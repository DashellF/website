var Mg = Object.defineProperty;
var Sg = (n, e, t) => e in n ? Mg(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t;
var Ye = (n, e, t) => (Sg(n, typeof e != "symbol" ? e + "" : e, t),
t);
function Fc(n, e) {
    const t = Object.create(null)
      , i = n.split(",");
    for (let r = 0; r < i.length; r++)
        t[i[r]] = !0;
    return e ? r => !!t[r.toLowerCase()] : r => !!t[r]
}
const rt = {}
  , Sr = []
  , yn = () => {}
  , Eg = () => !1
  , bg = /^on[^a-z]/
  , Vs = n => bg.test(n)
  , Oc = n => n.startsWith("onUpdate:")
  , _t = Object.assign
  , zc = (n, e) => {
    const t = n.indexOf(e);
    t > -1 && n.splice(t, 1)
}
  , Tg = Object.prototype.hasOwnProperty
  , Je = (n, e) => Tg.call(n, e)
  , Ie = Array.isArray
  , Er = n => Ws(n) === "[object Map]"
  , Fd = n => Ws(n) === "[object Set]"
  , wg = n => Ws(n) === "[object RegExp]"
  , He = n => typeof n == "function"
  , lt = n => typeof n == "string"
  , Bc = n => typeof n == "symbol"
  , tt = n => n !== null && typeof n == "object"
  , Od = n => tt(n) && He(n.then) && He(n.catch)
  , zd = Object.prototype.toString
  , Ws = n => zd.call(n)
  , Ag = n => Ws(n).slice(8, -1)
  , Bd = n => Ws(n) === "[object Object]"
  , Hc = n => lt(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n
  , ds = Fc(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , ma = n => {
    const e = Object.create(null);
    return t => e[t] || (e[t] = n(t))
}
  , Rg = /-(\w)/g
  , Pn = ma(n => n.replace(Rg, (e, t) => t ? t.toUpperCase() : ""))
  , Cg = /\B([A-Z])/g
  , Vr = ma(n => n.replace(Cg, "-$1").toLowerCase())
  , ga = ma(n => n.charAt(0).toUpperCase() + n.slice(1))
  , Wa = ma(n => n ? `on${ga(n)}` : "")
  , Rs = (n, e) => !Object.is(n, e)
  , ps = (n, e) => {
    for (let t = 0; t < n.length; t++)
        n[t](e)
}
  , Xo = (n, e, t) => {
    Object.defineProperty(n, e, {
        configurable: !0,
        enumerable: !1,
        value: t
    })
}
  , Pg = n => {
    const e = parseFloat(n);
    return isNaN(e) ? n : e
}
  , Hd = n => {
    const e = lt(n) ? Number(n) : NaN;
    return isNaN(e) ? n : e
}
;
let Uu;
const Wl = () => Uu || (Uu = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function _a(n) {
    if (Ie(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
            const i = n[t]
              , r = lt(i) ? Ug(i) : _a(i);
            if (r)
                for (const s in r)
                    e[s] = r[s]
        }
        return e
    } else {
        if (lt(n))
            return n;
        if (tt(n))
            return n
    }
}
const Lg = /;(?![^(]*\))/g
  , Dg = /:([^]+)/
  , Ig = /\/\*[^]*?\*\//g;
function Ug(n) {
    const e = {};
    return n.replace(Ig, "").split(Lg).forEach(t => {
        if (t) {
            const i = t.split(Dg);
            i.length > 1 && (e[i[0].trim()] = i[1].trim())
        }
    }
    ),
    e
}
function va(n) {
    let e = "";
    if (lt(n))
        e = n;
    else if (Ie(n))
        for (let t = 0; t < n.length; t++) {
            const i = va(n[t]);
            i && (e += i + " ")
        }
    else if (tt(n))
        for (const t in n)
            n[t] && (e += t + " ");
    return e.trim()
}
function Ng(n) {
    if (!n)
        return null;
    let {class: e, style: t} = n;
    return e && !lt(e) && (n.class = va(e)),
    t && (n.style = _a(t)),
    n
}
const Fg = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , Og = Fc(Fg);
function kd(n) {
    return !!n || n === ""
}
const UR = n => lt(n) ? n : n == null ? "" : Ie(n) || tt(n) && (n.toString === zd || !He(n.toString)) ? JSON.stringify(n, Gd, 2) : String(n)
  , Gd = (n, e) => e && e.__v_isRef ? Gd(n, e.value) : Er(e) ? {
    [`Map(${e.size})`]: [...e.entries()].reduce( (t, [i,r]) => (t[`${i} =>`] = r,
    t), {})
} : Fd(e) ? {
    [`Set(${e.size})`]: [...e.values()]
} : tt(e) && !Ie(e) && !Bd(e) ? String(e) : e;
let dn;
class zg {
    constructor(e=!1) {
        this.detached = e,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this.parent = dn,
        !e && dn && (this.index = (dn.scopes || (dn.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const t = dn;
            try {
                return dn = this,
                e()
            } finally {
                dn = t
            }
        }
    }
    on() {
        dn = this
    }
    off() {
        dn = this.parent
    }
    stop(e) {
        if (this._active) {
            let t, i;
            for (t = 0,
            i = this.effects.length; t < i; t++)
                this.effects[t].stop();
            for (t = 0,
            i = this.cleanups.length; t < i; t++)
                this.cleanups[t]();
            if (this.scopes)
                for (t = 0,
                i = this.scopes.length; t < i; t++)
                    this.scopes[t].stop(!0);
            if (!this.detached && this.parent && !e) {
                const r = this.parent.scopes.pop();
                r && r !== this && (this.parent.scopes[this.index] = r,
                r.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function Bg(n, e=dn) {
    e && e.active && e.effects.push(n)
}
function Hg() {
    return dn
}
const kc = n => {
    const e = new Set(n);
    return e.w = 0,
    e.n = 0,
    e
}
  , Vd = n => (n.w & xi) > 0
  , Wd = n => (n.n & xi) > 0
  , kg = ({deps: n}) => {
    if (n.length)
        for (let e = 0; e < n.length; e++)
            n[e].w |= xi
}
  , Gg = n => {
    const {deps: e} = n;
    if (e.length) {
        let t = 0;
        for (let i = 0; i < e.length; i++) {
            const r = e[i];
            Vd(r) && !Wd(r) ? r.delete(n) : e[t++] = r,
            r.w &= ~xi,
            r.n &= ~xi
        }
        e.length = t
    }
}
  , $o = new WeakMap;
let cs = 0
  , xi = 1;
const Xl = 30;
let mn;
const zi = Symbol("")
  , $l = Symbol("");
class Gc {
    constructor(e, t=null, i) {
        this.fn = e,
        this.scheduler = t,
        this.active = !0,
        this.deps = [],
        this.parent = void 0,
        Bg(this, i)
    }
    run() {
        if (!this.active)
            return this.fn();
        let e = mn
          , t = pi;
        for (; e; ) {
            if (e === this)
                return;
            e = e.parent
        }
        try {
            return this.parent = mn,
            mn = this,
            pi = !0,
            xi = 1 << ++cs,
            cs <= Xl ? kg(this) : Nu(this),
            this.fn()
        } finally {
            cs <= Xl && Gg(this),
            xi = 1 << --cs,
            mn = this.parent,
            pi = t,
            this.parent = void 0,
            this.deferStop && this.stop()
        }
    }
    stop() {
        mn === this ? this.deferStop = !0 : this.active && (Nu(this),
        this.onStop && this.onStop(),
        this.active = !1)
    }
}
function Nu(n) {
    const {deps: e} = n;
    if (e.length) {
        for (let t = 0; t < e.length; t++)
            e[t].delete(n);
        e.length = 0
    }
}
let pi = !0;
const Xd = [];
function Wr() {
    Xd.push(pi),
    pi = !1
}
function Xr() {
    const n = Xd.pop();
    pi = n === void 0 ? !0 : n
}
function Xt(n, e, t) {
    if (pi && mn) {
        let i = $o.get(n);
        i || $o.set(n, i = new Map);
        let r = i.get(t);
        r || i.set(t, r = kc()),
        $d(r)
    }
}
function $d(n, e) {
    let t = !1;
    cs <= Xl ? Wd(n) || (n.n |= xi,
    t = !Vd(n)) : t = !n.has(mn),
    t && (n.add(mn),
    mn.deps.push(n))
}
function qn(n, e, t, i, r, s) {
    const o = $o.get(n);
    if (!o)
        return;
    let a = [];
    if (e === "clear")
        a = [...o.values()];
    else if (t === "length" && Ie(n)) {
        const l = Number(i);
        o.forEach( (c, u) => {
            (u === "length" || u >= l) && a.push(c)
        }
        )
    } else
        switch (t !== void 0 && a.push(o.get(t)),
        e) {
        case "add":
            Ie(n) ? Hc(t) && a.push(o.get("length")) : (a.push(o.get(zi)),
            Er(n) && a.push(o.get($l)));
            break;
        case "delete":
            Ie(n) || (a.push(o.get(zi)),
            Er(n) && a.push(o.get($l)));
            break;
        case "set":
            Er(n) && a.push(o.get(zi));
            break
        }
    if (a.length === 1)
        a[0] && jl(a[0]);
    else {
        const l = [];
        for (const c of a)
            c && l.push(...c);
        jl(kc(l))
    }
}
function jl(n, e) {
    const t = Ie(n) ? n : [...n];
    for (const i of t)
        i.computed && Fu(i);
    for (const i of t)
        i.computed || Fu(i)
}
function Fu(n, e) {
    (n !== mn || n.allowRecurse) && (n.scheduler ? n.scheduler() : n.run())
}
function Vg(n, e) {
    var t;
    return (t = $o.get(n)) == null ? void 0 : t.get(e)
}
const Wg = Fc("__proto__,__v_isRef,__isVue")
  , jd = new Set(Object.getOwnPropertyNames(Symbol).filter(n => n !== "arguments" && n !== "caller").map(n => Symbol[n]).filter(Bc))
  , Xg = Vc()
  , $g = Vc(!1, !0)
  , jg = Vc(!0)
  , Ou = Kg();
function Kg() {
    const n = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        n[e] = function(...t) {
            const i = Ze(this);
            for (let s = 0, o = this.length; s < o; s++)
                Xt(i, "get", s + "");
            const r = i[e](...t);
            return r === -1 || r === !1 ? i[e](...t.map(Ze)) : r
        }
    }
    ),
    ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        n[e] = function(...t) {
            Wr();
            const i = Ze(this)[e].apply(this, t);
            return Xr(),
            i
        }
    }
    ),
    n
}
function qg(n) {
    const e = Ze(this);
    return Xt(e, "has", n),
    e.hasOwnProperty(n)
}
function Vc(n=!1, e=!1) {
    return function(i, r, s) {
        if (r === "__v_isReactive")
            return !n;
        if (r === "__v_isReadonly")
            return n;
        if (r === "__v_isShallow")
            return e;
        if (r === "__v_raw" && s === (n ? e ? h_ : Zd : e ? Jd : Yd).get(i))
            return i;
        const o = Ie(i);
        if (!n) {
            if (o && Je(Ou, r))
                return Reflect.get(Ou, r, s);
            if (r === "hasOwnProperty")
                return qg
        }
        const a = Reflect.get(i, r, s);
        return (Bc(r) ? jd.has(r) : Wg(r)) || (n || Xt(i, "get", r),
        e) ? a : Et(a) ? o && Hc(r) ? a : a.value : tt(a) ? n ? Qd(a) : yi(a) : a
    }
}
const Yg = Kd()
  , Jg = Kd(!0);
function Kd(n=!1) {
    return function(t, i, r, s) {
        let o = t[i];
        if (Vi(o) && Et(o) && !Et(r))
            return !1;
        if (!n && (!jo(r) && !Vi(r) && (o = Ze(o),
        r = Ze(r)),
        !Ie(t) && Et(o) && !Et(r)))
            return o.value = r,
            !0;
        const a = Ie(t) && Hc(i) ? Number(i) < t.length : Je(t, i)
          , l = Reflect.set(t, i, r, s);
        return t === Ze(s) && (a ? Rs(r, o) && qn(t, "set", i, r) : qn(t, "add", i, r)),
        l
    }
}
function Zg(n, e) {
    const t = Je(n, e);
    n[e];
    const i = Reflect.deleteProperty(n, e);
    return i && t && qn(n, "delete", e, void 0),
    i
}
function Qg(n, e) {
    const t = Reflect.has(n, e);
    return (!Bc(e) || !jd.has(e)) && Xt(n, "has", e),
    t
}
function e_(n) {
    return Xt(n, "iterate", Ie(n) ? "length" : zi),
    Reflect.ownKeys(n)
}
const qd = {
    get: Xg,
    set: Yg,
    deleteProperty: Zg,
    has: Qg,
    ownKeys: e_
}
  , t_ = {
    get: jg,
    set(n, e) {
        return !0
    },
    deleteProperty(n, e) {
        return !0
    }
}
  , n_ = _t({}, qd, {
    get: $g,
    set: Jg
})
  , Wc = n => n
  , xa = n => Reflect.getPrototypeOf(n);
function eo(n, e, t=!1, i=!1) {
    n = n.__v_raw;
    const r = Ze(n)
      , s = Ze(e);
    t || (e !== s && Xt(r, "get", e),
    Xt(r, "get", s));
    const {has: o} = xa(r)
      , a = i ? Wc : t ? jc : Cs;
    if (o.call(r, e))
        return a(n.get(e));
    if (o.call(r, s))
        return a(n.get(s));
    n !== r && n.get(e)
}
function to(n, e=!1) {
    const t = this.__v_raw
      , i = Ze(t)
      , r = Ze(n);
    return e || (n !== r && Xt(i, "has", n),
    Xt(i, "has", r)),
    n === r ? t.has(n) : t.has(n) || t.has(r)
}
function no(n, e=!1) {
    return n = n.__v_raw,
    !e && Xt(Ze(n), "iterate", zi),
    Reflect.get(n, "size", n)
}
function zu(n) {
    n = Ze(n);
    const e = Ze(this);
    return xa(e).has.call(e, n) || (e.add(n),
    qn(e, "add", n, n)),
    this
}
function Bu(n, e) {
    e = Ze(e);
    const t = Ze(this)
      , {has: i, get: r} = xa(t);
    let s = i.call(t, n);
    s || (n = Ze(n),
    s = i.call(t, n));
    const o = r.call(t, n);
    return t.set(n, e),
    s ? Rs(e, o) && qn(t, "set", n, e) : qn(t, "add", n, e),
    this
}
function Hu(n) {
    const e = Ze(this)
      , {has: t, get: i} = xa(e);
    let r = t.call(e, n);
    r || (n = Ze(n),
    r = t.call(e, n)),
    i && i.call(e, n);
    const s = e.delete(n);
    return r && qn(e, "delete", n, void 0),
    s
}
function ku() {
    const n = Ze(this)
      , e = n.size !== 0
      , t = n.clear();
    return e && qn(n, "clear", void 0, void 0),
    t
}
function io(n, e) {
    return function(i, r) {
        const s = this
          , o = s.__v_raw
          , a = Ze(o)
          , l = e ? Wc : n ? jc : Cs;
        return !n && Xt(a, "iterate", zi),
        o.forEach( (c, u) => i.call(r, l(c), l(u), s))
    }
}
function ro(n, e, t) {
    return function(...i) {
        const r = this.__v_raw
          , s = Ze(r)
          , o = Er(s)
          , a = n === "entries" || n === Symbol.iterator && o
          , l = n === "keys" && o
          , c = r[n](...i)
          , u = t ? Wc : e ? jc : Cs;
        return !e && Xt(s, "iterate", l ? $l : zi),
        {
            next() {
                const {value: h, done: f} = c.next();
                return f ? {
                    value: h,
                    done: f
                } : {
                    value: a ? [u(h[0]), u(h[1])] : u(h),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function ei(n) {
    return function(...e) {
        return n === "delete" ? !1 : this
    }
}
function i_() {
    const n = {
        get(s) {
            return eo(this, s)
        },
        get size() {
            return no(this)
        },
        has: to,
        add: zu,
        set: Bu,
        delete: Hu,
        clear: ku,
        forEach: io(!1, !1)
    }
      , e = {
        get(s) {
            return eo(this, s, !1, !0)
        },
        get size() {
            return no(this)
        },
        has: to,
        add: zu,
        set: Bu,
        delete: Hu,
        clear: ku,
        forEach: io(!1, !0)
    }
      , t = {
        get(s) {
            return eo(this, s, !0)
        },
        get size() {
            return no(this, !0)
        },
        has(s) {
            return to.call(this, s, !0)
        },
        add: ei("add"),
        set: ei("set"),
        delete: ei("delete"),
        clear: ei("clear"),
        forEach: io(!0, !1)
    }
      , i = {
        get(s) {
            return eo(this, s, !0, !0)
        },
        get size() {
            return no(this, !0)
        },
        has(s) {
            return to.call(this, s, !0)
        },
        add: ei("add"),
        set: ei("set"),
        delete: ei("delete"),
        clear: ei("clear"),
        forEach: io(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        n[s] = ro(s, !1, !1),
        t[s] = ro(s, !0, !1),
        e[s] = ro(s, !1, !0),
        i[s] = ro(s, !0, !0)
    }
    ),
    [n, t, e, i]
}
const [r_,s_,o_,a_] = i_();
function Xc(n, e) {
    const t = e ? n ? a_ : o_ : n ? s_ : r_;
    return (i, r, s) => r === "__v_isReactive" ? !n : r === "__v_isReadonly" ? n : r === "__v_raw" ? i : Reflect.get(Je(t, r) && r in i ? t : i, r, s)
}
const l_ = {
    get: Xc(!1, !1)
}
  , c_ = {
    get: Xc(!1, !0)
}
  , u_ = {
    get: Xc(!0, !1)
}
  , Yd = new WeakMap
  , Jd = new WeakMap
  , Zd = new WeakMap
  , h_ = new WeakMap;
function f_(n) {
    switch (n) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function d_(n) {
    return n.__v_skip || !Object.isExtensible(n) ? 0 : f_(Ag(n))
}
function yi(n) {
    return Vi(n) ? n : $c(n, !1, qd, l_, Yd)
}
function Xs(n) {
    return $c(n, !1, n_, c_, Jd)
}
function Qd(n) {
    return $c(n, !0, t_, u_, Zd)
}
function $c(n, e, t, i, r) {
    if (!tt(n) || n.__v_raw && !(e && n.__v_isReactive))
        return n;
    const s = r.get(n);
    if (s)
        return s;
    const o = d_(n);
    if (o === 0)
        return n;
    const a = new Proxy(n,o === 2 ? i : t);
    return r.set(n, a),
    a
}
function br(n) {
    return Vi(n) ? br(n.__v_raw) : !!(n && n.__v_isReactive)
}
function Vi(n) {
    return !!(n && n.__v_isReadonly)
}
function jo(n) {
    return !!(n && n.__v_isShallow)
}
function ep(n) {
    return br(n) || Vi(n)
}
function Ze(n) {
    const e = n && n.__v_raw;
    return e ? Ze(e) : n
}
function tp(n) {
    return Xo(n, "__v_skip", !0),
    n
}
const Cs = n => tt(n) ? yi(n) : n
  , jc = n => tt(n) ? Qd(n) : n;
function np(n) {
    pi && mn && (n = Ze(n),
    $d(n.dep || (n.dep = kc())))
}
function ip(n, e) {
    n = Ze(n);
    const t = n.dep;
    t && jl(t)
}
function Et(n) {
    return !!(n && n.__v_isRef === !0)
}
function Rn(n) {
    return rp(n, !1)
}
function Ps(n) {
    return rp(n, !0)
}
function rp(n, e) {
    return Et(n) ? n : new p_(n,e)
}
class p_ {
    constructor(e, t) {
        this.__v_isShallow = t,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = t ? e : Ze(e),
        this._value = t ? e : Cs(e)
    }
    get value() {
        return np(this),
        this._value
    }
    set value(e) {
        const t = this.__v_isShallow || jo(e) || Vi(e);
        e = t ? e : Ze(e),
        Rs(e, this._rawValue) && (this._rawValue = e,
        this._value = t ? e : Cs(e),
        ip(this))
    }
}
function st(n) {
    return Et(n) ? n.value : n
}
const m_ = {
    get: (n, e, t) => st(Reflect.get(n, e, t)),
    set: (n, e, t, i) => {
        const r = n[e];
        return Et(r) && !Et(t) ? (r.value = t,
        !0) : Reflect.set(n, e, t, i)
    }
};
function sp(n) {
    return br(n) ? n : new Proxy(n,m_)
}
class g_ {
    constructor(e, t, i) {
        this._object = e,
        this._key = t,
        this._defaultValue = i,
        this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return Vg(Ze(this._object), this._key)
    }
}
class __ {
    constructor(e) {
        this._getter = e,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}
function v_(n, e, t) {
    return Et(n) ? n : He(n) ? new __(n) : tt(n) && arguments.length > 1 ? x_(n, e, t) : Rn(n)
}
function x_(n, e, t) {
    const i = n[e];
    return Et(i) ? i : new g_(n,e,t)
}
class y_ {
    constructor(e, t, i, r) {
        this._setter = t,
        this.dep = void 0,
        this.__v_isRef = !0,
        this.__v_isReadonly = !1,
        this._dirty = !0,
        this.effect = new Gc(e, () => {
            this._dirty || (this._dirty = !0,
            ip(this))
        }
        ),
        this.effect.computed = this,
        this.effect.active = this._cacheable = !r,
        this.__v_isReadonly = i
    }
    get value() {
        const e = Ze(this);
        return np(e),
        (e._dirty || !e._cacheable) && (e._dirty = !1,
        e._value = e.effect.run()),
        e._value
    }
    set value(e) {
        this._setter(e)
    }
}
function M_(n, e, t=!1) {
    let i, r;
    const s = He(n);
    return s ? (i = n,
    r = yn) : (i = n.get,
    r = n.set),
    new y_(i,r,s || !r,t)
}
function mi(n, e, t, i) {
    let r;
    try {
        r = i ? n(...i) : n()
    } catch (s) {
        $r(s, e, t)
    }
    return r
}
function ln(n, e, t, i) {
    if (He(n)) {
        const s = mi(n, e, t, i);
        return s && Od(s) && s.catch(o => {
            $r(o, e, t)
        }
        ),
        s
    }
    const r = [];
    for (let s = 0; s < n.length; s++)
        r.push(ln(n[s], e, t, i));
    return r
}
function $r(n, e, t, i=!0) {
    const r = e ? e.vnode : null;
    if (e) {
        let s = e.parent;
        const o = e.proxy
          , a = t;
        for (; s; ) {
            const c = s.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](n, o, a) === !1)
                        return
            }
            s = s.parent
        }
        const l = e.appContext.config.errorHandler;
        if (l) {
            mi(l, null, 10, [n, o, a]);
            return
        }
    }
    S_(n, t, r, i)
}
function S_(n, e, t, i=!0) {
    console.error(n)
}
let Ls = !1
  , Kl = !1;
const Dt = [];
let wn = 0;
const Tr = [];
let Vn = null
  , Ni = 0;
const op = Promise.resolve();
let Kc = null;
function jr(n) {
    const e = Kc || op;
    return n ? e.then(this ? n.bind(this) : n) : e
}
function E_(n) {
    let e = wn + 1
      , t = Dt.length;
    for (; e < t; ) {
        const i = e + t >>> 1;
        Ds(Dt[i]) < n ? e = i + 1 : t = i
    }
    return e
}
function ya(n) {
    (!Dt.length || !Dt.includes(n, Ls && n.allowRecurse ? wn + 1 : wn)) && (n.id == null ? Dt.push(n) : Dt.splice(E_(n.id), 0, n),
    ap())
}
function ap() {
    !Ls && !Kl && (Kl = !0,
    Kc = op.then(cp))
}
function b_(n) {
    const e = Dt.indexOf(n);
    e > wn && Dt.splice(e, 1)
}
function lp(n) {
    Ie(n) ? Tr.push(...n) : (!Vn || !Vn.includes(n, n.allowRecurse ? Ni + 1 : Ni)) && Tr.push(n),
    ap()
}
function Gu(n, e=Ls ? wn + 1 : 0) {
    for (; e < Dt.length; e++) {
        const t = Dt[e];
        t && t.pre && (Dt.splice(e, 1),
        e--,
        t())
    }
}
function Ko(n) {
    if (Tr.length) {
        const e = [...new Set(Tr)];
        if (Tr.length = 0,
        Vn) {
            Vn.push(...e);
            return
        }
        for (Vn = e,
        Vn.sort( (t, i) => Ds(t) - Ds(i)),
        Ni = 0; Ni < Vn.length; Ni++)
            Vn[Ni]();
        Vn = null,
        Ni = 0
    }
}
const Ds = n => n.id == null ? 1 / 0 : n.id
  , T_ = (n, e) => {
    const t = Ds(n) - Ds(e);
    if (t === 0) {
        if (n.pre && !e.pre)
            return -1;
        if (e.pre && !n.pre)
            return 1
    }
    return t
}
;
function cp(n) {
    Kl = !1,
    Ls = !0,
    Dt.sort(T_);
    const e = yn;
    try {
        for (wn = 0; wn < Dt.length; wn++) {
            const t = Dt[wn];
            t && t.active !== !1 && mi(t, null, 14)
        }
    } finally {
        wn = 0,
        Dt.length = 0,
        Ko(),
        Ls = !1,
        Kc = null,
        (Dt.length || Tr.length) && cp()
    }
}
function w_(n, e, ...t) {
    if (n.isUnmounted)
        return;
    const i = n.vnode.props || rt;
    let r = t;
    const s = e.startsWith("update:")
      , o = s && e.slice(7);
    if (o && o in i) {
        const u = `${o === "modelValue" ? "model" : o}Modifiers`
          , {number: h, trim: f} = i[u] || rt;
        f && (r = t.map(p => lt(p) ? p.trim() : p)),
        h && (r = t.map(Pg))
    }
    let a, l = i[a = Wa(e)] || i[a = Wa(Pn(e))];
    !l && s && (l = i[a = Wa(Vr(e))]),
    l && ln(l, n, 6, r);
    const c = i[a + "Once"];
    if (c) {
        if (!n.emitted)
            n.emitted = {};
        else if (n.emitted[a])
            return;
        n.emitted[a] = !0,
        ln(c, n, 6, r)
    }
}
function up(n, e, t=!1) {
    const i = e.emitsCache
      , r = i.get(n);
    if (r !== void 0)
        return r;
    const s = n.emits;
    let o = {}
      , a = !1;
    if (!He(n)) {
        const l = c => {
            const u = up(c, e, !0);
            u && (a = !0,
            _t(o, u))
        }
        ;
        !t && e.mixins.length && e.mixins.forEach(l),
        n.extends && l(n.extends),
        n.mixins && n.mixins.forEach(l)
    }
    return !s && !a ? (tt(n) && i.set(n, null),
    null) : (Ie(s) ? s.forEach(l => o[l] = null) : _t(o, s),
    tt(n) && i.set(n, o),
    o)
}
function Ma(n, e) {
    return !n || !Vs(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""),
    Je(n, e[0].toLowerCase() + e.slice(1)) || Je(n, Vr(e)) || Je(n, e))
}
let Yt = null
  , Sa = null;
function qo(n) {
    const e = Yt;
    return Yt = n,
    Sa = n && n.type.__scopeId || null,
    e
}
function NR(n) {
    Sa = n
}
function FR() {
    Sa = null
}
function qc(n, e=Yt, t) {
    if (!e || n._n)
        return n;
    const i = (...r) => {
        i._d && nh(-1);
        const s = qo(e);
        let o;
        try {
            o = n(...r)
        } finally {
            qo(s),
            i._d && nh(1)
        }
        return o
    }
    ;
    return i._n = !0,
    i._c = !0,
    i._d = !0,
    i
}
function Xa(n) {
    const {type: e, vnode: t, proxy: i, withProxy: r, props: s, propsOptions: [o], slots: a, attrs: l, emit: c, render: u, renderCache: h, data: f, setupState: p, ctx: g, inheritAttrs: x} = n;
    let m, d;
    const v = qo(n);
    try {
        if (t.shapeFlag & 4) {
            const M = r || i;
            m = rn(u.call(M, M, h, s, p, f, g)),
            d = l
        } else {
            const M = e;
            m = rn(M.length > 1 ? M(s, {
                attrs: l,
                slots: a,
                emit: c
            }) : M(s, null)),
            d = e.props ? l : R_(l)
        }
    } catch (M) {
        vs.length = 0,
        $r(M, n, 1),
        m = at(cn)
    }
    let _ = m;
    if (d && x !== !1) {
        const M = Object.keys(d)
          , {shapeFlag: b} = _;
        M.length && b & 7 && (o && M.some(Oc) && (d = C_(d, o)),
        _ = Yn(_, d))
    }
    return t.dirs && (_ = Yn(_),
    _.dirs = _.dirs ? _.dirs.concat(t.dirs) : t.dirs),
    t.transition && (_.transition = t.transition),
    m = _,
    qo(v),
    m
}
function A_(n) {
    let e;
    for (let t = 0; t < n.length; t++) {
        const i = n[t];
        if (Ns(i)) {
            if (i.type !== cn || i.children === "v-if") {
                if (e)
                    return;
                e = i
            }
        } else
            return
    }
    return e
}
const R_ = n => {
    let e;
    for (const t in n)
        (t === "class" || t === "style" || Vs(t)) && ((e || (e = {}))[t] = n[t]);
    return e
}
  , C_ = (n, e) => {
    const t = {};
    for (const i in n)
        (!Oc(i) || !(i.slice(9)in e)) && (t[i] = n[i]);
    return t
}
;
function P_(n, e, t) {
    const {props: i, children: r, component: s} = n
      , {props: o, children: a, patchFlag: l} = e
      , c = s.emitsOptions;
    if (e.dirs || e.transition)
        return !0;
    if (t && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return i ? Vu(i, o, c) : !!o;
        if (l & 8) {
            const u = e.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                const f = u[h];
                if (o[f] !== i[f] && !Ma(c, f))
                    return !0
            }
        }
    } else
        return (r || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? o ? Vu(i, o, c) : !0 : !!o;
    return !1
}
function Vu(n, e, t) {
    const i = Object.keys(e);
    if (i.length !== Object.keys(n).length)
        return !0;
    for (let r = 0; r < i.length; r++) {
        const s = i[r];
        if (e[s] !== n[s] && !Ma(t, s))
            return !0
    }
    return !1
}
function Yc({vnode: n, parent: e}, t) {
    for (; e && e.subTree === n; )
        (n = e.vnode).el = t,
        e = e.parent
}
const hp = n => n.__isSuspense
  , L_ = {
    name: "Suspense",
    __isSuspense: !0,
    process(n, e, t, i, r, s, o, a, l, c) {
        n == null ? D_(e, t, i, r, s, o, a, l, c) : I_(n, e, t, i, r, o, a, l, c)
    },
    hydrate: U_,
    create: Jc,
    normalize: N_
}
  , fp = L_;
function Is(n, e) {
    const t = n.props && n.props[e];
    He(t) && t()
}
function D_(n, e, t, i, r, s, o, a, l) {
    const {p: c, o: {createElement: u}} = l
      , h = u("div")
      , f = n.suspense = Jc(n, r, i, e, h, t, s, o, a, l);
    c(null, f.pendingBranch = n.ssContent, h, null, i, f, s, o),
    f.deps > 0 ? (Is(n, "onPending"),
    Is(n, "onFallback"),
    c(null, n.ssFallback, e, t, i, null, s, o),
    wr(f, n.ssFallback)) : f.resolve(!1, !0)
}
function I_(n, e, t, i, r, s, o, a, {p: l, um: c, o: {createElement: u}}) {
    const h = e.suspense = n.suspense;
    h.vnode = e,
    e.el = n.el;
    const f = e.ssContent
      , p = e.ssFallback
      , {activeBranch: g, pendingBranch: x, isInFallback: m, isHydrating: d} = h;
    if (x)
        h.pendingBranch = f,
        gn(f, x) ? (l(x, f, h.hiddenContainer, null, r, h, s, o, a),
        h.deps <= 0 ? h.resolve() : m && (l(g, p, t, i, r, null, s, o, a),
        wr(h, p))) : (h.pendingId++,
        d ? (h.isHydrating = !1,
        h.activeBranch = x) : c(x, r, h),
        h.deps = 0,
        h.effects.length = 0,
        h.hiddenContainer = u("div"),
        m ? (l(null, f, h.hiddenContainer, null, r, h, s, o, a),
        h.deps <= 0 ? h.resolve() : (l(g, p, t, i, r, null, s, o, a),
        wr(h, p))) : g && gn(f, g) ? (l(g, f, t, i, r, h, s, o, a),
        h.resolve(!0)) : (l(null, f, h.hiddenContainer, null, r, h, s, o, a),
        h.deps <= 0 && h.resolve()));
    else if (g && gn(f, g))
        l(g, f, t, i, r, h, s, o, a),
        wr(h, f);
    else if (Is(e, "onPending"),
    h.pendingBranch = f,
    h.pendingId++,
    l(null, f, h.hiddenContainer, null, r, h, s, o, a),
    h.deps <= 0)
        h.resolve();
    else {
        const {timeout: v, pendingId: _} = h;
        v > 0 ? setTimeout( () => {
            h.pendingId === _ && h.fallback(p)
        }
        , v) : v === 0 && h.fallback(p)
    }
}
function Jc(n, e, t, i, r, s, o, a, l, c, u=!1) {
    const {p: h, m: f, um: p, n: g, o: {parentNode: x, remove: m}} = c;
    let d;
    const v = F_(n);
    v && e != null && e.pendingBranch && (d = e.pendingId,
    e.deps++);
    const _ = n.props ? Hd(n.props.timeout) : void 0
      , M = {
        vnode: n,
        parent: e,
        parentComponent: t,
        isSVG: o,
        container: i,
        hiddenContainer: r,
        anchor: s,
        deps: 0,
        pendingId: 0,
        timeout: typeof _ == "number" ? _ : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !0,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(b=!1, A=!1) {
            const {vnode: C, activeBranch: P, pendingBranch: S, pendingId: T, effects: F, parentComponent: k, container: X} = M;
            if (M.isHydrating)
                M.isHydrating = !1;
            else if (!b) {
                const V = P && S.transition && S.transition.mode === "out-in";
                V && (P.transition.afterLeave = () => {
                    T === M.pendingId && f(S, X, $, 0)
                }
                );
                let {anchor: $} = M;
                P && ($ = g(P),
                p(P, k, M, !0)),
                V || f(S, X, $, 0)
            }
            wr(M, S),
            M.pendingBranch = null,
            M.isInFallback = !1;
            let L = M.parent
              , G = !1;
            for (; L; ) {
                if (L.pendingBranch) {
                    L.effects.push(...F),
                    G = !0;
                    break
                }
                L = L.parent
            }
            G || lp(F),
            M.effects = [],
            v && e && e.pendingBranch && d === e.pendingId && (e.deps--,
            e.deps === 0 && !A && e.resolve()),
            Is(C, "onResolve")
        },
        fallback(b) {
            if (!M.pendingBranch)
                return;
            const {vnode: A, activeBranch: C, parentComponent: P, container: S, isSVG: T} = M;
            Is(A, "onFallback");
            const F = g(C)
              , k = () => {
                M.isInFallback && (h(null, b, S, F, P, null, T, a, l),
                wr(M, b))
            }
              , X = b.transition && b.transition.mode === "out-in";
            X && (C.transition.afterLeave = k),
            M.isInFallback = !0,
            p(C, P, null, !0),
            X || k()
        },
        move(b, A, C) {
            M.activeBranch && f(M.activeBranch, b, A, C),
            M.container = b
        },
        next() {
            return M.activeBranch && g(M.activeBranch)
        },
        registerDep(b, A) {
            const C = !!M.pendingBranch;
            C && M.deps++;
            const P = b.vnode.el;
            b.asyncDep.catch(S => {
                $r(S, b, 0)
            }
            ).then(S => {
                if (b.isUnmounted || M.isUnmounted || M.pendingId !== b.suspenseId)
                    return;
                b.asyncResolved = !0;
                const {vnode: T} = b;
                ec(b, S, !1),
                P && (T.el = P);
                const F = !P && b.subTree.el;
                A(b, T, x(P || b.subTree.el), P ? null : g(b.subTree), M, o, l),
                F && m(F),
                Yc(b, T.el),
                C && --M.deps === 0 && M.resolve()
            }
            )
        },
        unmount(b, A) {
            M.isUnmounted = !0,
            M.activeBranch && p(M.activeBranch, t, b, A),
            M.pendingBranch && p(M.pendingBranch, t, b, A)
        }
    };
    return M
}
function U_(n, e, t, i, r, s, o, a, l) {
    const c = e.suspense = Jc(e, i, t, n.parentNode, document.createElement("div"), null, r, s, o, a, !0)
      , u = l(n, c.pendingBranch = e.ssContent, t, c, s, o);
    return c.deps === 0 && c.resolve(!1, !0),
    u
}
function N_(n) {
    const {shapeFlag: e, children: t} = n
      , i = e & 32;
    n.ssContent = Wu(i ? t.default : t),
    n.ssFallback = i ? Wu(t.fallback) : at(cn)
}
function Wu(n) {
    let e;
    if (He(n)) {
        const t = Ir && n._c;
        t && (n._d = !1,
        Wn()),
        n = n(),
        t && (n._d = !0,
        e = an,
        Up())
    }
    return Ie(n) && (n = A_(n)),
    n = rn(n),
    e && !n.dynamicChildren && (n.dynamicChildren = e.filter(t => t !== n)),
    n
}
function dp(n, e) {
    e && e.pendingBranch ? Ie(n) ? e.effects.push(...n) : e.effects.push(n) : lp(n)
}
function wr(n, e) {
    n.activeBranch = e;
    const {vnode: t, parentComponent: i} = n
      , r = t.el = e.el;
    i && i.subTree === t && (i.vnode.el = r,
    Yc(i, r))
}
function F_(n) {
    var e;
    return ((e = n.props) == null ? void 0 : e.suspensible) != null && n.props.suspensible !== !1
}
function OR(n, e) {
    return Zc(n, null, e)
}
const so = {};
function ms(n, e, t) {
    return Zc(n, e, t)
}
function Zc(n, e, {immediate: t, deep: i, flush: r, onTrack: s, onTrigger: o}=rt) {
    var a;
    const l = Hg() === ((a = gt) == null ? void 0 : a.scope) ? gt : null;
    let c, u = !1, h = !1;
    if (Et(n) ? (c = () => n.value,
    u = jo(n)) : br(n) ? (c = () => n,
    i = !0) : Ie(n) ? (h = !0,
    u = n.some(M => br(M) || jo(M)),
    c = () => n.map(M => {
        if (Et(M))
            return M.value;
        if (br(M))
            return vr(M);
        if (He(M))
            return mi(M, l, 2)
    }
    )) : He(n) ? e ? c = () => mi(n, l, 2) : c = () => {
        if (!(l && l.isUnmounted))
            return f && f(),
            ln(n, l, 3, [p])
    }
    : c = yn,
    e && i) {
        const M = c;
        c = () => vr(M())
    }
    let f, p = M => {
        f = v.onStop = () => {
            mi(M, l, 4)
        }
    }
    , g;
    if (Nr)
        if (p = yn,
        e ? t && ln(e, l, 3, [c(), h ? [] : void 0, p]) : c(),
        r === "sync") {
            const M = Av();
            g = M.__watcherHandles || (M.__watcherHandles = [])
        } else
            return yn;
    let x = h ? new Array(n.length).fill(so) : so;
    const m = () => {
        if (v.active)
            if (e) {
                const M = v.run();
                (i || u || (h ? M.some( (b, A) => Rs(b, x[A])) : Rs(M, x))) && (f && f(),
                ln(e, l, 3, [M, x === so ? void 0 : h && x[0] === so ? [] : x, p]),
                x = M)
            } else
                v.run()
    }
    ;
    m.allowRecurse = !!e;
    let d;
    r === "sync" ? d = m : r === "post" ? d = () => wt(m, l && l.suspense) : (m.pre = !0,
    l && (m.id = l.uid),
    d = () => ya(m));
    const v = new Gc(c,d);
    e ? t ? m() : x = v.run() : r === "post" ? wt(v.run.bind(v), l && l.suspense) : v.run();
    const _ = () => {
        v.stop(),
        l && l.scope && zc(l.scope.effects, v)
    }
    ;
    return g && g.push(_),
    _
}
function O_(n, e, t) {
    const i = this.proxy
      , r = lt(n) ? n.includes(".") ? pp(i, n) : () => i[n] : n.bind(i, i);
    let s;
    He(e) ? s = e : (s = e.handler,
    t = e);
    const o = gt;
    Ur(this);
    const a = Zc(r, s.bind(i), t);
    return o ? Ur(o) : Bi(),
    a
}
function pp(n, e) {
    const t = e.split(".");
    return () => {
        let i = n;
        for (let r = 0; r < t.length && i; r++)
            i = i[t[r]];
        return i
    }
}
function vr(n, e) {
    if (!tt(n) || n.__v_skip || (e = e || new Set,
    e.has(n)))
        return n;
    if (e.add(n),
    Et(n))
        vr(n.value, e);
    else if (Ie(n))
        for (let t = 0; t < n.length; t++)
            vr(n[t], e);
    else if (Fd(n) || Er(n))
        n.forEach(t => {
            vr(t, e)
        }
        );
    else if (Bd(n))
        for (const t in n)
            vr(n[t], e);
    return n
}
function bn(n, e, t, i) {
    const r = n.dirs
      , s = e && e.dirs;
    for (let o = 0; o < r.length; o++) {
        const a = r[o];
        s && (a.oldValue = s[o].value);
        let l = a.dir[i];
        l && (Wr(),
        ln(l, t, 8, [n.el, a, n, e]),
        Xr())
    }
}
function z_() {
    const n = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return js( () => {
        n.isMounted = !0
    }
    ),
    Qc( () => {
        n.isUnmounting = !0
    }
    ),
    n
}
const en = [Function, Array]
  , mp = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: en,
    onEnter: en,
    onAfterEnter: en,
    onEnterCancelled: en,
    onBeforeLeave: en,
    onLeave: en,
    onAfterLeave: en,
    onLeaveCancelled: en,
    onBeforeAppear: en,
    onAppear: en,
    onAfterAppear: en,
    onAppearCancelled: en
}
  , B_ = {
    name: "BaseTransition",
    props: mp,
    setup(n, {slots: e}) {
        const t = ou()
          , i = z_();
        let r;
        return () => {
            const s = e.default && _p(e.default(), !0);
            if (!s || !s.length)
                return;
            let o = s[0];
            if (s.length > 1) {
                for (const x of s)
                    if (x.type !== cn) {
                        o = x;
                        break
                    }
            }
            const a = Ze(n)
              , {mode: l} = a;
            if (i.isLeaving)
                return $a(o);
            const c = Xu(o);
            if (!c)
                return $a(o);
            const u = ql(c, a, i, t);
            Yo(c, u);
            const h = t.subTree
              , f = h && Xu(h);
            let p = !1;
            const {getTransitionKey: g} = c.type;
            if (g) {
                const x = g();
                r === void 0 ? r = x : x !== r && (r = x,
                p = !0)
            }
            if (f && f.type !== cn && (!gn(c, f) || p)) {
                const x = ql(f, a, i, t);
                if (Yo(f, x),
                l === "out-in")
                    return i.isLeaving = !0,
                    x.afterLeave = () => {
                        i.isLeaving = !1,
                        t.update.active !== !1 && t.update()
                    }
                    ,
                    $a(o);
                l === "in-out" && c.type !== cn && (x.delayLeave = (m, d, v) => {
                    const _ = gp(i, f);
                    _[String(f.key)] = f,
                    m._leaveCb = () => {
                        d(),
                        m._leaveCb = void 0,
                        delete u.delayedLeave
                    }
                    ,
                    u.delayedLeave = v
                }
                )
            }
            return o
        }
    }
}
  , H_ = B_;
function gp(n, e) {
    const {leavingVNodes: t} = n;
    let i = t.get(e.type);
    return i || (i = Object.create(null),
    t.set(e.type, i)),
    i
}
function ql(n, e, t, i) {
    const {appear: r, mode: s, persisted: o=!1, onBeforeEnter: a, onEnter: l, onAfterEnter: c, onEnterCancelled: u, onBeforeLeave: h, onLeave: f, onAfterLeave: p, onLeaveCancelled: g, onBeforeAppear: x, onAppear: m, onAfterAppear: d, onAppearCancelled: v} = e
      , _ = String(n.key)
      , M = gp(t, n)
      , b = (P, S) => {
        P && ln(P, i, 9, S)
    }
      , A = (P, S) => {
        const T = S[1];
        b(P, S),
        Ie(P) ? P.every(F => F.length <= 1) && T() : P.length <= 1 && T()
    }
      , C = {
        mode: s,
        persisted: o,
        beforeEnter(P) {
            let S = a;
            if (!t.isMounted)
                if (r)
                    S = x || a;
                else
                    return;
            P._leaveCb && P._leaveCb(!0);
            const T = M[_];
            T && gn(n, T) && T.el._leaveCb && T.el._leaveCb(),
            b(S, [P])
        },
        enter(P) {
            let S = l
              , T = c
              , F = u;
            if (!t.isMounted)
                if (r)
                    S = m || l,
                    T = d || c,
                    F = v || u;
                else
                    return;
            let k = !1;
            const X = P._enterCb = L => {
                k || (k = !0,
                L ? b(F, [P]) : b(T, [P]),
                C.delayedLeave && C.delayedLeave(),
                P._enterCb = void 0)
            }
            ;
            S ? A(S, [P, X]) : X()
        },
        leave(P, S) {
            const T = String(n.key);
            if (P._enterCb && P._enterCb(!0),
            t.isUnmounting)
                return S();
            b(h, [P]);
            let F = !1;
            const k = P._leaveCb = X => {
                F || (F = !0,
                S(),
                X ? b(g, [P]) : b(p, [P]),
                P._leaveCb = void 0,
                M[T] === n && delete M[T])
            }
            ;
            M[T] = n,
            f ? A(f, [P, k]) : k()
        },
        clone(P) {
            return ql(P, e, t, i)
        }
    };
    return C
}
function $a(n) {
    if ($s(n))
        return n = Yn(n),
        n.children = null,
        n
}
function Xu(n) {
    return $s(n) ? n.children ? n.children[0] : void 0 : n
}
function Yo(n, e) {
    n.shapeFlag & 6 && n.component ? Yo(n.component.subTree, e) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent),
    n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e
}
function _p(n, e=!1, t) {
    let i = []
      , r = 0;
    for (let s = 0; s < n.length; s++) {
        let o = n[s];
        const a = t == null ? o.key : String(t) + String(o.key != null ? o.key : s);
        o.type === nn ? (o.patchFlag & 128 && r++,
        i = i.concat(_p(o.children, e, a))) : (e || o.type !== cn) && i.push(a != null ? Yn(o, {
            key: a
        }) : o)
    }
    if (r > 1)
        for (let s = 0; s < i.length; s++)
            i[s].patchFlag = -2;
    return i
}
function $i(n, e) {
    return He(n) ? ( () => _t({
        name: n.name
    }, e, {
        setup: n
    }))() : n
}
const Ar = n => !!n.type.__asyncLoader;
function $u(n) {
    He(n) && (n = {
        loader: n
    });
    const {loader: e, loadingComponent: t, errorComponent: i, delay: r=200, timeout: s, suspensible: o=!0, onError: a} = n;
    let l = null, c, u = 0;
    const h = () => (u++,
    l = null,
    f())
      , f = () => {
        let p;
        return l || (p = l = e().catch(g => {
            if (g = g instanceof Error ? g : new Error(String(g)),
            a)
                return new Promise( (x, m) => {
                    a(g, () => x(h()), () => m(g), u + 1)
                }
                );
            throw g
        }
        ).then(g => p !== l && l ? l : (g && (g.__esModule || g[Symbol.toStringTag] === "Module") && (g = g.default),
        c = g,
        g)))
    }
    ;
    return $i({
        name: "AsyncComponentWrapper",
        __asyncLoader: f,
        get __asyncResolved() {
            return c
        },
        setup() {
            const p = gt;
            if (c)
                return () => ja(c, p);
            const g = v => {
                l = null,
                $r(v, p, 13, !i)
            }
            ;
            if (o && p.suspense || Nr)
                return f().then(v => () => ja(v, p)).catch(v => (g(v),
                () => i ? at(i, {
                    error: v
                }) : null));
            const x = Rn(!1)
              , m = Rn()
              , d = Rn(!!r);
            return r && setTimeout( () => {
                d.value = !1
            }
            , r),
            s != null && setTimeout( () => {
                if (!x.value && !m.value) {
                    const v = new Error(`Async component timed out after ${s}ms.`);
                    g(v),
                    m.value = v
                }
            }
            , s),
            f().then( () => {
                x.value = !0,
                p.parent && $s(p.parent.vnode) && ya(p.parent.update)
            }
            ).catch(v => {
                g(v),
                m.value = v
            }
            ),
            () => {
                if (x.value && c)
                    return ja(c, p);
                if (m.value && i)
                    return at(i, {
                        error: m.value
                    });
                if (t && !d.value)
                    return at(t)
            }
        }
    })
}
function ja(n, e) {
    const {ref: t, props: i, children: r, ce: s} = e.vnode
      , o = at(n, i, r);
    return o.ref = t,
    o.ce = s,
    delete e.vnode.ce,
    o
}
const $s = n => n.type.__isKeepAlive
  , k_ = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(n, {slots: e}) {
        const t = ou()
          , i = t.ctx;
        if (!i.renderer)
            return () => {
                const v = e.default && e.default();
                return v && v.length === 1 ? v[0] : v
            }
            ;
        const r = new Map
          , s = new Set;
        let o = null;
        const a = t.suspense
          , {renderer: {p: l, m: c, um: u, o: {createElement: h}}} = i
          , f = h("div");
        i.activate = (v, _, M, b, A) => {
            const C = v.component;
            c(v, _, M, 0, a),
            l(C.vnode, v, _, M, C, a, b, v.slotScopeIds, A),
            wt( () => {
                C.isDeactivated = !1,
                C.a && ps(C.a);
                const P = v.props && v.props.onVnodeMounted;
                P && kt(P, C.parent, v)
            }
            , a)
        }
        ,
        i.deactivate = v => {
            const _ = v.component;
            c(v, f, null, 1, a),
            wt( () => {
                _.da && ps(_.da);
                const M = v.props && v.props.onVnodeUnmounted;
                M && kt(M, _.parent, v),
                _.isDeactivated = !0
            }
            , a)
        }
        ;
        function p(v) {
            Ka(v),
            u(v, t, a, !0)
        }
        function g(v) {
            r.forEach( (_, M) => {
                const b = tc(_.type);
                b && (!v || !v(b)) && x(M)
            }
            )
        }
        function x(v) {
            const _ = r.get(v);
            !o || !gn(_, o) ? p(_) : o && Ka(o),
            r.delete(v),
            s.delete(v)
        }
        ms( () => [n.include, n.exclude], ([v,_]) => {
            v && g(M => us(v, M)),
            _ && g(M => !us(_, M))
        }
        , {
            flush: "post",
            deep: !0
        });
        let m = null;
        const d = () => {
            m != null && r.set(m, qa(t.subTree))
        }
        ;
        return js(d),
        xp(d),
        Qc( () => {
            r.forEach(v => {
                const {subTree: _, suspense: M} = t
                  , b = qa(_);
                if (v.type === b.type && v.key === b.key) {
                    Ka(b);
                    const A = b.component.da;
                    A && wt(A, M);
                    return
                }
                p(v)
            }
            )
        }
        ),
        () => {
            if (m = null,
            !e.default)
                return null;
            const v = e.default()
              , _ = v[0];
            if (v.length > 1)
                return o = null,
                v;
            if (!Ns(_) || !(_.shapeFlag & 4) && !(_.shapeFlag & 128))
                return o = null,
                _;
            let M = qa(_);
            const b = M.type
              , A = tc(Ar(M) ? M.type.__asyncResolved || {} : b)
              , {include: C, exclude: P, max: S} = n;
            if (C && (!A || !us(C, A)) || P && A && us(P, A))
                return o = M,
                _;
            const T = M.key == null ? b : M.key
              , F = r.get(T);
            return M.el && (M = Yn(M),
            _.shapeFlag & 128 && (_.ssContent = M)),
            m = T,
            F ? (M.el = F.el,
            M.component = F.component,
            M.transition && Yo(M, M.transition),
            M.shapeFlag |= 512,
            s.delete(T),
            s.add(T)) : (s.add(T),
            S && s.size > parseInt(S, 10) && x(s.values().next().value)),
            M.shapeFlag |= 256,
            o = M,
            hp(_.type) ? _ : M
        }
    }
}
  , G_ = k_;
function us(n, e) {
    return Ie(n) ? n.some(t => us(t, e)) : lt(n) ? n.split(",").includes(e) : wg(n) ? n.test(e) : !1
}
function V_(n, e) {
    vp(n, "a", e)
}
function W_(n, e) {
    vp(n, "da", e)
}
function vp(n, e, t=gt) {
    const i = n.__wdc || (n.__wdc = () => {
        let r = t;
        for (; r; ) {
            if (r.isDeactivated)
                return;
            r = r.parent
        }
        return n()
    }
    );
    if (Ea(e, i, t),
    t) {
        let r = t.parent;
        for (; r && r.parent; )
            $s(r.parent.vnode) && X_(i, e, t, r),
            r = r.parent
    }
}
function X_(n, e, t, i) {
    const r = Ea(e, n, i, !0);
    yp( () => {
        zc(i[e], r)
    }
    , t)
}
function Ka(n) {
    n.shapeFlag &= -257,
    n.shapeFlag &= -513
}
function qa(n) {
    return n.shapeFlag & 128 ? n.ssContent : n
}
function Ea(n, e, t=gt, i=!1) {
    if (t) {
        const r = t[n] || (t[n] = [])
          , s = e.__weh || (e.__weh = (...o) => {
            if (t.isUnmounted)
                return;
            Wr(),
            Ur(t);
            const a = ln(e, t, n, o);
            return Bi(),
            Xr(),
            a
        }
        );
        return i ? r.unshift(s) : r.push(s),
        s
    }
}
const Qn = n => (e, t=gt) => (!Nr || n === "sp") && Ea(n, (...i) => e(...i), t)
  , $_ = Qn("bm")
  , js = Qn("m")
  , j_ = Qn("bu")
  , xp = Qn("u")
  , Qc = Qn("bum")
  , yp = Qn("um")
  , K_ = Qn("sp")
  , q_ = Qn("rtg")
  , Y_ = Qn("rtc");
function Mp(n, e=gt) {
    Ea("ec", n, e)
}
const eu = "components";
function zR(n, e) {
    return Ep(eu, n, !0, e) || n
}
const Sp = Symbol.for("v-ndc");
function J_(n) {
    return lt(n) ? Ep(eu, n, !1) || n : n || Sp
}
function Ep(n, e, t=!0, i=!1) {
    const r = Yt || gt;
    if (r) {
        const s = r.type;
        if (n === eu) {
            const a = tc(s, !1);
            if (a && (a === e || a === Pn(e) || a === ga(Pn(e))))
                return s
        }
        const o = ju(r[n] || s[n], e) || ju(r.appContext[n], e);
        return !o && i ? s : o
    }
}
function ju(n, e) {
    return n && (n[e] || n[Pn(e)] || n[ga(Pn(e))])
}
function BR(n, e, t, i) {
    let r;
    const s = t && t[i];
    if (Ie(n) || lt(n)) {
        r = new Array(n.length);
        for (let o = 0, a = n.length; o < a; o++)
            r[o] = e(n[o], o, void 0, s && s[o])
    } else if (typeof n == "number") {
        r = new Array(n);
        for (let o = 0; o < n; o++)
            r[o] = e(o + 1, o, void 0, s && s[o])
    } else if (tt(n))
        if (n[Symbol.iterator])
            r = Array.from(n, (o, a) => e(o, a, void 0, s && s[a]));
        else {
            const o = Object.keys(n);
            r = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                r[a] = e(n[c], c, a, s && s[a])
            }
        }
    else
        r = [];
    return t && (t[i] = r),
    r
}
const Yl = n => n ? Bp(n) ? lu(n) || n.proxy : Yl(n.parent) : null
  , gs = _t(Object.create(null), {
    $: n => n,
    $el: n => n.vnode.el,
    $data: n => n.data,
    $props: n => n.props,
    $attrs: n => n.attrs,
    $slots: n => n.slots,
    $refs: n => n.refs,
    $parent: n => Yl(n.parent),
    $root: n => Yl(n.root),
    $emit: n => n.emit,
    $options: n => tu(n),
    $forceUpdate: n => n.f || (n.f = () => ya(n.update)),
    $nextTick: n => n.n || (n.n = jr.bind(n.proxy)),
    $watch: n => O_.bind(n)
})
  , Ya = (n, e) => n !== rt && !n.__isScriptSetup && Je(n, e)
  , Z_ = {
    get({_: n}, e) {
        const {ctx: t, setupState: i, data: r, props: s, accessCache: o, type: a, appContext: l} = n;
        let c;
        if (e[0] !== "$") {
            const p = o[e];
            if (p !== void 0)
                switch (p) {
                case 1:
                    return i[e];
                case 2:
                    return r[e];
                case 4:
                    return t[e];
                case 3:
                    return s[e]
                }
            else {
                if (Ya(i, e))
                    return o[e] = 1,
                    i[e];
                if (r !== rt && Je(r, e))
                    return o[e] = 2,
                    r[e];
                if ((c = n.propsOptions[0]) && Je(c, e))
                    return o[e] = 3,
                    s[e];
                if (t !== rt && Je(t, e))
                    return o[e] = 4,
                    t[e];
                Jl && (o[e] = 0)
            }
        }
        const u = gs[e];
        let h, f;
        if (u)
            return e === "$attrs" && Xt(n, "get", e),
            u(n);
        if ((h = a.__cssModules) && (h = h[e]))
            return h;
        if (t !== rt && Je(t, e))
            return o[e] = 4,
            t[e];
        if (f = l.config.globalProperties,
        Je(f, e))
            return f[e]
    },
    set({_: n}, e, t) {
        const {data: i, setupState: r, ctx: s} = n;
        return Ya(r, e) ? (r[e] = t,
        !0) : i !== rt && Je(i, e) ? (i[e] = t,
        !0) : Je(n.props, e) || e[0] === "$" && e.slice(1)in n ? !1 : (s[e] = t,
        !0)
    },
    has({_: {data: n, setupState: e, accessCache: t, ctx: i, appContext: r, propsOptions: s}}, o) {
        let a;
        return !!t[o] || n !== rt && Je(n, o) || Ya(e, o) || (a = s[0]) && Je(a, o) || Je(i, o) || Je(gs, o) || Je(r.config.globalProperties, o)
    },
    defineProperty(n, e, t) {
        return t.get != null ? n._.accessCache[e] = 0 : Je(t, "value") && this.set(n, e, t.value, null),
        Reflect.defineProperty(n, e, t)
    }
};
function Ku(n) {
    return Ie(n) ? n.reduce( (e, t) => (e[t] = null,
    e), {}) : n
}
let Jl = !0;
function Q_(n) {
    const e = tu(n)
      , t = n.proxy
      , i = n.ctx;
    Jl = !1,
    e.beforeCreate && qu(e.beforeCreate, n, "bc");
    const {data: r, computed: s, methods: o, watch: a, provide: l, inject: c, created: u, beforeMount: h, mounted: f, beforeUpdate: p, updated: g, activated: x, deactivated: m, beforeDestroy: d, beforeUnmount: v, destroyed: _, unmounted: M, render: b, renderTracked: A, renderTriggered: C, errorCaptured: P, serverPrefetch: S, expose: T, inheritAttrs: F, components: k, directives: X, filters: L} = e;
    if (c && ev(c, i, null),
    o)
        for (const $ in o) {
            const re = o[$];
            He(re) && (i[$] = re.bind(t))
        }
    if (r) {
        const $ = r.call(t, t);
        tt($) && (n.data = yi($))
    }
    if (Jl = !0,
    s)
        for (const $ in s) {
            const re = s[$]
              , ee = He(re) ? re.bind(t, t) : He(re.get) ? re.get.bind(t, t) : yn
              , le = !He(re) && He(re.set) ? re.set.bind(t) : yn
              , B = _n({
                get: ee,
                set: le
            });
            Object.defineProperty(i, $, {
                enumerable: !0,
                configurable: !0,
                get: () => B.value,
                set: J => B.value = J
            })
        }
    if (a)
        for (const $ in a)
            bp(a[$], i, t, $);
    if (l) {
        const $ = He(l) ? l.call(t) : l;
        Reflect.ownKeys($).forEach(re => {
            Rr(re, $[re])
        }
        )
    }
    u && qu(u, n, "c");
    function V($, re) {
        Ie(re) ? re.forEach(ee => $(ee.bind(t))) : re && $(re.bind(t))
    }
    if (V($_, h),
    V(js, f),
    V(j_, p),
    V(xp, g),
    V(V_, x),
    V(W_, m),
    V(Mp, P),
    V(Y_, A),
    V(q_, C),
    V(Qc, v),
    V(yp, M),
    V(K_, S),
    Ie(T))
        if (T.length) {
            const $ = n.exposed || (n.exposed = {});
            T.forEach(re => {
                Object.defineProperty($, re, {
                    get: () => t[re],
                    set: ee => t[re] = ee
                })
            }
            )
        } else
            n.exposed || (n.exposed = {});
    b && n.render === yn && (n.render = b),
    F != null && (n.inheritAttrs = F),
    k && (n.components = k),
    X && (n.directives = X)
}
function ev(n, e, t=yn) {
    Ie(n) && (n = Zl(n));
    for (const i in n) {
        const r = n[i];
        let s;
        tt(r) ? "default"in r ? s = Jt(r.from || i, r.default, !0) : s = Jt(r.from || i) : s = Jt(r),
        Et(s) ? Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : e[i] = s
    }
}
function qu(n, e, t) {
    ln(Ie(n) ? n.map(i => i.bind(e.proxy)) : n.bind(e.proxy), e, t)
}
function bp(n, e, t, i) {
    const r = i.includes(".") ? pp(t, i) : () => t[i];
    if (lt(n)) {
        const s = e[n];
        He(s) && ms(r, s)
    } else if (He(n))
        ms(r, n.bind(t));
    else if (tt(n))
        if (Ie(n))
            n.forEach(s => bp(s, e, t, i));
        else {
            const s = He(n.handler) ? n.handler.bind(t) : e[n.handler];
            He(s) && ms(r, s, n)
        }
}
function tu(n) {
    const e = n.type
      , {mixins: t, extends: i} = e
      , {mixins: r, optionsCache: s, config: {optionMergeStrategies: o}} = n.appContext
      , a = s.get(e);
    let l;
    return a ? l = a : !r.length && !t && !i ? l = e : (l = {},
    r.length && r.forEach(c => Jo(l, c, o, !0)),
    Jo(l, e, o)),
    tt(e) && s.set(e, l),
    l
}
function Jo(n, e, t, i=!1) {
    const {mixins: r, extends: s} = e;
    s && Jo(n, s, t, !0),
    r && r.forEach(o => Jo(n, o, t, !0));
    for (const o in e)
        if (!(i && o === "expose")) {
            const a = tv[o] || t && t[o];
            n[o] = a ? a(n[o], e[o]) : e[o]
        }
    return n
}
const tv = {
    data: Yu,
    props: Ju,
    emits: Ju,
    methods: hs,
    computed: hs,
    beforeCreate: Ft,
    created: Ft,
    beforeMount: Ft,
    mounted: Ft,
    beforeUpdate: Ft,
    updated: Ft,
    beforeDestroy: Ft,
    beforeUnmount: Ft,
    destroyed: Ft,
    unmounted: Ft,
    activated: Ft,
    deactivated: Ft,
    errorCaptured: Ft,
    serverPrefetch: Ft,
    components: hs,
    directives: hs,
    watch: iv,
    provide: Yu,
    inject: nv
};
function Yu(n, e) {
    return e ? n ? function() {
        return _t(He(n) ? n.call(this, this) : n, He(e) ? e.call(this, this) : e)
    }
    : e : n
}
function nv(n, e) {
    return hs(Zl(n), Zl(e))
}
function Zl(n) {
    if (Ie(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++)
            e[n[t]] = n[t];
        return e
    }
    return n
}
function Ft(n, e) {
    return n ? [...new Set([].concat(n, e))] : e
}
function hs(n, e) {
    return n ? _t(Object.create(null), n, e) : e
}
function Ju(n, e) {
    return n ? Ie(n) && Ie(e) ? [...new Set([...n, ...e])] : _t(Object.create(null), Ku(n), Ku(e ?? {})) : e
}
function iv(n, e) {
    if (!n)
        return e;
    if (!e)
        return n;
    const t = _t(Object.create(null), n);
    for (const i in e)
        t[i] = Ft(n[i], e[i]);
    return t
}
function Tp() {
    return {
        app: null,
        config: {
            isNativeTag: Eg,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let rv = 0;
function sv(n, e) {
    return function(i, r=null) {
        He(i) || (i = _t({}, i)),
        r != null && !tt(r) && (r = null);
        const s = Tp()
          , o = new Set;
        let a = !1;
        const l = s.app = {
            _uid: rv++,
            _component: i,
            _props: r,
            _container: null,
            _context: s,
            _instance: null,
            version: kp,
            get config() {
                return s.config
            },
            set config(c) {},
            use(c, ...u) {
                return o.has(c) || (c && He(c.install) ? (o.add(c),
                c.install(l, ...u)) : He(c) && (o.add(c),
                c(l, ...u))),
                l
            },
            mixin(c) {
                return s.mixins.includes(c) || s.mixins.push(c),
                l
            },
            component(c, u) {
                return u ? (s.components[c] = u,
                l) : s.components[c]
            },
            directive(c, u) {
                return u ? (s.directives[c] = u,
                l) : s.directives[c]
            },
            mount(c, u, h) {
                if (!a) {
                    const f = at(i, r);
                    return f.appContext = s,
                    u && e ? e(f, c) : n(f, c, h),
                    a = !0,
                    l._container = c,
                    c.__vue_app__ = l,
                    lu(f.component) || f.component.proxy
                }
            },
            unmount() {
                a && (n(null, l._container),
                delete l._container.__vue_app__)
            },
            provide(c, u) {
                return s.provides[c] = u,
                l
            },
            runWithContext(c) {
                Us = l;
                try {
                    return c()
                } finally {
                    Us = null
                }
            }
        };
        return l
    }
}
let Us = null;
function Rr(n, e) {
    if (gt) {
        let t = gt.provides;
        const i = gt.parent && gt.parent.provides;
        i === t && (t = gt.provides = Object.create(i)),
        t[n] = e
    }
}
function Jt(n, e, t=!1) {
    const i = gt || Yt;
    if (i || Us) {
        const r = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : Us._context.provides;
        if (r && n in r)
            return r[n];
        if (arguments.length > 1)
            return t && He(e) ? e.call(i && i.proxy) : e
    }
}
function wp() {
    return !!(gt || Yt || Us)
}
function ov(n, e, t, i=!1) {
    const r = {}
      , s = {};
    Xo(s, ba, 1),
    n.propsDefaults = Object.create(null),
    Ap(n, e, r, s);
    for (const o in n.propsOptions[0])
        o in r || (r[o] = void 0);
    t ? n.props = i ? r : Xs(r) : n.type.props ? n.props = r : n.props = s,
    n.attrs = s
}
function av(n, e, t, i) {
    const {props: r, attrs: s, vnode: {patchFlag: o}} = n
      , a = Ze(r)
      , [l] = n.propsOptions;
    let c = !1;
    if ((i || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = n.vnode.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                let f = u[h];
                if (Ma(n.emitsOptions, f))
                    continue;
                const p = e[f];
                if (l)
                    if (Je(s, f))
                        p !== s[f] && (s[f] = p,
                        c = !0);
                    else {
                        const g = Pn(f);
                        r[g] = Ql(l, a, g, p, n, !1)
                    }
                else
                    p !== s[f] && (s[f] = p,
                    c = !0)
            }
        }
    } else {
        Ap(n, e, r, s) && (c = !0);
        let u;
        for (const h in a)
            (!e || !Je(e, h) && ((u = Vr(h)) === h || !Je(e, u))) && (l ? t && (t[h] !== void 0 || t[u] !== void 0) && (r[h] = Ql(l, a, h, void 0, n, !0)) : delete r[h]);
        if (s !== a)
            for (const h in s)
                (!e || !Je(e, h)) && (delete s[h],
                c = !0)
    }
    c && qn(n, "set", "$attrs")
}
function Ap(n, e, t, i) {
    const [r,s] = n.propsOptions;
    let o = !1, a;
    if (e)
        for (let l in e) {
            if (ds(l))
                continue;
            const c = e[l];
            let u;
            r && Je(r, u = Pn(l)) ? !s || !s.includes(u) ? t[u] = c : (a || (a = {}))[u] = c : Ma(n.emitsOptions, l) || (!(l in i) || c !== i[l]) && (i[l] = c,
            o = !0)
        }
    if (s) {
        const l = Ze(t)
          , c = a || rt;
        for (let u = 0; u < s.length; u++) {
            const h = s[u];
            t[h] = Ql(r, l, h, c[h], n, !Je(c, h))
        }
    }
    return o
}
function Ql(n, e, t, i, r, s) {
    const o = n[t];
    if (o != null) {
        const a = Je(o, "default");
        if (a && i === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && He(l)) {
                const {propsDefaults: c} = r;
                t in c ? i = c[t] : (Ur(r),
                i = c[t] = l.call(null, e),
                Bi())
            } else
                i = l
        }
        o[0] && (s && !a ? i = !1 : o[1] && (i === "" || i === Vr(t)) && (i = !0))
    }
    return i
}
function Rp(n, e, t=!1) {
    const i = e.propsCache
      , r = i.get(n);
    if (r)
        return r;
    const s = n.props
      , o = {}
      , a = [];
    let l = !1;
    if (!He(n)) {
        const u = h => {
            l = !0;
            const [f,p] = Rp(h, e, !0);
            _t(o, f),
            p && a.push(...p)
        }
        ;
        !t && e.mixins.length && e.mixins.forEach(u),
        n.extends && u(n.extends),
        n.mixins && n.mixins.forEach(u)
    }
    if (!s && !l)
        return tt(n) && i.set(n, Sr),
        Sr;
    if (Ie(s))
        for (let u = 0; u < s.length; u++) {
            const h = Pn(s[u]);
            Zu(h) && (o[h] = rt)
        }
    else if (s)
        for (const u in s) {
            const h = Pn(u);
            if (Zu(h)) {
                const f = s[u]
                  , p = o[h] = Ie(f) || He(f) ? {
                    type: f
                } : _t({}, f);
                if (p) {
                    const g = th(Boolean, p.type)
                      , x = th(String, p.type);
                    p[0] = g > -1,
                    p[1] = x < 0 || g < x,
                    (g > -1 || Je(p, "default")) && a.push(h)
                }
            }
        }
    const c = [o, a];
    return tt(n) && i.set(n, c),
    c
}
function Zu(n) {
    return n[0] !== "$"
}
function Qu(n) {
    const e = n && n.toString().match(/^\s*(function|class) (\w+)/);
    return e ? e[2] : n === null ? "null" : ""
}
function eh(n, e) {
    return Qu(n) === Qu(e)
}
function th(n, e) {
    return Ie(e) ? e.findIndex(t => eh(t, n)) : He(e) && eh(e, n) ? 0 : -1
}
const Cp = n => n[0] === "_" || n === "$stable"
  , nu = n => Ie(n) ? n.map(rn) : [rn(n)]
  , lv = (n, e, t) => {
    if (e._n)
        return e;
    const i = qc( (...r) => nu(e(...r)), t);
    return i._c = !1,
    i
}
  , Pp = (n, e, t) => {
    const i = n._ctx;
    for (const r in n) {
        if (Cp(r))
            continue;
        const s = n[r];
        if (He(s))
            e[r] = lv(r, s, i);
        else if (s != null) {
            const o = nu(s);
            e[r] = () => o
        }
    }
}
  , Lp = (n, e) => {
    const t = nu(e);
    n.slots.default = () => t
}
  , cv = (n, e) => {
    if (n.vnode.shapeFlag & 32) {
        const t = e._;
        t ? (n.slots = Ze(e),
        Xo(e, "_", t)) : Pp(e, n.slots = {})
    } else
        n.slots = {},
        e && Lp(n, e);
    Xo(n.slots, ba, 1)
}
  , uv = (n, e, t) => {
    const {vnode: i, slots: r} = n;
    let s = !0
      , o = rt;
    if (i.shapeFlag & 32) {
        const a = e._;
        a ? t && a === 1 ? s = !1 : (_t(r, e),
        !t && a === 1 && delete r._) : (s = !e.$stable,
        Pp(e, r)),
        o = e
    } else
        e && (Lp(n, e),
        o = {
            default: 1
        });
    if (s)
        for (const a in r)
            !Cp(a) && !(a in o) && delete r[a]
}
;
function Zo(n, e, t, i, r=!1) {
    if (Ie(n)) {
        n.forEach( (f, p) => Zo(f, e && (Ie(e) ? e[p] : e), t, i, r));
        return
    }
    if (Ar(i) && !r)
        return;
    const s = i.shapeFlag & 4 ? lu(i.component) || i.component.proxy : i.el
      , o = r ? null : s
      , {i: a, r: l} = n
      , c = e && e.r
      , u = a.refs === rt ? a.refs = {} : a.refs
      , h = a.setupState;
    if (c != null && c !== l && (lt(c) ? (u[c] = null,
    Je(h, c) && (h[c] = null)) : Et(c) && (c.value = null)),
    He(l))
        mi(l, a, 12, [o, u]);
    else {
        const f = lt(l)
          , p = Et(l);
        if (f || p) {
            const g = () => {
                if (n.f) {
                    const x = f ? Je(h, l) ? h[l] : u[l] : l.value;
                    r ? Ie(x) && zc(x, s) : Ie(x) ? x.includes(s) || x.push(s) : f ? (u[l] = [s],
                    Je(h, l) && (h[l] = u[l])) : (l.value = [s],
                    n.k && (u[n.k] = l.value))
                } else
                    f ? (u[l] = o,
                    Je(h, l) && (h[l] = o)) : p && (l.value = o,
                    n.k && (u[n.k] = o))
            }
            ;
            o ? (g.id = -1,
            wt(g, t)) : g()
        }
    }
}
let ti = !1;
const oo = n => /svg/.test(n.namespaceURI) && n.tagName !== "foreignObject"
  , ao = n => n.nodeType === 8;
function hv(n) {
    const {mt: e, p: t, o: {patchProp: i, createText: r, nextSibling: s, parentNode: o, remove: a, insert: l, createComment: c}} = n
      , u = (d, v) => {
        if (!v.hasChildNodes()) {
            t(null, d, v),
            Ko(),
            v._vnode = d;
            return
        }
        ti = !1,
        h(v.firstChild, d, null, null, null),
        Ko(),
        v._vnode = d,
        ti && console.error("Hydration completed but contains mismatches.")
    }
      , h = (d, v, _, M, b, A=!1) => {
        const C = ao(d) && d.data === "["
          , P = () => x(d, v, _, M, b, C)
          , {type: S, ref: T, shapeFlag: F, patchFlag: k} = v;
        let X = d.nodeType;
        v.el = d,
        k === -2 && (A = !1,
        v.dynamicChildren = null);
        let L = null;
        switch (S) {
        case Dr:
            X !== 3 ? v.children === "" ? (l(v.el = r(""), o(d), d),
            L = d) : L = P() : (d.data !== v.children && (ti = !0,
            d.data = v.children),
            L = s(d));
            break;
        case cn:
            X !== 8 || C ? L = P() : L = s(d);
            break;
        case _s:
            if (C && (d = s(d),
            X = d.nodeType),
            X === 1 || X === 3) {
                L = d;
                const G = !v.children.length;
                for (let V = 0; V < v.staticCount; V++)
                    G && (v.children += L.nodeType === 1 ? L.outerHTML : L.data),
                    V === v.staticCount - 1 && (v.anchor = L),
                    L = s(L);
                return C ? s(L) : L
            } else
                P();
            break;
        case nn:
            C ? L = g(d, v, _, M, b, A) : L = P();
            break;
        default:
            if (F & 1)
                X !== 1 || v.type.toLowerCase() !== d.tagName.toLowerCase() ? L = P() : L = f(d, v, _, M, b, A);
            else if (F & 6) {
                v.slotScopeIds = b;
                const G = o(d);
                if (e(v, G, null, _, M, oo(G), A),
                L = C ? m(d) : s(d),
                L && ao(L) && L.data === "teleport end" && (L = s(L)),
                Ar(v)) {
                    let V;
                    C ? (V = at(nn),
                    V.anchor = L ? L.previousSibling : G.lastChild) : V = d.nodeType === 3 ? zp("") : at("div"),
                    V.el = d,
                    v.component.subTree = V
                }
            } else
                F & 64 ? X !== 8 ? L = P() : L = v.type.hydrate(d, v, _, M, b, A, n, p) : F & 128 && (L = v.type.hydrate(d, v, _, M, oo(o(d)), b, A, n, h))
        }
        return T != null && Zo(T, null, M, v),
        L
    }
      , f = (d, v, _, M, b, A) => {
        A = A || !!v.dynamicChildren;
        const {type: C, props: P, patchFlag: S, shapeFlag: T, dirs: F} = v
          , k = C === "input" && F || C === "option";
        if (k || S !== -1) {
            if (F && bn(v, null, _, "created"),
            P)
                if (k || !A || S & 48)
                    for (const L in P)
                        (k && L.endsWith("value") || Vs(L) && !ds(L)) && i(d, L, null, P[L], !1, void 0, _);
                else
                    P.onClick && i(d, "onClick", null, P.onClick, !1, void 0, _);
            let X;
            if ((X = P && P.onVnodeBeforeMount) && kt(X, _, v),
            F && bn(v, null, _, "beforeMount"),
            ((X = P && P.onVnodeMounted) || F) && dp( () => {
                X && kt(X, _, v),
                F && bn(v, null, _, "mounted")
            }
            , M),
            T & 16 && !(P && (P.innerHTML || P.textContent))) {
                let L = p(d.firstChild, v, d, _, M, b, A);
                for (; L; ) {
                    ti = !0;
                    const G = L;
                    L = L.nextSibling,
                    a(G)
                }
            } else
                T & 8 && d.textContent !== v.children && (ti = !0,
                d.textContent = v.children)
        }
        return d.nextSibling
    }
      , p = (d, v, _, M, b, A, C) => {
        C = C || !!v.dynamicChildren;
        const P = v.children
          , S = P.length;
        for (let T = 0; T < S; T++) {
            const F = C ? P[T] : P[T] = rn(P[T]);
            if (d)
                d = h(d, F, M, b, A, C);
            else {
                if (F.type === Dr && !F.children)
                    continue;
                ti = !0,
                t(null, F, _, null, M, b, oo(_), A)
            }
        }
        return d
    }
      , g = (d, v, _, M, b, A) => {
        const {slotScopeIds: C} = v;
        C && (b = b ? b.concat(C) : C);
        const P = o(d)
          , S = p(s(d), v, P, _, M, b, A);
        return S && ao(S) && S.data === "]" ? s(v.anchor = S) : (ti = !0,
        l(v.anchor = c("]"), P, S),
        S)
    }
      , x = (d, v, _, M, b, A) => {
        if (ti = !0,
        v.el = null,
        A) {
            const S = m(d);
            for (; ; ) {
                const T = s(d);
                if (T && T !== S)
                    a(T);
                else
                    break
            }
        }
        const C = s(d)
          , P = o(d);
        return a(d),
        t(null, v, P, C, _, M, oo(P), b),
        C
    }
      , m = d => {
        let v = 0;
        for (; d; )
            if (d = s(d),
            d && ao(d) && (d.data === "[" && v++,
            d.data === "]")) {
                if (v === 0)
                    return s(d);
                v--
            }
        return d
    }
    ;
    return [u, h]
}
const wt = dp;
function fv(n) {
    return Dp(n)
}
function dv(n) {
    return Dp(n, hv)
}
function Dp(n, e) {
    const t = Wl();
    t.__VUE__ = !0;
    const {insert: i, remove: r, patchProp: s, createElement: o, createText: a, createComment: l, setText: c, setElementText: u, parentNode: h, nextSibling: f, setScopeId: p=yn, insertStaticContent: g} = n
      , x = (y, R, D, O=null, N=null, j=null, Z=!1, Y=null, oe=!!R.dynamicChildren) => {
        if (y === R)
            return;
        y && !gn(y, R) && (O = W(y),
        J(y, N, j, !0),
        y = null),
        R.patchFlag === -2 && (oe = !1,
        R.dynamicChildren = null);
        const {type: Q, ref: be, shapeFlag: w} = R;
        switch (Q) {
        case Dr:
            m(y, R, D, O);
            break;
        case cn:
            d(y, R, D, O);
            break;
        case _s:
            y == null && v(R, D, O, Z);
            break;
        case nn:
            k(y, R, D, O, N, j, Z, Y, oe);
            break;
        default:
            w & 1 ? b(y, R, D, O, N, j, Z, Y, oe) : w & 6 ? X(y, R, D, O, N, j, Z, Y, oe) : (w & 64 || w & 128) && Q.process(y, R, D, O, N, j, Z, Y, oe, ce)
        }
        be != null && N && Zo(be, y && y.ref, j, R || y, !R)
    }
      , m = (y, R, D, O) => {
        if (y == null)
            i(R.el = a(R.children), D, O);
        else {
            const N = R.el = y.el;
            R.children !== y.children && c(N, R.children)
        }
    }
      , d = (y, R, D, O) => {
        y == null ? i(R.el = l(R.children || ""), D, O) : R.el = y.el
    }
      , v = (y, R, D, O) => {
        [y.el,y.anchor] = g(y.children, R, D, O, y.el, y.anchor)
    }
      , _ = ({el: y, anchor: R}, D, O) => {
        let N;
        for (; y && y !== R; )
            N = f(y),
            i(y, D, O),
            y = N;
        i(R, D, O)
    }
      , M = ({el: y, anchor: R}) => {
        let D;
        for (; y && y !== R; )
            D = f(y),
            r(y),
            y = D;
        r(R)
    }
      , b = (y, R, D, O, N, j, Z, Y, oe) => {
        Z = Z || R.type === "svg",
        y == null ? A(R, D, O, N, j, Z, Y, oe) : S(y, R, N, j, Z, Y, oe)
    }
      , A = (y, R, D, O, N, j, Z, Y) => {
        let oe, Q;
        const {type: be, props: w, shapeFlag: E, transition: z, dirs: ie} = y;
        if (oe = y.el = o(y.type, j, w && w.is, w),
        E & 8 ? u(oe, y.children) : E & 16 && P(y.children, oe, null, O, N, j && be !== "foreignObject", Z, Y),
        ie && bn(y, null, O, "created"),
        C(oe, y, y.scopeId, Z, O),
        w) {
            for (const ue in w)
                ue !== "value" && !ds(ue) && s(oe, ue, null, w[ue], j, y.children, O, N, Ae);
            "value"in w && s(oe, "value", null, w.value),
            (Q = w.onVnodeBeforeMount) && kt(Q, O, y)
        }
        ie && bn(y, null, O, "beforeMount");
        const ae = (!N || N && !N.pendingBranch) && z && !z.persisted;
        ae && z.beforeEnter(oe),
        i(oe, R, D),
        ((Q = w && w.onVnodeMounted) || ae || ie) && wt( () => {
            Q && kt(Q, O, y),
            ae && z.enter(oe),
            ie && bn(y, null, O, "mounted")
        }
        , N)
    }
      , C = (y, R, D, O, N) => {
        if (D && p(y, D),
        O)
            for (let j = 0; j < O.length; j++)
                p(y, O[j]);
        if (N) {
            let j = N.subTree;
            if (R === j) {
                const Z = N.vnode;
                C(y, Z, Z.scopeId, Z.slotScopeIds, N.parent)
            }
        }
    }
      , P = (y, R, D, O, N, j, Z, Y, oe=0) => {
        for (let Q = oe; Q < y.length; Q++) {
            const be = y[Q] = Y ? hi(y[Q]) : rn(y[Q]);
            x(null, be, R, D, O, N, j, Z, Y)
        }
    }
      , S = (y, R, D, O, N, j, Z) => {
        const Y = R.el = y.el;
        let {patchFlag: oe, dynamicChildren: Q, dirs: be} = R;
        oe |= y.patchFlag & 16;
        const w = y.props || rt
          , E = R.props || rt;
        let z;
        D && bi(D, !1),
        (z = E.onVnodeBeforeUpdate) && kt(z, D, R, y),
        be && bn(R, y, D, "beforeUpdate"),
        D && bi(D, !0);
        const ie = N && R.type !== "foreignObject";
        if (Q ? T(y.dynamicChildren, Q, Y, D, O, ie, j) : Z || re(y, R, Y, null, D, O, ie, j, !1),
        oe > 0) {
            if (oe & 16)
                F(Y, R, w, E, D, O, N);
            else if (oe & 2 && w.class !== E.class && s(Y, "class", null, E.class, N),
            oe & 4 && s(Y, "style", w.style, E.style, N),
            oe & 8) {
                const ae = R.dynamicProps;
                for (let ue = 0; ue < ae.length; ue++) {
                    const Se = ae[ue]
                      , pe = w[Se]
                      , Ee = E[Se];
                    (Ee !== pe || Se === "value") && s(Y, Se, pe, Ee, N, y.children, D, O, Ae)
                }
            }
            oe & 1 && y.children !== R.children && u(Y, R.children)
        } else
            !Z && Q == null && F(Y, R, w, E, D, O, N);
        ((z = E.onVnodeUpdated) || be) && wt( () => {
            z && kt(z, D, R, y),
            be && bn(R, y, D, "updated")
        }
        , O)
    }
      , T = (y, R, D, O, N, j, Z) => {
        for (let Y = 0; Y < R.length; Y++) {
            const oe = y[Y]
              , Q = R[Y]
              , be = oe.el && (oe.type === nn || !gn(oe, Q) || oe.shapeFlag & 70) ? h(oe.el) : D;
            x(oe, Q, be, null, O, N, j, Z, !0)
        }
    }
      , F = (y, R, D, O, N, j, Z) => {
        if (D !== O) {
            if (D !== rt)
                for (const Y in D)
                    !ds(Y) && !(Y in O) && s(y, Y, D[Y], null, Z, R.children, N, j, Ae);
            for (const Y in O) {
                if (ds(Y))
                    continue;
                const oe = O[Y]
                  , Q = D[Y];
                oe !== Q && Y !== "value" && s(y, Y, Q, oe, Z, R.children, N, j, Ae)
            }
            "value"in O && s(y, "value", D.value, O.value)
        }
    }
      , k = (y, R, D, O, N, j, Z, Y, oe) => {
        const Q = R.el = y ? y.el : a("")
          , be = R.anchor = y ? y.anchor : a("");
        let {patchFlag: w, dynamicChildren: E, slotScopeIds: z} = R;
        z && (Y = Y ? Y.concat(z) : z),
        y == null ? (i(Q, D, O),
        i(be, D, O),
        P(R.children, D, be, N, j, Z, Y, oe)) : w > 0 && w & 64 && E && y.dynamicChildren ? (T(y.dynamicChildren, E, D, N, j, Z, Y),
        (R.key != null || N && R === N.subTree) && Ip(y, R, !0)) : re(y, R, D, be, N, j, Z, Y, oe)
    }
      , X = (y, R, D, O, N, j, Z, Y, oe) => {
        R.slotScopeIds = Y,
        y == null ? R.shapeFlag & 512 ? N.ctx.activate(R, D, O, Z, oe) : L(R, D, O, N, j, Z, oe) : G(y, R, oe)
    }
      , L = (y, R, D, O, N, j, Z) => {
        const Y = y.component = yv(y, O, N);
        if ($s(y) && (Y.ctx.renderer = ce),
        Mv(Y),
        Y.asyncDep) {
            if (N && N.registerDep(Y, V),
            !y.el) {
                const oe = Y.subTree = at(cn);
                d(null, oe, R, D)
            }
            return
        }
        V(Y, y, R, D, N, j, Z)
    }
      , G = (y, R, D) => {
        const O = R.component = y.component;
        if (P_(y, R, D))
            if (O.asyncDep && !O.asyncResolved) {
                $(O, R, D);
                return
            } else
                O.next = R,
                b_(O.update),
                O.update();
        else
            R.el = y.el,
            O.vnode = R
    }
      , V = (y, R, D, O, N, j, Z) => {
        const Y = () => {
            if (y.isMounted) {
                let {next: be, bu: w, u: E, parent: z, vnode: ie} = y, ae = be, ue;
                bi(y, !1),
                be ? (be.el = ie.el,
                $(y, be, Z)) : be = ie,
                w && ps(w),
                (ue = be.props && be.props.onVnodeBeforeUpdate) && kt(ue, z, be, ie),
                bi(y, !0);
                const Se = Xa(y)
                  , pe = y.subTree;
                y.subTree = Se,
                x(pe, Se, h(pe.el), W(pe), y, N, j),
                be.el = Se.el,
                ae === null && Yc(y, Se.el),
                E && wt(E, N),
                (ue = be.props && be.props.onVnodeUpdated) && wt( () => kt(ue, z, be, ie), N)
            } else {
                let be;
                const {el: w, props: E} = R
                  , {bm: z, m: ie, parent: ae} = y
                  , ue = Ar(R);
                if (bi(y, !1),
                z && ps(z),
                !ue && (be = E && E.onVnodeBeforeMount) && kt(be, ae, R),
                bi(y, !0),
                w && he) {
                    const Se = () => {
                        y.subTree = Xa(y),
                        he(w, y.subTree, y, N, null)
                    }
                    ;
                    ue ? R.type.__asyncLoader().then( () => !y.isUnmounted && Se()) : Se()
                } else {
                    const Se = y.subTree = Xa(y);
                    x(null, Se, D, O, y, N, j),
                    R.el = Se.el
                }
                if (ie && wt(ie, N),
                !ue && (be = E && E.onVnodeMounted)) {
                    const Se = R;
                    wt( () => kt(be, ae, Se), N)
                }
                (R.shapeFlag & 256 || ae && Ar(ae.vnode) && ae.vnode.shapeFlag & 256) && y.a && wt(y.a, N),
                y.isMounted = !0,
                R = D = O = null
            }
        }
          , oe = y.effect = new Gc(Y, () => ya(Q),y.scope)
          , Q = y.update = () => oe.run();
        Q.id = y.uid,
        bi(y, !0),
        Q()
    }
      , $ = (y, R, D) => {
        R.component = y;
        const O = y.vnode.props;
        y.vnode = R,
        y.next = null,
        av(y, R.props, O, D),
        uv(y, R.children, D),
        Wr(),
        Gu(),
        Xr()
    }
      , re = (y, R, D, O, N, j, Z, Y, oe=!1) => {
        const Q = y && y.children
          , be = y ? y.shapeFlag : 0
          , w = R.children
          , {patchFlag: E, shapeFlag: z} = R;
        if (E > 0) {
            if (E & 128) {
                le(Q, w, D, O, N, j, Z, Y, oe);
                return
            } else if (E & 256) {
                ee(Q, w, D, O, N, j, Z, Y, oe);
                return
            }
        }
        z & 8 ? (be & 16 && Ae(Q, N, j),
        w !== Q && u(D, w)) : be & 16 ? z & 16 ? le(Q, w, D, O, N, j, Z, Y, oe) : Ae(Q, N, j, !0) : (be & 8 && u(D, ""),
        z & 16 && P(w, D, O, N, j, Z, Y, oe))
    }
      , ee = (y, R, D, O, N, j, Z, Y, oe) => {
        y = y || Sr,
        R = R || Sr;
        const Q = y.length
          , be = R.length
          , w = Math.min(Q, be);
        let E;
        for (E = 0; E < w; E++) {
            const z = R[E] = oe ? hi(R[E]) : rn(R[E]);
            x(y[E], z, D, null, N, j, Z, Y, oe)
        }
        Q > be ? Ae(y, N, j, !0, !1, w) : P(R, D, O, N, j, Z, Y, oe, w)
    }
      , le = (y, R, D, O, N, j, Z, Y, oe) => {
        let Q = 0;
        const be = R.length;
        let w = y.length - 1
          , E = be - 1;
        for (; Q <= w && Q <= E; ) {
            const z = y[Q]
              , ie = R[Q] = oe ? hi(R[Q]) : rn(R[Q]);
            if (gn(z, ie))
                x(z, ie, D, null, N, j, Z, Y, oe);
            else
                break;
            Q++
        }
        for (; Q <= w && Q <= E; ) {
            const z = y[w]
              , ie = R[E] = oe ? hi(R[E]) : rn(R[E]);
            if (gn(z, ie))
                x(z, ie, D, null, N, j, Z, Y, oe);
            else
                break;
            w--,
            E--
        }
        if (Q > w) {
            if (Q <= E) {
                const z = E + 1
                  , ie = z < be ? R[z].el : O;
                for (; Q <= E; )
                    x(null, R[Q] = oe ? hi(R[Q]) : rn(R[Q]), D, ie, N, j, Z, Y, oe),
                    Q++
            }
        } else if (Q > E)
            for (; Q <= w; )
                J(y[Q], N, j, !0),
                Q++;
        else {
            const z = Q
              , ie = Q
              , ae = new Map;
            for (Q = ie; Q <= E; Q++) {
                const ke = R[Q] = oe ? hi(R[Q]) : rn(R[Q]);
                ke.key != null && ae.set(ke.key, Q)
            }
            let ue, Se = 0;
            const pe = E - ie + 1;
            let Ee = !1
              , Ne = 0;
            const je = new Array(pe);
            for (Q = 0; Q < pe; Q++)
                je[Q] = 0;
            for (Q = z; Q <= w; Q++) {
                const ke = y[Q];
                if (Se >= pe) {
                    J(ke, N, j, !0);
                    continue
                }
                let Le;
                if (ke.key != null)
                    Le = ae.get(ke.key);
                else
                    for (ue = ie; ue <= E; ue++)
                        if (je[ue - ie] === 0 && gn(ke, R[ue])) {
                            Le = ue;
                            break
                        }
                Le === void 0 ? J(ke, N, j, !0) : (je[Le - ie] = Q + 1,
                Le >= Ne ? Ne = Le : Ee = !0,
                x(ke, R[Le], D, null, N, j, Z, Y, oe),
                Se++)
            }
            const me = Ee ? pv(je) : Sr;
            for (ue = me.length - 1,
            Q = pe - 1; Q >= 0; Q--) {
                const ke = ie + Q
                  , Le = R[ke]
                  , Fe = ke + 1 < be ? R[ke + 1].el : O;
                je[Q] === 0 ? x(null, Le, D, Fe, N, j, Z, Y, oe) : Ee && (ue < 0 || Q !== me[ue] ? B(Le, D, Fe, 2) : ue--)
            }
        }
    }
      , B = (y, R, D, O, N=null) => {
        const {el: j, type: Z, transition: Y, children: oe, shapeFlag: Q} = y;
        if (Q & 6) {
            B(y.component.subTree, R, D, O);
            return
        }
        if (Q & 128) {
            y.suspense.move(R, D, O);
            return
        }
        if (Q & 64) {
            Z.move(y, R, D, ce);
            return
        }
        if (Z === nn) {
            i(j, R, D);
            for (let w = 0; w < oe.length; w++)
                B(oe[w], R, D, O);
            i(y.anchor, R, D);
            return
        }
        if (Z === _s) {
            _(y, R, D);
            return
        }
        if (O !== 2 && Q & 1 && Y)
            if (O === 0)
                Y.beforeEnter(j),
                i(j, R, D),
                wt( () => Y.enter(j), N);
            else {
                const {leave: w, delayLeave: E, afterLeave: z} = Y
                  , ie = () => i(j, R, D)
                  , ae = () => {
                    w(j, () => {
                        ie(),
                        z && z()
                    }
                    )
                }
                ;
                E ? E(j, ie, ae) : ae()
            }
        else
            i(j, R, D)
    }
      , J = (y, R, D, O=!1, N=!1) => {
        const {type: j, props: Z, ref: Y, children: oe, dynamicChildren: Q, shapeFlag: be, patchFlag: w, dirs: E} = y;
        if (Y != null && Zo(Y, null, D, y, !0),
        be & 256) {
            R.ctx.deactivate(y);
            return
        }
        const z = be & 1 && E
          , ie = !Ar(y);
        let ae;
        if (ie && (ae = Z && Z.onVnodeBeforeUnmount) && kt(ae, R, y),
        be & 6)
            Te(y.component, D, O);
        else {
            if (be & 128) {
                y.suspense.unmount(D, O);
                return
            }
            z && bn(y, null, R, "beforeUnmount"),
            be & 64 ? y.type.remove(y, R, D, N, ce, O) : Q && (j !== nn || w > 0 && w & 64) ? Ae(Q, R, D, !1, !0) : (j === nn && w & 384 || !N && be & 16) && Ae(oe, R, D),
            O && fe(y)
        }
        (ie && (ae = Z && Z.onVnodeUnmounted) || z) && wt( () => {
            ae && kt(ae, R, y),
            z && bn(y, null, R, "unmounted")
        }
        , D)
    }
      , fe = y => {
        const {type: R, el: D, anchor: O, transition: N} = y;
        if (R === nn) {
            _e(D, O);
            return
        }
        if (R === _s) {
            M(y);
            return
        }
        const j = () => {
            r(D),
            N && !N.persisted && N.afterLeave && N.afterLeave()
        }
        ;
        if (y.shapeFlag & 1 && N && !N.persisted) {
            const {leave: Z, delayLeave: Y} = N
              , oe = () => Z(D, j);
            Y ? Y(y.el, j, oe) : oe()
        } else
            j()
    }
      , _e = (y, R) => {
        let D;
        for (; y !== R; )
            D = f(y),
            r(y),
            y = D;
        r(R)
    }
      , Te = (y, R, D) => {
        const {bum: O, scope: N, update: j, subTree: Z, um: Y} = y;
        O && ps(O),
        N.stop(),
        j && (j.active = !1,
        J(Z, y, R, D)),
        Y && wt(Y, R),
        wt( () => {
            y.isUnmounted = !0
        }
        , R),
        R && R.pendingBranch && !R.isUnmounted && y.asyncDep && !y.asyncResolved && y.suspenseId === R.pendingId && (R.deps--,
        R.deps === 0 && R.resolve())
    }
      , Ae = (y, R, D, O=!1, N=!1, j=0) => {
        for (let Z = j; Z < y.length; Z++)
            J(y[Z], R, D, O, N)
    }
      , W = y => y.shapeFlag & 6 ? W(y.component.subTree) : y.shapeFlag & 128 ? y.suspense.next() : f(y.anchor || y.el)
      , se = (y, R, D) => {
        y == null ? R._vnode && J(R._vnode, null, null, !0) : x(R._vnode || null, y, R, null, null, null, D),
        Gu(),
        Ko(),
        R._vnode = y
    }
      , ce = {
        p: x,
        um: J,
        m: B,
        r: fe,
        mt: L,
        mc: P,
        pc: re,
        pbc: T,
        n: W,
        o: n
    };
    let ge, he;
    return e && ([ge,he] = e(ce)),
    {
        render: se,
        hydrate: ge,
        createApp: sv(se, ge)
    }
}
function bi({effect: n, update: e}, t) {
    n.allowRecurse = e.allowRecurse = t
}
function Ip(n, e, t=!1) {
    const i = n.children
      , r = e.children;
    if (Ie(i) && Ie(r))
        for (let s = 0; s < i.length; s++) {
            const o = i[s];
            let a = r[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = r[s] = hi(r[s]),
            a.el = o.el),
            t || Ip(o, a)),
            a.type === Dr && (a.el = o.el)
        }
}
function pv(n) {
    const e = n.slice()
      , t = [0];
    let i, r, s, o, a;
    const l = n.length;
    for (i = 0; i < l; i++) {
        const c = n[i];
        if (c !== 0) {
            if (r = t[t.length - 1],
            n[r] < c) {
                e[i] = r,
                t.push(i);
                continue
            }
            for (s = 0,
            o = t.length - 1; s < o; )
                a = s + o >> 1,
                n[t[a]] < c ? s = a + 1 : o = a;
            c < n[t[s]] && (s > 0 && (e[i] = t[s - 1]),
            t[s] = i)
        }
    }
    for (s = t.length,
    o = t[s - 1]; s-- > 0; )
        t[s] = o,
        o = e[o];
    return t
}
const mv = n => n.__isTeleport
  , nn = Symbol.for("v-fgt")
  , Dr = Symbol.for("v-txt")
  , cn = Symbol.for("v-cmt")
  , _s = Symbol.for("v-stc")
  , vs = [];
let an = null;
function Wn(n=!1) {
    vs.push(an = n ? null : [])
}
function Up() {
    vs.pop(),
    an = vs[vs.length - 1] || null
}
let Ir = 1;
function nh(n) {
    Ir += n
}
function Np(n) {
    return n.dynamicChildren = Ir > 0 ? an || Sr : null,
    Up(),
    Ir > 0 && an && an.push(n),
    n
}
function iu(n, e, t, i, r, s) {
    return Np(ru(n, e, t, i, r, s, !0))
}
function pr(n, e, t, i, r) {
    return Np(at(n, e, t, i, r, !0))
}
function Ns(n) {
    return n ? n.__v_isVNode === !0 : !1
}
function gn(n, e) {
    return n.type === e.type && n.key === e.key
}
const ba = "__vInternal"
  , Fp = ({key: n}) => n ?? null
  , Ho = ({ref: n, ref_key: e, ref_for: t}) => (typeof n == "number" && (n = "" + n),
n != null ? lt(n) || Et(n) || He(n) ? {
    i: Yt,
    r: n,
    k: e,
    f: !!t
} : n : null);
function ru(n, e=null, t=null, i=0, r=null, s=n === nn ? 0 : 1, o=!1, a=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n,
        props: e,
        key: e && Fp(e),
        ref: e && Ho(e),
        scopeId: Sa,
        slotScopeIds: null,
        children: t,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: i,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
        ctx: Yt
    };
    return a ? (su(l, t),
    s & 128 && n.normalize(l)) : t && (l.shapeFlag |= lt(t) ? 8 : 16),
    Ir > 0 && !o && an && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && an.push(l),
    l
}
const at = gv;
function gv(n, e=null, t=null, i=0, r=null, s=!1) {
    if ((!n || n === Sp) && (n = cn),
    Ns(n)) {
        const a = Yn(n, e, !0);
        return t && su(a, t),
        Ir > 0 && !s && an && (a.shapeFlag & 6 ? an[an.indexOf(n)] = a : an.push(a)),
        a.patchFlag |= -2,
        a
    }
    if (Tv(n) && (n = n.__vccOpts),
    e) {
        e = Op(e);
        let {class: a, style: l} = e;
        a && !lt(a) && (e.class = va(a)),
        tt(l) && (ep(l) && !Ie(l) && (l = _t({}, l)),
        e.style = _a(l))
    }
    const o = lt(n) ? 1 : hp(n) ? 128 : mv(n) ? 64 : tt(n) ? 4 : He(n) ? 2 : 0;
    return ru(n, e, t, i, r, o, s, !0)
}
function Op(n) {
    return n ? ep(n) || ba in n ? _t({}, n) : n : null
}
function Yn(n, e, t=!1) {
    const {props: i, ref: r, patchFlag: s, children: o} = n
      , a = e ? _v(i || {}, e) : i;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n.type,
        props: a,
        key: a && Fp(a),
        ref: e && e.ref ? t && r ? Ie(r) ? r.concat(Ho(e)) : [r, Ho(e)] : Ho(e) : r,
        scopeId: n.scopeId,
        slotScopeIds: n.slotScopeIds,
        children: o,
        target: n.target,
        targetAnchor: n.targetAnchor,
        staticCount: n.staticCount,
        shapeFlag: n.shapeFlag,
        patchFlag: e && n.type !== nn ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: n.dynamicProps,
        dynamicChildren: n.dynamicChildren,
        appContext: n.appContext,
        dirs: n.dirs,
        transition: n.transition,
        component: n.component,
        suspense: n.suspense,
        ssContent: n.ssContent && Yn(n.ssContent),
        ssFallback: n.ssFallback && Yn(n.ssFallback),
        el: n.el,
        anchor: n.anchor,
        ctx: n.ctx,
        ce: n.ce
    }
}
function zp(n=" ", e=0) {
    return at(Dr, null, n, e)
}
function HR(n, e) {
    const t = at(_s, null, n);
    return t.staticCount = e,
    t
}
function rn(n) {
    return n == null || typeof n == "boolean" ? at(cn) : Ie(n) ? at(nn, null, n.slice()) : typeof n == "object" ? hi(n) : at(Dr, null, String(n))
}
function hi(n) {
    return n.el === null && n.patchFlag !== -1 || n.memo ? n : Yn(n)
}
function su(n, e) {
    let t = 0;
    const {shapeFlag: i} = n;
    if (e == null)
        e = null;
    else if (Ie(e))
        t = 16;
    else if (typeof e == "object")
        if (i & 65) {
            const r = e.default;
            r && (r._c && (r._d = !1),
            su(n, r()),
            r._c && (r._d = !0));
            return
        } else {
            t = 32;
            const r = e._;
            !r && !(ba in e) ? e._ctx = Yt : r === 3 && Yt && (Yt.slots._ === 1 ? e._ = 1 : (e._ = 2,
            n.patchFlag |= 1024))
        }
    else
        He(e) ? (e = {
            default: e,
            _ctx: Yt
        },
        t = 32) : (e = String(e),
        i & 64 ? (t = 16,
        e = [zp(e)]) : t = 8);
    n.children = e,
    n.shapeFlag |= t
}
function _v(...n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = n[t];
        for (const r in i)
            if (r === "class")
                e.class !== i.class && (e.class = va([e.class, i.class]));
            else if (r === "style")
                e.style = _a([e.style, i.style]);
            else if (Vs(r)) {
                const s = e[r]
                  , o = i[r];
                o && s !== o && !(Ie(s) && s.includes(o)) && (e[r] = s ? [].concat(s, o) : o)
            } else
                r !== "" && (e[r] = i[r])
    }
    return e
}
function kt(n, e, t, i=null) {
    ln(n, e, 7, [t, i])
}
const vv = Tp();
let xv = 0;
function yv(n, e, t) {
    const i = n.type
      , r = (e ? e.appContext : n.appContext) || vv
      , s = {
        uid: xv++,
        vnode: n,
        type: i,
        parent: e,
        appContext: r,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new zg(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: e ? e.provides : Object.create(r.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: Rp(i, r),
        emitsOptions: up(i, r),
        emit: null,
        emitted: null,
        propsDefaults: rt,
        inheritAttrs: i.inheritAttrs,
        ctx: rt,
        data: rt,
        props: rt,
        attrs: rt,
        slots: rt,
        refs: rt,
        setupState: rt,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: t,
        suspenseId: t ? t.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return s.ctx = {
        _: s
    },
    s.root = e ? e.root : s,
    s.emit = w_.bind(null, s),
    n.ce && n.ce(s),
    s
}
let gt = null;
const ou = () => gt || Yt;
let au, qi, ih = "__VUE_INSTANCE_SETTERS__";
(qi = Wl()[ih]) || (qi = Wl()[ih] = []),
qi.push(n => gt = n),
au = n => {
    qi.length > 1 ? qi.forEach(e => e(n)) : qi[0](n)
}
;
const Ur = n => {
    au(n),
    n.scope.on()
}
  , Bi = () => {
    gt && gt.scope.off(),
    au(null)
}
;
function Bp(n) {
    return n.vnode.shapeFlag & 4
}
let Nr = !1;
function Mv(n, e=!1) {
    Nr = e;
    const {props: t, children: i} = n.vnode
      , r = Bp(n);
    ov(n, t, r, e),
    cv(n, i);
    const s = r ? Sv(n, e) : void 0;
    return Nr = !1,
    s
}
function Sv(n, e) {
    const t = n.type;
    n.accessCache = Object.create(null),
    n.proxy = tp(new Proxy(n.ctx,Z_));
    const {setup: i} = t;
    if (i) {
        const r = n.setupContext = i.length > 1 ? bv(n) : null;
        Ur(n),
        Wr();
        const s = mi(i, n, 0, [n.props, r]);
        if (Xr(),
        Bi(),
        Od(s)) {
            if (s.then(Bi, Bi),
            e)
                return s.then(o => {
                    ec(n, o, e)
                }
                ).catch(o => {
                    $r(o, n, 0)
                }
                );
            n.asyncDep = s
        } else
            ec(n, s, e)
    } else
        Hp(n, e)
}
function ec(n, e, t) {
    He(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : tt(e) && (n.setupState = sp(e)),
    Hp(n, t)
}
let rh;
function Hp(n, e, t) {
    const i = n.type;
    if (!n.render) {
        if (!e && rh && !i.render) {
            const r = i.template || tu(n).template;
            if (r) {
                const {isCustomElement: s, compilerOptions: o} = n.appContext.config
                  , {delimiters: a, compilerOptions: l} = i
                  , c = _t(_t({
                    isCustomElement: s,
                    delimiters: a
                }, o), l);
                i.render = rh(r, c)
            }
        }
        n.render = i.render || yn
    }
    Ur(n),
    Wr(),
    Q_(n),
    Xr(),
    Bi()
}
function Ev(n) {
    return n.attrsProxy || (n.attrsProxy = new Proxy(n.attrs,{
        get(e, t) {
            return Xt(n, "get", "$attrs"),
            e[t]
        }
    }))
}
function bv(n) {
    const e = t => {
        n.exposed = t || {}
    }
    ;
    return {
        get attrs() {
            return Ev(n)
        },
        slots: n.slots,
        emit: n.emit,
        expose: e
    }
}
function lu(n) {
    if (n.exposed)
        return n.exposeProxy || (n.exposeProxy = new Proxy(sp(tp(n.exposed)),{
            get(e, t) {
                if (t in e)
                    return e[t];
                if (t in gs)
                    return gs[t](n)
            },
            has(e, t) {
                return t in e || t in gs
            }
        }))
}
function tc(n, e=!0) {
    return He(n) ? n.displayName || n.name : n.name || e && n.__name
}
function Tv(n) {
    return He(n) && "__vccOpts"in n
}
const _n = (n, e) => M_(n, e, Nr);
function Kn(n, e, t) {
    const i = arguments.length;
    return i === 2 ? tt(e) && !Ie(e) ? Ns(e) ? at(n, null, [e]) : at(n, e) : at(n, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && Ns(t) && (t = [t]),
    at(n, e, t))
}
const wv = Symbol.for("v-scx")
  , Av = () => Jt(wv)
  , kp = "3.3.4"
  , Rv = "http://www.w3.org/2000/svg"
  , Fi = typeof document < "u" ? document : null
  , sh = Fi && Fi.createElement("template")
  , Cv = {
    insert: (n, e, t) => {
        e.insertBefore(n, t || null)
    }
    ,
    remove: n => {
        const e = n.parentNode;
        e && e.removeChild(n)
    }
    ,
    createElement: (n, e, t, i) => {
        const r = e ? Fi.createElementNS(Rv, n) : Fi.createElement(n, t ? {
            is: t
        } : void 0);
        return n === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple),
        r
    }
    ,
    createText: n => Fi.createTextNode(n),
    createComment: n => Fi.createComment(n),
    setText: (n, e) => {
        n.nodeValue = e
    }
    ,
    setElementText: (n, e) => {
        n.textContent = e
    }
    ,
    parentNode: n => n.parentNode,
    nextSibling: n => n.nextSibling,
    querySelector: n => Fi.querySelector(n),
    setScopeId(n, e) {
        n.setAttribute(e, "")
    },
    insertStaticContent(n, e, t, i, r, s) {
        const o = t ? t.previousSibling : e.lastChild;
        if (r && (r === s || r.nextSibling))
            for (; e.insertBefore(r.cloneNode(!0), t),
            !(r === s || !(r = r.nextSibling)); )
                ;
        else {
            sh.innerHTML = i ? `<svg>${n}</svg>` : n;
            const a = sh.content;
            if (i) {
                const l = a.firstChild;
                for (; l.firstChild; )
                    a.appendChild(l.firstChild);
                a.removeChild(l)
            }
            e.insertBefore(a, t)
        }
        return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
    }
};
function Pv(n, e, t) {
    const i = n._vtc;
    i && (e = (e ? [e, ...i] : [...i]).join(" ")),
    e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e
}
function Lv(n, e, t) {
    const i = n.style
      , r = lt(t);
    if (t && !r) {
        if (e && !lt(e))
            for (const s in e)
                t[s] == null && nc(i, s, "");
        for (const s in t)
            nc(i, s, t[s])
    } else {
        const s = i.display;
        r ? e !== t && (i.cssText = t) : e && n.removeAttribute("style"),
        "_vod"in n && (i.display = s)
    }
}
const oh = /\s*!important$/;
function nc(n, e, t) {
    if (Ie(t))
        t.forEach(i => nc(n, e, i));
    else if (t == null && (t = ""),
    e.startsWith("--"))
        n.setProperty(e, t);
    else {
        const i = Dv(n, e);
        oh.test(t) ? n.setProperty(Vr(i), t.replace(oh, ""), "important") : n[i] = t
    }
}
const ah = ["Webkit", "Moz", "ms"]
  , Ja = {};
function Dv(n, e) {
    const t = Ja[e];
    if (t)
        return t;
    let i = Pn(e);
    if (i !== "filter" && i in n)
        return Ja[e] = i;
    i = ga(i);
    for (let r = 0; r < ah.length; r++) {
        const s = ah[r] + i;
        if (s in n)
            return Ja[e] = s
    }
    return e
}
const lh = "http://www.w3.org/1999/xlink";
function Iv(n, e, t, i, r) {
    if (i && e.startsWith("xlink:"))
        t == null ? n.removeAttributeNS(lh, e.slice(6, e.length)) : n.setAttributeNS(lh, e, t);
    else {
        const s = Og(e);
        t == null || s && !kd(t) ? n.removeAttribute(e) : n.setAttribute(e, s ? "" : t)
    }
}
function Uv(n, e, t, i, r, s, o) {
    if (e === "innerHTML" || e === "textContent") {
        i && o(i, r, s),
        n[e] = t ?? "";
        return
    }
    const a = n.tagName;
    if (e === "value" && a !== "PROGRESS" && !a.includes("-")) {
        n._value = t;
        const c = a === "OPTION" ? n.getAttribute("value") : n.value
          , u = t ?? "";
        c !== u && (n.value = u),
        t == null && n.removeAttribute(e);
        return
    }
    let l = !1;
    if (t === "" || t == null) {
        const c = typeof n[e];
        c === "boolean" ? t = kd(t) : t == null && c === "string" ? (t = "",
        l = !0) : c === "number" && (t = 0,
        l = !0)
    }
    try {
        n[e] = t
    } catch {}
    l && n.removeAttribute(e)
}
function Nv(n, e, t, i) {
    n.addEventListener(e, t, i)
}
function Fv(n, e, t, i) {
    n.removeEventListener(e, t, i)
}
function Ov(n, e, t, i, r=null) {
    const s = n._vei || (n._vei = {})
      , o = s[e];
    if (i && o)
        o.value = i;
    else {
        const [a,l] = zv(e);
        if (i) {
            const c = s[e] = kv(i, r);
            Nv(n, a, c, l)
        } else
            o && (Fv(n, a, o, l),
            s[e] = void 0)
    }
}
const ch = /(?:Once|Passive|Capture)$/;
function zv(n) {
    let e;
    if (ch.test(n)) {
        e = {};
        let i;
        for (; i = n.match(ch); )
            n = n.slice(0, n.length - i[0].length),
            e[i[0].toLowerCase()] = !0
    }
    return [n[2] === ":" ? n.slice(3) : Vr(n.slice(2)), e]
}
let Za = 0;
const Bv = Promise.resolve()
  , Hv = () => Za || (Bv.then( () => Za = 0),
Za = Date.now());
function kv(n, e) {
    const t = i => {
        if (!i._vts)
            i._vts = Date.now();
        else if (i._vts <= t.attached)
            return;
        ln(Gv(i, t.value), e, 5, [i])
    }
    ;
    return t.value = n,
    t.attached = Hv(),
    t
}
function Gv(n, e) {
    if (Ie(e)) {
        const t = n.stopImmediatePropagation;
        return n.stopImmediatePropagation = () => {
            t.call(n),
            n._stopped = !0
        }
        ,
        e.map(i => r => !r._stopped && i && i(r))
    } else
        return e
}
const uh = /^on[a-z]/
  , Vv = (n, e, t, i, r=!1, s, o, a, l) => {
    e === "class" ? Pv(n, i, r) : e === "style" ? Lv(n, t, i) : Vs(e) ? Oc(e) || Ov(n, e, t, i, o) : (e[0] === "." ? (e = e.slice(1),
    !0) : e[0] === "^" ? (e = e.slice(1),
    !1) : Wv(n, e, i, r)) ? Uv(n, e, i, s, o, a, l) : (e === "true-value" ? n._trueValue = i : e === "false-value" && (n._falseValue = i),
    Iv(n, e, i, r))
}
;
function Wv(n, e, t, i) {
    return i ? !!(e === "innerHTML" || e === "textContent" || e in n && uh.test(e) && He(t)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA" || uh.test(e) && lt(t) ? !1 : e in n
}
const ni = "transition"
  , es = "animation"
  , cu = (n, {slots: e}) => Kn(H_, Xv(n), e);
cu.displayName = "Transition";
const Gp = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
cu.props = _t({}, mp, Gp);
const Ti = (n, e=[]) => {
    Ie(n) ? n.forEach(t => t(...e)) : n && n(...e)
}
  , hh = n => n ? Ie(n) ? n.some(e => e.length > 1) : n.length > 1 : !1;
function Xv(n) {
    const e = {};
    for (const k in n)
        k in Gp || (e[k] = n[k]);
    if (n.css === !1)
        return e;
    const {name: t="v", type: i, duration: r, enterFromClass: s=`${t}-enter-from`, enterActiveClass: o=`${t}-enter-active`, enterToClass: a=`${t}-enter-to`, appearFromClass: l=s, appearActiveClass: c=o, appearToClass: u=a, leaveFromClass: h=`${t}-leave-from`, leaveActiveClass: f=`${t}-leave-active`, leaveToClass: p=`${t}-leave-to`} = n
      , g = $v(r)
      , x = g && g[0]
      , m = g && g[1]
      , {onBeforeEnter: d, onEnter: v, onEnterCancelled: _, onLeave: M, onLeaveCancelled: b, onBeforeAppear: A=d, onAppear: C=v, onAppearCancelled: P=_} = e
      , S = (k, X, L) => {
        wi(k, X ? u : a),
        wi(k, X ? c : o),
        L && L()
    }
      , T = (k, X) => {
        k._isLeaving = !1,
        wi(k, h),
        wi(k, p),
        wi(k, f),
        X && X()
    }
      , F = k => (X, L) => {
        const G = k ? C : v
          , V = () => S(X, k, L);
        Ti(G, [X, V]),
        fh( () => {
            wi(X, k ? l : s),
            ii(X, k ? u : a),
            hh(G) || dh(X, i, x, V)
        }
        )
    }
    ;
    return _t(e, {
        onBeforeEnter(k) {
            Ti(d, [k]),
            ii(k, s),
            ii(k, o)
        },
        onBeforeAppear(k) {
            Ti(A, [k]),
            ii(k, l),
            ii(k, c)
        },
        onEnter: F(!1),
        onAppear: F(!0),
        onLeave(k, X) {
            k._isLeaving = !0;
            const L = () => T(k, X);
            ii(k, h),
            qv(),
            ii(k, f),
            fh( () => {
                k._isLeaving && (wi(k, h),
                ii(k, p),
                hh(M) || dh(k, i, m, L))
            }
            ),
            Ti(M, [k, L])
        },
        onEnterCancelled(k) {
            S(k, !1),
            Ti(_, [k])
        },
        onAppearCancelled(k) {
            S(k, !0),
            Ti(P, [k])
        },
        onLeaveCancelled(k) {
            T(k),
            Ti(b, [k])
        }
    })
}
function $v(n) {
    if (n == null)
        return null;
    if (tt(n))
        return [Qa(n.enter), Qa(n.leave)];
    {
        const e = Qa(n);
        return [e, e]
    }
}
function Qa(n) {
    return Hd(n)
}
function ii(n, e) {
    e.split(/\s+/).forEach(t => t && n.classList.add(t)),
    (n._vtc || (n._vtc = new Set)).add(e)
}
function wi(n, e) {
    e.split(/\s+/).forEach(i => i && n.classList.remove(i));
    const {_vtc: t} = n;
    t && (t.delete(e),
    t.size || (n._vtc = void 0))
}
function fh(n) {
    requestAnimationFrame( () => {
        requestAnimationFrame(n)
    }
    )
}
let jv = 0;
function dh(n, e, t, i) {
    const r = n._endId = ++jv
      , s = () => {
        r === n._endId && i()
    }
    ;
    if (t)
        return setTimeout(s, t);
    const {type: o, timeout: a, propCount: l} = Kv(n, e);
    if (!o)
        return i();
    const c = o + "end";
    let u = 0;
    const h = () => {
        n.removeEventListener(c, f),
        s()
    }
      , f = p => {
        p.target === n && ++u >= l && h()
    }
    ;
    setTimeout( () => {
        u < l && h()
    }
    , a + 1),
    n.addEventListener(c, f)
}
function Kv(n, e) {
    const t = window.getComputedStyle(n)
      , i = g => (t[g] || "").split(", ")
      , r = i(`${ni}Delay`)
      , s = i(`${ni}Duration`)
      , o = ph(r, s)
      , a = i(`${es}Delay`)
      , l = i(`${es}Duration`)
      , c = ph(a, l);
    let u = null
      , h = 0
      , f = 0;
    e === ni ? o > 0 && (u = ni,
    h = o,
    f = s.length) : e === es ? c > 0 && (u = es,
    h = c,
    f = l.length) : (h = Math.max(o, c),
    u = h > 0 ? o > c ? ni : es : null,
    f = u ? u === ni ? s.length : l.length : 0);
    const p = u === ni && /\b(transform|all)(,|$)/.test(i(`${ni}Property`).toString());
    return {
        type: u,
        timeout: h,
        propCount: f,
        hasTransform: p
    }
}
function ph(n, e) {
    for (; n.length < e.length; )
        n = n.concat(n);
    return Math.max(...e.map( (t, i) => mh(t) + mh(n[i])))
}
function mh(n) {
    return Number(n.slice(0, -1).replace(",", ".")) * 1e3
}
function qv() {
    return document.body.offsetHeight
}
const Vp = _t({
    patchProp: Vv
}, Cv);
let xs, gh = !1;
function Yv() {
    return xs || (xs = fv(Vp))
}
function Jv() {
    return xs = gh ? xs : dv(Vp),
    gh = !0,
    xs
}
const Zv = (...n) => {
    const e = Yv().createApp(...n)
      , {mount: t} = e;
    return e.mount = i => {
        const r = Wp(i);
        if (!r)
            return;
        const s = e._component;
        !He(s) && !s.render && !s.template && (s.template = r.innerHTML),
        r.innerHTML = "";
        const o = t(r, !1, r instanceof SVGElement);
        return r instanceof Element && (r.removeAttribute("v-cloak"),
        r.setAttribute("data-v-app", "")),
        o
    }
    ,
    e
}
  , Qv = (...n) => {
    const e = Jv().createApp(...n)
      , {mount: t} = e;
    return e.mount = i => {
        const r = Wp(i);
        if (r)
            return t(r, !0, r instanceof SVGElement)
    }
    ,
    e
}
;
function Wp(n) {
    return lt(n) ? document.querySelector(n) : n
}
const e0 = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , t0 = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , n0 = /^\s*["[{]|^\s*-?\d[\d.]{0,14}\s*$/;
function i0(n, e) {
    if (n === "__proto__" || n === "constructor" && e && typeof e == "object" && "prototype"in e) {
        r0(n);
        return
    }
    return e
}
function r0(n) {
    console.warn(`[destr] Dropping "${n}" key to prevent prototype pollution.`)
}
function Qo(n, e={}) {
    if (typeof n != "string")
        return n;
    const t = n.trim();
    if (n[0] === '"' && n[n.length - 1] === '"')
        return t.slice(1, -1);
    if (t.length <= 9) {
        const i = t.toLowerCase();
        if (i === "true")
            return !0;
        if (i === "false")
            return !1;
        if (i === "undefined")
            return;
        if (i === "null")
            return null;
        if (i === "nan")
            return Number.NaN;
        if (i === "infinity")
            return Number.POSITIVE_INFINITY;
        if (i === "-infinity")
            return Number.NEGATIVE_INFINITY
    }
    if (!n0.test(n)) {
        if (e.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return n
    }
    try {
        if (e0.test(n) || t0.test(n)) {
            if (e.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(n, i0)
        }
        return JSON.parse(n)
    } catch (i) {
        if (e.strict)
            throw i;
        return n
    }
}
const Xp = /#/g
  , $p = /&/g
  , s0 = /\//g
  , o0 = /=/g
  , a0 = /\?/g
  , Ta = /\+/g
  , l0 = /%5e/gi
  , c0 = /%60/gi
  , u0 = /%7c/gi
  , h0 = /%20/gi
  , f0 = /%252f/gi;
function jp(n) {
    return encodeURI("" + n).replace(u0, "|")
}
function ic(n) {
    return jp(typeof n == "string" ? n : JSON.stringify(n)).replace(Ta, "%2B").replace(h0, "+").replace(Xp, "%23").replace($p, "%26").replace(c0, "`").replace(l0, "^")
}
function el(n) {
    return ic(n).replace(o0, "%3D")
}
function d0(n) {
    return jp(n).replace(Xp, "%23").replace(a0, "%3F").replace(f0, "%2F").replace($p, "%26").replace(Ta, "%2B")
}
function kR(n) {
    return d0(n).replace(s0, "%2F")
}
function ea(n="") {
    try {
        return decodeURIComponent("" + n)
    } catch {
        return "" + n
    }
}
function p0(n) {
    return ea(n.replace(Ta, " "))
}
function m0(n) {
    return ea(n.replace(Ta, " "))
}
function g0(n="") {
    const e = {};
    n[0] === "?" && (n = n.slice(1));
    for (const t of n.split("&")) {
        const i = t.match(/([^=]+)=?(.*)/) || [];
        if (i.length < 2)
            continue;
        const r = p0(i[1]);
        if (r === "__proto__" || r === "constructor")
            continue;
        const s = m0(i[2] || "");
        e[r] === void 0 ? e[r] = s : Array.isArray(e[r]) ? e[r].push(s) : e[r] = [e[r], s]
    }
    return e
}
function _0(n, e) {
    return (typeof e == "number" || typeof e == "boolean") && (e = String(e)),
    e ? Array.isArray(e) ? e.map(t => `${el(n)}=${ic(t)}`).join("&") : `${el(n)}=${ic(e)}` : el(n)
}
function v0(n) {
    return Object.keys(n).filter(e => n[e] !== void 0).map(e => _0(e, n[e])).filter(Boolean).join("&")
}
const x0 = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/
  , y0 = /^[\s\w\0+.-]{2,}:([/\\]{2})?/
  , M0 = /^([/\\]\s*){2,}[^/\\]/;
function Ks(n, e={}) {
    return typeof e == "boolean" && (e = {
        acceptRelative: e
    }),
    e.strict ? x0.test(n) : y0.test(n) || (e.acceptRelative ? M0.test(n) : !1)
}
const S0 = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
function E0(n) {
    return !!n && S0.test(n)
}
const b0 = /\/$|\/\?/;
function rc(n="", e=!1) {
    return e ? b0.test(n) : n.endsWith("/")
}
function Kp(n="", e=!1) {
    if (!e)
        return (rc(n) ? n.slice(0, -1) : n) || "/";
    if (!rc(n, !0))
        return n || "/";
    const [t,...i] = n.split("?");
    return (t.slice(0, -1) || "/") + (i.length > 0 ? `?${i.join("?")}` : "")
}
function sc(n="", e=!1) {
    if (!e)
        return n.endsWith("/") ? n : n + "/";
    if (rc(n, !0))
        return n || "/";
    const [t,...i] = n.split("?");
    return t + "/" + (i.length > 0 ? `?${i.join("?")}` : "")
}
function T0(n="") {
    return n.startsWith("/")
}
function _h(n="") {
    return T0(n) ? n : "/" + n
}
function w0(n, e) {
    if (Yp(e) || Ks(n))
        return n;
    const t = Kp(e);
    return n.startsWith(t) ? n : qs(t, n)
}
function vh(n, e) {
    if (Yp(e))
        return n;
    const t = Kp(e);
    if (!n.startsWith(t))
        return n;
    const i = n.slice(t.length);
    return i[0] === "/" ? i : "/" + i
}
function qp(n, e) {
    const t = wa(n)
      , i = {
        ...g0(t.search),
        ...e
    };
    return t.search = v0(i),
    P0(t)
}
function Yp(n) {
    return !n || n === "/"
}
function A0(n) {
    return n && n !== "/"
}
const R0 = /^\.?\//;
function qs(n, ...e) {
    let t = n || "";
    for (const i of e.filter(r => A0(r)))
        if (t) {
            const r = i.replace(R0, "");
            t = sc(t) + r
        } else
            t = i;
    return t
}
function C0(n, e, t={}) {
    return t.trailingSlash || (n = sc(n),
    e = sc(e)),
    t.leadingSlash || (n = _h(n),
    e = _h(e)),
    t.encoding || (n = ea(n),
    e = ea(e)),
    n === e
}
function wa(n="", e) {
    const t = n.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/);
    if (t) {
        const [,h,f=""] = t;
        return {
            protocol: h,
            pathname: f,
            href: h + f,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!Ks(n, {
        acceptRelative: !0
    }))
        return e ? wa(e + n) : xh(n);
    const [,i="",r,s=""] = n.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
      , [,o="",a=""] = s.match(/([^#/?]*)(.*)?/) || []
      , {pathname: l, search: c, hash: u} = xh(a.replace(/\/(?=[A-Za-z]:)/, ""));
    return {
        protocol: i,
        auth: r ? r.slice(0, Math.max(0, r.length - 1)) : "",
        host: o,
        pathname: l,
        search: c,
        hash: u
    }
}
function xh(n="") {
    const [e="",t="",i=""] = (n.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: e,
        search: t,
        hash: i
    }
}
function P0(n) {
    const e = n.pathname || ""
      , t = n.search ? (n.search.startsWith("?") ? "" : "?") + n.search : ""
      , i = n.hash || ""
      , r = n.auth ? n.auth + "@" : ""
      , s = n.host || "";
    return (n.protocol ? n.protocol + "//" : "") + r + s + e + t + i
}
class L0 extends Error {
    constructor(e, t) {
        super(e, t),
        this.name = "FetchError",
        t != null && t.cause && !this.cause && (this.cause = t.cause)
    }
}
function D0(n) {
    var l, c, u, h, f;
    const e = ((l = n.error) == null ? void 0 : l.message) || ((c = n.error) == null ? void 0 : c.toString()) || ""
      , t = ((u = n.request) == null ? void 0 : u.method) || ((h = n.options) == null ? void 0 : h.method) || "GET"
      , i = ((f = n.request) == null ? void 0 : f.url) || String(n.request) || "/"
      , r = `[${t}] ${JSON.stringify(i)}`
      , s = n.response ? `${n.response.status} ${n.response.statusText}` : "<no response>"
      , o = `${r}: ${s}${e ? ` ${e}` : ""}`
      , a = new L0(o,n.error ? {
        cause: n.error
    } : void 0);
    for (const p of ["request", "options", "response"])
        Object.defineProperty(a, p, {
            get() {
                return n[p]
            }
        });
    for (const [p,g] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
        Object.defineProperty(a, p, {
            get() {
                return n.response && n.response[g]
            }
        });
    return a
}
const I0 = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function yh(n="GET") {
    return I0.has(n.toUpperCase())
}
function U0(n) {
    if (n === void 0)
        return !1;
    const e = typeof n;
    return e === "string" || e === "number" || e === "boolean" || e === null ? !0 : e !== "object" ? !1 : Array.isArray(n) ? !0 : n.buffer ? !1 : n.constructor && n.constructor.name === "Object" || typeof n.toJSON == "function"
}
const N0 = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
  , F0 = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function O0(n="") {
    if (!n)
        return "json";
    const e = n.split(";").shift() || "";
    return F0.test(e) ? "json" : N0.has(e) || e.startsWith("text/") ? "text" : "blob"
}
function z0(n, e, t=globalThis.Headers) {
    const i = {
        ...e,
        ...n
    };
    if (e != null && e.params && (n != null && n.params) && (i.params = {
        ...e == null ? void 0 : e.params,
        ...n == null ? void 0 : n.params
    }),
    e != null && e.query && (n != null && n.query) && (i.query = {
        ...e == null ? void 0 : e.query,
        ...n == null ? void 0 : n.query
    }),
    e != null && e.headers && (n != null && n.headers)) {
        i.headers = new t((e == null ? void 0 : e.headers) || {});
        for (const [r,s] of new t((n == null ? void 0 : n.headers) || {}))
            i.headers.set(r, s)
    }
    return i
}
const B0 = new Set([408, 409, 425, 429, 500, 502, 503, 504])
  , H0 = new Set([101, 204, 205, 304]);
function Jp(n={}) {
    const {fetch: e=globalThis.fetch, Headers: t=globalThis.Headers, AbortController: i=globalThis.AbortController} = n;
    async function r(a) {
        const l = a.error && a.error.name === "AbortError" && !a.options.timeout || !1;
        if (a.options.retry !== !1 && !l) {
            let u;
            typeof a.options.retry == "number" ? u = a.options.retry : u = yh(a.options.method) ? 0 : 1;
            const h = a.response && a.response.status || 500;
            if (u > 0 && (Array.isArray(a.options.retryStatusCodes) ? a.options.retryStatusCodes.includes(h) : B0.has(h))) {
                const f = a.options.retryDelay || 0;
                return f > 0 && await new Promise(p => setTimeout(p, f)),
                s(a.request, {
                    ...a.options,
                    retry: u - 1,
                    timeout: a.options.timeout
                })
            }
        }
        const c = D0(a);
        throw Error.captureStackTrace && Error.captureStackTrace(c, s),
        c
    }
    const s = async function(l, c={}) {
        var f;
        const u = {
            request: l,
            options: z0(c, n.defaults, t),
            response: void 0,
            error: void 0
        };
        if (u.options.method = (f = u.options.method) == null ? void 0 : f.toUpperCase(),
        u.options.onRequest && await u.options.onRequest(u),
        typeof u.request == "string" && (u.options.baseURL && (u.request = w0(u.request, u.options.baseURL)),
        (u.options.query || u.options.params) && (u.request = qp(u.request, {
            ...u.options.params,
            ...u.options.query
        }))),
        u.options.body && yh(u.options.method) && (U0(u.options.body) ? (u.options.body = typeof u.options.body == "string" ? u.options.body : JSON.stringify(u.options.body),
        u.options.headers = new t(u.options.headers || {}),
        u.options.headers.has("content-type") || u.options.headers.set("content-type", "application/json"),
        u.options.headers.has("accept") || u.options.headers.set("accept", "application/json")) : ("pipeTo"in u.options.body && typeof u.options.body.pipeTo == "function" || typeof u.options.body.pipe == "function") && ("duplex"in u.options || (u.options.duplex = "half"))),
        !u.options.signal && u.options.timeout) {
            const p = new i;
            setTimeout( () => p.abort(), u.options.timeout),
            u.options.signal = p.signal
        }
        try {
            u.response = await e(u.request, u.options)
        } catch (p) {
            return u.error = p,
            u.options.onRequestError && await u.options.onRequestError(u),
            await r(u)
        }
        if (u.response.body && !H0.has(u.response.status) && u.options.method !== "HEAD") {
            const p = (u.options.parseResponse ? "json" : u.options.responseType) || O0(u.response.headers.get("content-type") || "");
            switch (p) {
            case "json":
                {
                    const g = await u.response.text()
                      , x = u.options.parseResponse || Qo;
                    u.response._data = x(g);
                    break
                }
            case "stream":
                {
                    u.response._data = u.response.body;
                    break
                }
            default:
                u.response._data = await u.response[p]()
            }
        }
        return u.options.onResponse && await u.options.onResponse(u),
        !u.options.ignoreResponseError && u.response.status >= 400 && u.response.status < 600 ? (u.options.onResponseError && await u.options.onResponseError(u),
        await r(u)) : u.response
    }
      , o = async function(l, c) {
        return (await s(l, c))._data
    };
    return o.raw = s,
    o.native = (...a) => e(...a),
    o.create = (a={}) => Jp({
        ...n,
        defaults: {
            ...n.defaults,
            ...a
        }
    }),
    o
}
const uu = function() {
    if (typeof globalThis < "u")
        return globalThis;
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}()
  , k0 = uu.fetch || ( () => Promise.reject(new Error("[ofetch] global.fetch is not supported!")))
  , G0 = uu.Headers
  , V0 = uu.AbortController
  , W0 = Jp({
    fetch: k0,
    Headers: G0,
    AbortController: V0
})
  , X0 = W0
  , $0 = () => {
    var n;
    return ((n = window == null ? void 0 : window.__NUXT__) == null ? void 0 : n.config) || {}
}
  , ta = $0().app
  , j0 = () => ta.baseURL
  , K0 = () => ta.buildAssetsDir
  , q0 = (...n) => qs(Zp(), K0(), ...n)
  , Zp = (...n) => {
    const e = ta.cdnURL || ta.baseURL;
    return n.length ? qs(e, ...n) : e
}
;
globalThis.__buildAssetsURL = q0,
globalThis.__publicAssetsURL = Zp;
function oc(n, e={}, t) {
    for (const i in n) {
        const r = n[i]
          , s = t ? `${t}:${i}` : i;
        typeof r == "object" && r !== null ? oc(r, e, s) : typeof r == "function" && (e[s] = r)
    }
    return e
}
const Y0 = {
    run: n => n()
}
  , J0 = () => Y0
  , Qp = typeof console.createTask < "u" ? console.createTask : J0;
function Z0(n, e) {
    const t = e.shift()
      , i = Qp(t);
    return n.reduce( (r, s) => r.then( () => i.run( () => s(...e))), Promise.resolve())
}
function Q0(n, e) {
    const t = e.shift()
      , i = Qp(t);
    return Promise.all(n.map(r => i.run( () => r(...e))))
}
function tl(n, e) {
    for (const t of [...n])
        t(e)
}
class ex {
    constructor() {
        this._hooks = {},
        this._before = void 0,
        this._after = void 0,
        this._deprecatedMessages = void 0,
        this._deprecatedHooks = {},
        this.hook = this.hook.bind(this),
        this.callHook = this.callHook.bind(this),
        this.callHookWith = this.callHookWith.bind(this)
    }
    hook(e, t, i={}) {
        if (!e || typeof t != "function")
            return () => {}
            ;
        const r = e;
        let s;
        for (; this._deprecatedHooks[e]; )
            s = this._deprecatedHooks[e],
            e = s.to;
        if (s && !i.allowDeprecated) {
            let o = s.message;
            o || (o = `${r} hook has been deprecated` + (s.to ? `, please use ${s.to}` : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set),
            this._deprecatedMessages.has(o) || (console.warn(o),
            this._deprecatedMessages.add(o))
        }
        if (!t.name)
            try {
                Object.defineProperty(t, "name", {
                    get: () => "_" + e.replace(/\W+/g, "_") + "_hook_cb",
                    configurable: !0
                })
            } catch {}
        return this._hooks[e] = this._hooks[e] || [],
        this._hooks[e].push(t),
        () => {
            t && (this.removeHook(e, t),
            t = void 0)
        }
    }
    hookOnce(e, t) {
        let i, r = (...s) => (typeof i == "function" && i(),
        i = void 0,
        r = void 0,
        t(...s));
        return i = this.hook(e, r),
        i
    }
    removeHook(e, t) {
        if (this._hooks[e]) {
            const i = this._hooks[e].indexOf(t);
            i !== -1 && this._hooks[e].splice(i, 1),
            this._hooks[e].length === 0 && delete this._hooks[e]
        }
    }
    deprecateHook(e, t) {
        this._deprecatedHooks[e] = typeof t == "string" ? {
            to: t
        } : t;
        const i = this._hooks[e] || [];
        delete this._hooks[e];
        for (const r of i)
            this.hook(e, r)
    }
    deprecateHooks(e) {
        Object.assign(this._deprecatedHooks, e);
        for (const t in e)
            this.deprecateHook(t, e[t])
    }
    addHooks(e) {
        const t = oc(e)
          , i = Object.keys(t).map(r => this.hook(r, t[r]));
        return () => {
            for (const r of i.splice(0, i.length))
                r()
        }
    }
    removeHooks(e) {
        const t = oc(e);
        for (const i in t)
            this.removeHook(i, t[i])
    }
    removeAllHooks() {
        for (const e in this._hooks)
            delete this._hooks[e]
    }
    callHook(e, ...t) {
        return t.unshift(e),
        this.callHookWith(Z0, e, ...t)
    }
    callHookParallel(e, ...t) {
        return t.unshift(e),
        this.callHookWith(Q0, e, ...t)
    }
    callHookWith(e, t, ...i) {
        const r = this._before || this._after ? {
            name: t,
            args: i,
            context: {}
        } : void 0;
        this._before && tl(this._before, r);
        const s = e(t in this._hooks ? [...this._hooks[t]] : [], i);
        return s instanceof Promise ? s.finally( () => {
            this._after && r && tl(this._after, r)
        }
        ) : (this._after && r && tl(this._after, r),
        s)
    }
    beforeEach(e) {
        return this._before = this._before || [],
        this._before.push(e),
        () => {
            if (this._before !== void 0) {
                const t = this._before.indexOf(e);
                t !== -1 && this._before.splice(t, 1)
            }
        }
    }
    afterEach(e) {
        return this._after = this._after || [],
        this._after.push(e),
        () => {
            if (this._after !== void 0) {
                const t = this._after.indexOf(e);
                t !== -1 && this._after.splice(t, 1)
            }
        }
    }
}
function em() {
    return new ex
}
function tx(n={}) {
    let e, t = !1;
    const i = o => {
        if (e && e !== o)
            throw new Error("Context conflict")
    }
    ;
    let r;
    if (n.asyncContext) {
        const o = n.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        o ? r = new o : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const s = () => {
        if (r && e === void 0) {
            const o = r.getStore();
            if (o !== void 0)
                return o
        }
        return e
    }
    ;
    return {
        use: () => {
            const o = s();
            if (o === void 0)
                throw new Error("Context is not available");
            return o
        }
        ,
        tryUse: () => s(),
        set: (o, a) => {
            a || i(o),
            e = o,
            t = !0
        }
        ,
        unset: () => {
            e = void 0,
            t = !1
        }
        ,
        call: (o, a) => {
            i(o),
            e = o;
            try {
                return r ? r.run(o, a) : a()
            } finally {
                t || (e = void 0)
            }
        }
        ,
        async callAsync(o, a) {
            e = o;
            const l = () => {
                e = o
            }
              , c = () => e === o ? l : void 0;
            ac.add(c);
            try {
                const u = r ? r.run(o, a) : a();
                return t || (e = void 0),
                await u
            } finally {
                ac.delete(c)
            }
        }
    }
}
function nx(n={}) {
    const e = {};
    return {
        get(t, i={}) {
            return e[t] || (e[t] = tx({
                ...n,
                ...i
            })),
            e[t],
            e[t]
        }
    }
}
const na = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}
  , Mh = "__unctx__"
  , ix = na[Mh] || (na[Mh] = nx())
  , rx = (n, e={}) => ix.get(n, e)
  , Sh = "__unctx_async_handlers__"
  , ac = na[Sh] || (na[Sh] = new Set);
function ia(n) {
    const e = [];
    for (const r of ac) {
        const s = r();
        s && e.push(s)
    }
    const t = () => {
        for (const r of e)
            r()
    }
    ;
    let i = n();
    return i && typeof i == "object" && "catch"in i && (i = i.catch(r => {
        throw t(),
        r
    }
    )),
    [i, t]
}
const tm = rx("nuxt-app", {
    asyncContext: !1
})
  , sx = "__nuxt_plugin";
function ox(n) {
    let e = 0;
    const t = {
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.7.4"
            },
            get vue() {
                return t.vueApp.version
            }
        },
        payload: yi({
            data: {},
            state: {},
            _errors: {},
            ...window.__NUXT__ ?? {}
        }),
        static: {
            data: {}
        },
        runWithContext: r => cx(t, r),
        isHydrating: !0,
        deferHydration() {
            if (!t.isHydrating)
                return () => {}
                ;
            e++;
            let r = !1;
            return () => {
                if (!r && (r = !0,
                e--,
                e === 0))
                    return t.isHydrating = !1,
                    t.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: {},
        _payloadRevivers: {},
        ...n
    };
    t.hooks = em(),
    t.hook = t.hooks.hook,
    t.callHook = t.hooks.callHook,
    t.provide = (r, s) => {
        const o = "$" + r;
        lo(t, o, s),
        lo(t.vueApp.config.globalProperties, o, s)
    }
    ,
    lo(t.vueApp, "$nuxt", t),
    lo(t.vueApp.config.globalProperties, "$nuxt", t);
    {
        window.addEventListener("nuxt.preloadError", s => {
            t.callHook("app:chunkError", {
                error: s.payload
            })
        }
        ),
        window.useNuxtApp = window.useNuxtApp || ft;
        const r = t.hook("app:error", (...s) => {
            console.error("[nuxt] error caught during app initialization", ...s)
        }
        );
        t.hook("app:mounted", r)
    }
    const i = yi(t.payload.config);
    return t.provide("config", i),
    t
}
async function ax(n, e) {
    if (e.hooks && n.hooks.addHooks(e.hooks),
    typeof e == "function") {
        const {provide: t} = await n.runWithContext( () => e(n)) || {};
        if (t && typeof t == "object")
            for (const i in t)
                n.provide(i, t[i])
    }
}
async function lx(n, e) {
    const t = []
      , i = [];
    for (const r of e) {
        const s = ax(n, r);
        r.parallel ? t.push(s.catch(o => i.push(o))) : await s
    }
    if (await Promise.all(t),
    i.length)
        throw i[0]
}
/*! @__NO_SIDE_EFFECTS__ */
function ji(n) {
    return typeof n == "function" ? n : (delete n.name,
    Object.assign(n.setup || ( () => {}
    ), n, {
        [sx]: !0
    }))
}
function cx(n, e, t) {
    const i = () => t ? e(...t) : e();
    return tm.set(n),
    n.vueApp.runWithContext(i)
}
/*! @__NO_SIDE_EFFECTS__ */
function ft() {
    var e;
    let n;
    if (wp() && (n = (e = ou()) == null ? void 0 : e.appContext.app.$nuxt),
    n = n || tm.tryUse(),
    !n)
        throw new Error("[nuxt] instance unavailable");
    return n
}
/*! @__NO_SIDE_EFFECTS__ */
function Aa() {
    return ft().$config
}
function lo(n, e, t) {
    Object.defineProperty(n, e, {
        get: () => t
    })
}
const ux = "modulepreload"
  , hx = function(n, e) {
    return n[0] === "." ? new URL(n,e).href : n
}
  , Eh = {}
  , fx = function(e, t, i) {
    if (!t || t.length === 0)
        return e();
    const r = document.getElementsByTagName("link");
    return Promise.all(t.map(s => {
        if (s = hx(s, i),
        s in Eh)
            return;
        Eh[s] = !0;
        const o = s.endsWith(".css")
          , a = o ? '[rel="stylesheet"]' : "";
        if (!!i)
            for (let u = r.length - 1; u >= 0; u--) {
                const h = r[u];
                if (h.href === s && (!o || h.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${s}"]${a}`))
            return;
        const c = document.createElement("link");
        if (c.rel = o ? "stylesheet" : ux,
        o || (c.as = "script",
        c.crossOrigin = ""),
        c.href = s,
        document.head.appendChild(c),
        o)
            return new Promise( (u, h) => {
                c.addEventListener("load", u),
                c.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${s}`)))
            }
            )
    }
    )).then( () => e()).catch(s => {
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = s,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw s
    }
    )
}
  , lc = (...n) => fx(...n).catch(e => {
    const t = new Event("nuxt.preloadError");
    throw t.payload = e,
    window.dispatchEvent(t),
    e
}
)
  , dx = -1
  , px = -2
  , mx = -3
  , gx = -4
  , _x = -5
  , vx = -6;
function xx(n, e) {
    return yx(JSON.parse(n), e)
}
function yx(n, e) {
    if (typeof n == "number")
        return r(n, !0);
    if (!Array.isArray(n) || n.length === 0)
        throw new Error("Invalid input");
    const t = n
      , i = Array(t.length);
    function r(s, o=!1) {
        if (s === dx)
            return;
        if (s === mx)
            return NaN;
        if (s === gx)
            return 1 / 0;
        if (s === _x)
            return -1 / 0;
        if (s === vx)
            return -0;
        if (o)
            throw new Error("Invalid input");
        if (s in i)
            return i[s];
        const a = t[s];
        if (!a || typeof a != "object")
            i[s] = a;
        else if (Array.isArray(a))
            if (typeof a[0] == "string") {
                const l = a[0]
                  , c = e == null ? void 0 : e[l];
                if (c)
                    return i[s] = c(r(a[1]));
                switch (l) {
                case "Date":
                    i[s] = new Date(a[1]);
                    break;
                case "Set":
                    const u = new Set;
                    i[s] = u;
                    for (let p = 1; p < a.length; p += 1)
                        u.add(r(a[p]));
                    break;
                case "Map":
                    const h = new Map;
                    i[s] = h;
                    for (let p = 1; p < a.length; p += 2)
                        h.set(r(a[p]), r(a[p + 1]));
                    break;
                case "RegExp":
                    i[s] = new RegExp(a[1],a[2]);
                    break;
                case "Object":
                    i[s] = Object(a[1]);
                    break;
                case "BigInt":
                    i[s] = BigInt(a[1]);
                    break;
                case "null":
                    const f = Object.create(null);
                    i[s] = f;
                    for (let p = 1; p < a.length; p += 2)
                        f[a[p]] = r(a[p + 1]);
                    break;
                default:
                    throw new Error(`Unknown type ${l}`)
                }
            } else {
                const l = new Array(a.length);
                i[s] = l;
                for (let c = 0; c < a.length; c += 1) {
                    const u = a[c];
                    u !== px && (l[c] = r(u))
                }
            }
        else {
            const l = {};
            i[s] = l;
            for (const c in a) {
                const u = a[c];
                l[c] = r(u)
            }
        }
        return i[s]
    }
    return r(0)
}
function Mx(n) {
    return Array.isArray(n) ? n : [n]
}
const Sx = ["title", "titleTemplate", "script", "style", "noscript"]
  , ko = ["base", "meta", "link", "style", "script", "noscript"]
  , Ex = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]
  , bx = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]
  , nm = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent", "processTemplateParams"]
  , Tx = typeof window < "u";
function im(n) {
    let e = 9;
    for (let t = 0; t < n.length; )
        e = Math.imul(e ^ n.charCodeAt(t++), 9 ** 9);
    return ((e ^ e >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}
function bh(n) {
    return n._h || im(n._d ? n._d : `${n.tag}:${n.textContent || n.innerHTML || ""}:${Object.entries(n.props).map( ([e,t]) => `${e}:${String(t)}`).join(",")}`)
}
function rm(n, e) {
    const {props: t, tag: i} = n;
    if (bx.includes(i))
        return i;
    if (i === "link" && t.rel === "canonical")
        return "canonical";
    if (t.charset)
        return "charset";
    const r = ["id"];
    i === "meta" && r.push("name", "property", "http-equiv");
    for (const s of r)
        if (typeof t[s] < "u") {
            const o = String(t[s]);
            return e && !e(o) ? !1 : `${i}:${s}:${o}`
        }
    return !1
}
function Th(n, e) {
    return n == null ? e || null : typeof n == "function" ? n(e) : n
}
async function wx(n, e, t) {
    const i = {
        tag: n,
        props: await sm(typeof e == "object" && typeof e != "function" && !(e instanceof Promise) ? {
            ...e
        } : {
            [["script", "noscript", "style"].includes(n) ? "innerHTML" : "textContent"]: e
        }, ["templateParams", "titleTemplate"].includes(n))
    };
    return nm.forEach(r => {
        const s = typeof i.props[r] < "u" ? i.props[r] : t[r];
        typeof s < "u" && ((!["innerHTML", "textContent"].includes(r) || Sx.includes(i.tag)) && (i[r] = s),
        delete i.props[r])
    }
    ),
    i.props.body && (i.tagPosition = "bodyClose",
    delete i.props.body),
    i.props.children && (i.innerHTML = i.props.children,
    delete i.props.children),
    i.tag === "script" && (typeof i.innerHTML == "object" && (i.innerHTML = JSON.stringify(i.innerHTML),
    i.props.type = i.props.type || "application/json"),
    i.innerHTML && ["application/ld+json", "application/json"].includes(i.props.type) && (i.innerHTML = i.innerHTML.replace(/</g, "\\u003C"))),
    Array.isArray(i.props.content) ? i.props.content.map(r => ({
        ...i,
        props: {
            ...i.props,
            content: r
        }
    })) : i
}
function Ax(n) {
    return typeof n == "object" && !Array.isArray(n) && (n = Object.keys(n).filter(e => n[e])),
    (Array.isArray(n) ? n.join(" ") : n).split(" ").filter(e => e.trim()).filter(Boolean).join(" ")
}
async function sm(n, e) {
    for (const t of Object.keys(n)) {
        if (t === "class") {
            n[t] = Ax(n[t]);
            continue
        }
        if (n[t]instanceof Promise && (n[t] = await n[t]),
        !e && !nm.includes(t)) {
            const i = String(n[t])
              , r = t.startsWith("data-");
            i === "true" || i === "" ? n[t] = r ? "true" : !0 : n[t] || (r && i === "false" ? n[t] = "false" : delete n[t])
        }
    }
    return n
}
const Rx = 10;
async function Cx(n) {
    const e = [];
    return Object.entries(n.resolvedInput).filter( ([t,i]) => typeof i < "u" && Ex.includes(t)).forEach( ([t,i]) => {
        const r = Mx(i);
        e.push(...r.map(s => wx(t, s, n)).flat())
    }
    ),
    (await Promise.all(e)).flat().filter(Boolean).map( (t, i) => (t._e = n._i,
    n.mode && (t._m = n.mode),
    t._p = (n._i << Rx) + i,
    t))
}
const wh = {
    base: -10,
    title: 10
}
  , Ah = {
    critical: -80,
    high: -10,
    low: 20
};
function ra(n) {
    let e = 100;
    const t = n.tagPriority;
    return typeof t == "number" ? t : (n.tag === "meta" ? (n.props["http-equiv"] === "content-security-policy" && (e = -30),
    n.props.charset && (e = -20),
    n.props.name === "viewport" && (e = -15)) : n.tag === "link" && n.props.rel === "preconnect" ? e = 20 : n.tag in wh && (e = wh[n.tag]),
    typeof t == "string" && t in Ah ? e + Ah[t] : e)
}
const Px = [{
    prefix: "before:",
    offset: -1
}, {
    prefix: "after:",
    offset: 1
}]
  , ri = "%separator";
function Li(n, e, t) {
    if (typeof n != "string" || !n.includes("%"))
        return n;
    function i(o) {
        let a;
        return ["s", "pageTitle"].includes(o) ? a = e.pageTitle : o.includes(".") ? a = o.split(".").reduce( (l, c) => l && l[c] || void 0, e) : a = e[o],
        typeof a < "u" ? (a || "").replace(/"/g, '\\"') : !1
    }
    let r = n;
    try {
        r = decodeURI(n)
    } catch {}
    return (r.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(o => {
        const a = i(o.slice(1));
        typeof a == "string" && (n = n.replace(new RegExp(`\\${o}(\\W|$)`,"g"), (l, c) => `${a}${c}`).trim())
    }
    ),
    n.includes(ri) && (n.endsWith(ri) && (n = n.slice(0, -ri.length).trim()),
    n.startsWith(ri) && (n = n.slice(ri.length).trim()),
    n = n.replace(new RegExp(`\\${ri}\\s*\\${ri}`,"g"), ri),
    n = Li(n, {
        separator: t
    }, t)),
    n
}
async function Lx(n) {
    const e = {
        tag: n.tagName.toLowerCase(),
        props: await sm(n.getAttributeNames().reduce( (t, i) => ({
            ...t,
            [i]: n.getAttribute(i)
        }), {})),
        innerHTML: n.innerHTML
    };
    return e._d = rm(e),
    e
}
async function om(n, e={}) {
    var u;
    const t = e.document || n.resolvedOptions.document;
    if (!t)
        return;
    const i = {
        shouldRender: n.dirty,
        tags: []
    };
    if (await n.hooks.callHook("dom:beforeRender", i),
    !i.shouldRender)
        return;
    const r = (await n.resolveTags()).map(h => ({
        tag: h,
        id: ko.includes(h.tag) ? bh(h) : h.tag,
        shouldRender: !0
    }));
    let s = n._dom;
    if (!s) {
        s = {
            elMap: {
                htmlAttrs: t.documentElement,
                bodyAttrs: t.body
            }
        };
        for (const h of ["body", "head"]) {
            const f = (u = t == null ? void 0 : t[h]) == null ? void 0 : u.children;
            for (const p of [...f].filter(g => ko.includes(g.tagName.toLowerCase())))
                s.elMap[p.getAttribute("data-hid") || bh(await Lx(p))] = p
        }
    }
    s.pendingSideEffects = {
        ...s.sideEffects || {}
    },
    s.sideEffects = {};
    function o(h, f, p) {
        const g = `${h}:${f}`;
        s.sideEffects[g] = p,
        delete s.pendingSideEffects[g]
    }
    function a({id: h, $el: f, tag: p}) {
        const g = p.tag.endsWith("Attrs");
        s.elMap[h] = f,
        g || (["textContent", "innerHTML"].forEach(x => {
            p[x] && p[x] !== f[x] && (f[x] = p[x])
        }
        ),
        o(h, "el", () => {
            s.elMap[h].remove(),
            delete s.elMap[h]
        }
        )),
        Object.entries(p.props).forEach( ([x,m]) => {
            const d = `attr:${x}`;
            if (x === "class")
                for (const v of (m || "").split(" ").filter(Boolean))
                    g && o(h, `${d}:${v}`, () => f.classList.remove(v)),
                    !f.classList.contains(v) && f.classList.add(v);
            else
                f.getAttribute(x) !== m && f.setAttribute(x, m === !0 ? "" : String(m)),
                g && o(h, d, () => f.removeAttribute(x))
        }
        )
    }
    const l = []
      , c = {
        bodyClose: void 0,
        bodyOpen: void 0,
        head: void 0
    };
    for (const h of r) {
        const {tag: f, shouldRender: p, id: g} = h;
        if (p) {
            if (f.tag === "title") {
                t.title = f.textContent;
                continue
            }
            h.$el = h.$el || s.elMap[g],
            h.$el ? a(h) : ko.includes(f.tag) && l.push(h)
        }
    }
    for (const h of l) {
        const f = h.tag.tagPosition || "head";
        h.$el = t.createElement(h.tag.tag),
        a(h),
        c[f] = c[f] || t.createDocumentFragment(),
        c[f].appendChild(h.$el)
    }
    for (const h of r)
        await n.hooks.callHook("dom:renderTag", h, t, o);
    c.head && t.head.appendChild(c.head),
    c.bodyOpen && t.body.insertBefore(c.bodyOpen, t.body.firstChild),
    c.bodyClose && t.body.appendChild(c.bodyClose),
    Object.values(s.pendingSideEffects).forEach(h => h()),
    n._dom = s,
    n.dirty = !1,
    await n.hooks.callHook("dom:rendered", {
        renders: r
    })
}
async function Dx(n, e={}) {
    const t = e.delayFn || (i => setTimeout(i, 10));
    return n._domUpdatePromise = n._domUpdatePromise || new Promise(i => t(async () => {
        await om(n, e),
        delete n._domUpdatePromise,
        i()
    }
    ))
}
function Ix(n) {
    return e => {
        var i, r;
        const t = ((r = (i = e.resolvedOptions.document) == null ? void 0 : i.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : r.innerHTML) || !1;
        return t && e.push(JSON.parse(t)),
        {
            mode: "client",
            hooks: {
                "entries:updated": function(s) {
                    Dx(s, n)
                }
            }
        }
    }
}
const Ux = ["templateParams", "htmlAttrs", "bodyAttrs"]
  , Nx = {
    hooks: {
        "tag:normalise": function({tag: n}) {
            ["hid", "vmid", "key"].forEach(i => {
                n.props[i] && (n.key = n.props[i],
                delete n.props[i])
            }
            );
            const t = rm(n) || (n.key ? `${n.tag}:${n.key}` : !1);
            t && (n._d = t)
        },
        "tags:resolve": function(n) {
            const e = {};
            n.tags.forEach(i => {
                const r = (i.key ? `${i.tag}:${i.key}` : i._d) || i._p
                  , s = e[r];
                if (s) {
                    let a = i == null ? void 0 : i.tagDuplicateStrategy;
                    if (!a && Ux.includes(i.tag) && (a = "merge"),
                    a === "merge") {
                        const l = s.props;
                        ["class", "style"].forEach(c => {
                            i.props[c] && l[c] && (c === "style" && !l[c].endsWith(";") && (l[c] += ";"),
                            i.props[c] = `${l[c]} ${i.props[c]}`)
                        }
                        ),
                        e[r].props = {
                            ...l,
                            ...i.props
                        };
                        return
                    } else if (i._e === s._e) {
                        s._duped = s._duped || [],
                        i._d = `${s._d}:${s._duped.length + 1}`,
                        s._duped.push(i);
                        return
                    } else if (ra(i) > ra(s))
                        return
                }
                const o = Object.keys(i.props).length + (i.innerHTML ? 1 : 0) + (i.textContent ? 1 : 0);
                if (ko.includes(i.tag) && o === 0) {
                    delete e[r];
                    return
                }
                e[r] = i
            }
            );
            const t = [];
            Object.values(e).forEach(i => {
                const r = i._duped;
                delete i._duped,
                t.push(i),
                r && t.push(...r)
            }
            ),
            n.tags = t,
            n.tags = n.tags.filter(i => !(i.tag === "meta" && (i.props.name || i.props.property) && !i.props.content))
        }
    }
}
  , Fx = {
    mode: "server",
    hooks: {
        "tags:resolve": function(n) {
            const e = {};
            n.tags.filter(t => ["titleTemplate", "templateParams", "title"].includes(t.tag) && t._m === "server").forEach(t => {
                e[t.tag] = t.tag.startsWith("title") ? t.textContent : t.props
            }
            ),
            Object.keys(e).length && n.tags.push({
                tag: "script",
                innerHTML: JSON.stringify(e),
                props: {
                    id: "unhead:payload",
                    type: "application/json"
                }
            })
        }
    }
}
  , Rh = ["script", "link", "bodyAttrs"];
function Ch(n) {
    const e = {}
      , t = {};
    return Object.entries(n.props).forEach( ([i,r]) => {
        i.startsWith("on") && typeof r == "function" ? t[i] = r : e[i] = r
    }
    ),
    {
        props: e,
        eventHandlers: t
    }
}
const Ox = {
    hooks: {
        "ssr:render": function(n) {
            n.tags = n.tags.map(e => (!Rh.includes(e.tag) || !Object.entries(e.props).find( ([t,i]) => t.startsWith("on") && typeof i == "function") || (e.props = Ch(e).props),
            e))
        },
        "tags:resolve": function(n) {
            n.tags = n.tags.map(e => {
                if (!Rh.includes(e.tag))
                    return e;
                const {props: t, eventHandlers: i} = Ch(e);
                return Object.keys(i).length && (e.props = t,
                e._eventHandlers = i),
                e
            }
            )
        },
        "dom:renderTag": function(n, e, t) {
            if (!n.tag._eventHandlers)
                return;
            const i = n.tag.tag === "bodyAttrs" ? e.defaultView : n.$el;
            Object.entries(n.tag._eventHandlers).forEach( ([r,s]) => {
                const o = `${n.tag._d || n.tag._p}:${r}`
                  , a = r.slice(2).toLowerCase()
                  , l = `data-h-${a}`;
                if (t(n.id, o, () => {}
                ),
                n.$el.hasAttribute(l))
                    return;
                const c = s;
                n.$el.setAttribute(l, ""),
                i.addEventListener(a, c),
                n.entry && t(n.id, o, () => {
                    i.removeEventListener(a, c),
                    n.$el.removeAttribute(l)
                }
                )
            }
            )
        }
    }
}
  , zx = ["link", "style", "script", "noscript"]
  , Bx = {
    hooks: {
        "tag:normalise": ({tag: n}) => {
            n.key && zx.includes(n.tag) && (n.props["data-hid"] = n._h = im(n.key))
        }
    }
}
  , Hx = {
    hooks: {
        "tags:resolve": n => {
            const e = t => {
                var i;
                return (i = n.tags.find(r => r._d === t)) == null ? void 0 : i._p
            }
            ;
            for (const {prefix: t, offset: i} of Px)
                for (const r of n.tags.filter(s => typeof s.tagPriority == "string" && s.tagPriority.startsWith(t))) {
                    const s = e(r.tagPriority.replace(t, ""));
                    typeof s < "u" && (r._p = s + i)
                }
            n.tags.sort( (t, i) => t._p - i._p).sort( (t, i) => ra(t) - ra(i))
        }
    }
}
  , kx = {
    hooks: {
        "tags:resolve": n => {
            var o;
            const {tags: e} = n
              , t = (o = e.find(a => a.tag === "title")) == null ? void 0 : o.textContent
              , i = e.findIndex(a => a.tag === "templateParams")
              , r = i !== -1 ? e[i].props : {}
              , s = r.separator || "|";
            delete r.separator,
            r.pageTitle = Li(r.pageTitle || t || "", r, s);
            for (const a of e)
                a.processTemplateParams !== !1 && (["titleTemplate", "title"].includes(a.tag) && typeof a.textContent == "string" ? a.textContent = Li(a.textContent, r, s) : a.tag === "meta" && typeof a.props.content == "string" ? a.props.content = Li(a.props.content, r, s) : a.tag === "link" && typeof a.props.href == "string" ? a.props.href = Li(a.props.href, r, s) : a.processTemplateParams === !0 && (a.innerHTML ? a.innerHTML = Li(a.innerHTML, r, s) : a.textContent && (a.textContent = Li(a.textContent, r, s))));
            n.tags = e.filter(a => a.tag !== "templateParams")
        }
    }
}
  , Gx = {
    hooks: {
        "tags:resolve": n => {
            const {tags: e} = n;
            let t = e.findIndex(r => r.tag === "titleTemplate");
            const i = e.findIndex(r => r.tag === "title");
            if (i !== -1 && t !== -1) {
                const r = Th(e[t].textContent, e[i].textContent);
                r !== null ? e[i].textContent = r || e[i].textContent : delete e[i]
            } else if (t !== -1) {
                const r = Th(e[t].textContent);
                r !== null && (e[t].textContent = r,
                e[t].tag = "title",
                t = -1)
            }
            t !== -1 && delete e[t],
            n.tags = e.filter(Boolean)
        }
    }
};
let am;
function Vx(n={}) {
    const e = Wx(n);
    return e.use(Ix()),
    am = e
}
function Ph(n, e) {
    return !n || n === "server" && e || n === "client" && !e
}
function Wx(n={}) {
    const e = em();
    e.addHooks(n.hooks || {}),
    n.document = n.document || (Tx ? document : void 0);
    const t = !n.document;
    n.plugins = [Nx, Fx, Ox, Bx, Hx, kx, Gx, ...(n == null ? void 0 : n.plugins) || []];
    const i = () => {
        o.dirty = !0,
        e.callHook("entries:updated", o)
    }
    ;
    let r = 0
      , s = [];
    const o = {
        dirty: !1,
        resolvedOptions: n,
        hooks: e,
        headEntries() {
            return s
        },
        use(a) {
            const l = typeof a == "function" ? a(o) : a;
            Ph(l.mode, t) && e.addHooks(l.hooks || {})
        },
        push(a, l) {
            l == null || delete l.head;
            const c = {
                _i: r++,
                input: a,
                ...l
            };
            return Ph(c.mode, t) && (s.push(c),
            i()),
            {
                dispose() {
                    s = s.filter(u => u._i !== c._i),
                    e.callHook("entries:updated", o),
                    i()
                },
                patch(u) {
                    s = s.map(h => (h._i === c._i && (h.input = c.input = u),
                    h)),
                    i()
                }
            }
        },
        async resolveTags() {
            const a = {
                tags: [],
                entries: [...s]
            };
            await e.callHook("entries:resolve", a);
            for (const l of a.entries) {
                const c = l.resolvedInput || l.input;
                if (l.resolvedInput = await (l.transform ? l.transform(c) : c),
                l.resolvedInput)
                    for (const u of await Cx(l)) {
                        const h = {
                            tag: u,
                            entry: l,
                            resolvedOptions: o.resolvedOptions
                        };
                        await e.callHook("tag:normalise", h),
                        a.tags.push(h.tag)
                    }
            }
            return await e.callHook("tags:beforeResolve", a),
            await e.callHook("tags:resolve", a),
            a.tags
        },
        ssr: t
    };
    return n.plugins.forEach(a => o.use(a)),
    o.hooks.callHook("init", o),
    o
}
function Xx() {
    return am
}
const $x = kp.startsWith("3");
function jx(n) {
    return typeof n == "function" ? n() : st(n)
}
function cc(n, e="") {
    if (n instanceof Promise)
        return n;
    const t = jx(n);
    return !n || !t ? t : Array.isArray(t) ? t.map(i => cc(i, e)) : typeof t == "object" ? Object.fromEntries(Object.entries(t).map( ([i,r]) => i === "titleTemplate" || i.startsWith("on") ? [i, st(r)] : [i, cc(r, i)])) : t
}
const Kx = {
    hooks: {
        "entries:resolve": function(n) {
            for (const e of n.entries)
                e.resolvedInput = cc(e.input)
        }
    }
}
  , lm = "usehead";
function qx(n) {
    return {
        install(t) {
            $x && (t.config.globalProperties.$unhead = n,
            t.config.globalProperties.$head = n,
            t.provide(lm, n))
        }
    }.install
}
function Yx(n={}) {
    n.domDelayFn = n.domDelayFn || (t => jr( () => setTimeout( () => t(), 0)));
    const e = Vx(n);
    return e.use(Kx),
    e.install = qx(e),
    e
}
const uc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , hc = "__unhead_injection_handler__";
function Jx(n) {
    uc[hc] = n
}
function GR() {
    if (hc in uc)
        return uc[hc]();
    const n = Jt(lm);
    return n || Xx()
}
function nl(n) {
    return n !== null && typeof n == "object"
}
function fc(n, e, t=".", i) {
    if (!nl(e))
        return fc(n, {}, t, i);
    const r = Object.assign({}, e);
    for (const s in n) {
        if (s === "__proto__" || s === "constructor")
            continue;
        const o = n[s];
        o != null && (i && i(r, s, o, t) || (Array.isArray(o) && Array.isArray(r[s]) ? r[s] = [...o, ...r[s]] : nl(o) && nl(r[s]) ? r[s] = fc(o, r[s], (t ? `${t}.` : "") + s.toString(), i) : r[s] = o))
    }
    return r
}
function Zx(n) {
    return (...e) => e.reduce( (t, i) => fc(t, i, "", n), {})
}
const Qx = Zx();
function ey(n, e) {
    try {
        return e in n
    } catch {
        return !1
    }
}
var ty = Object.defineProperty
  , ny = (n, e, t) => e in n ? ty(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Di = (n, e, t) => (ny(n, typeof e != "symbol" ? e + "" : e, t),
t);
class dc extends Error {
    constructor(e, t={}) {
        super(e, t),
        Di(this, "statusCode", 500),
        Di(this, "fatal", !1),
        Di(this, "unhandled", !1),
        Di(this, "statusMessage"),
        Di(this, "data"),
        Di(this, "cause"),
        t.cause && !this.cause && (this.cause = t.cause)
    }
    toJSON() {
        const e = {
            message: this.message,
            statusCode: mc(this.statusCode, 500)
        };
        return this.statusMessage && (e.statusMessage = cm(this.statusMessage)),
        this.data !== void 0 && (e.data = this.data),
        e
    }
}
Di(dc, "__h3_error__", !0);
function pc(n) {
    if (typeof n == "string")
        return new dc(n);
    if (iy(n))
        return n;
    const e = new dc(n.message ?? n.statusMessage ?? "",{
        cause: n.cause || n
    });
    if (ey(n, "stack"))
        try {
            Object.defineProperty(e, "stack", {
                get() {
                    return n.stack
                }
            })
        } catch {
            try {
                e.stack = n.stack
            } catch {}
        }
    if (n.data && (e.data = n.data),
    n.statusCode ? e.statusCode = mc(n.statusCode, e.statusCode) : n.status && (e.statusCode = mc(n.status, e.statusCode)),
    n.statusMessage ? e.statusMessage = n.statusMessage : n.statusText && (e.statusMessage = n.statusText),
    e.statusMessage) {
        const t = e.statusMessage;
        cm(e.statusMessage) !== t && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return n.fatal !== void 0 && (e.fatal = n.fatal),
    n.unhandled !== void 0 && (e.unhandled = n.unhandled),
    e
}
function iy(n) {
    var e;
    return ((e = n == null ? void 0 : n.constructor) == null ? void 0 : e.__h3_error__) === !0
}
const ry = /[^\u0009\u0020-\u007E]/g;
function cm(n="") {
    return n.replace(ry, "")
}
function mc(n, e=200) {
    return !n || (typeof n == "string" && (n = Number.parseInt(n, 10)),
    n < 100 || n > 999) ? e : n
}
const sy = Symbol("layout-meta")
  , Ra = Symbol("route")
  , Ki = () => {
    var n;
    return (n = ft()) == null ? void 0 : n.$router
}
  , um = () => wp() ? Jt(Ra, ft()._route) : ft()._route;
/*! @__NO_SIDE_EFFECTS__ */
const oy = () => {
    try {
        if (ft()._processingMiddleware)
            return !0
    } catch {
        return !0
    }
    return !1
}
  , VR = (n, e) => {
    n || (n = "/");
    const t = typeof n == "string" ? n : qp(n.path || "/", n.query || {}) + (n.hash || "");
    if (e != null && e.open) {
        {
            const {target: a="_blank", windowFeatures: l={}} = e.open
              , c = Object.entries(l).filter( ([u,h]) => h !== void 0).map( ([u,h]) => `${u.toLowerCase()}=${h}`).join(", ");
            open(t, a, c)
        }
        return Promise.resolve()
    }
    const i = (e == null ? void 0 : e.external) || Ks(t, {
        acceptRelative: !0
    });
    if (i) {
        if (!(e != null && e.external))
            throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
        const a = wa(t).protocol;
        if (a && E0(a))
            throw new Error(`Cannot navigate to a URL with '${a}' protocol.`)
    }
    const r = oy();
    if (!i && r)
        return n;
    const s = Ki()
      , o = ft();
    return i ? (e != null && e.replace ? location.replace(t) : location.href = t,
    r ? o.isHydrating ? new Promise( () => {}
    ) : !1 : Promise.resolve()) : e != null && e.replace ? s.replace(n) : s.push(n)
}
  , Ca = () => v_(ft().payload, "error")
  , xr = n => {
    const e = hu(n);
    try {
        const t = ft()
          , i = Ca();
        t.hooks.callHook("app:error", e),
        i.value = i.value || e
    } catch {
        throw e
    }
    return e
}
  , ay = async (n={}) => {
    const e = ft()
      , t = Ca();
    e.callHook("app:error:cleared", n),
    n.redirect && await Ki().replace(n.redirect),
    t.value = null
}
  , ly = n => !!(n && typeof n == "object" && "__nuxt_error"in n)
  , hu = n => {
    const e = pc(n);
    return e.__nuxt_error = !0,
    e
}
  , Lh = globalThis.requestIdleCallback || (n => {
    const e = Date.now()
      , t = {
        didTimeout: !1,
        timeRemaining: () => Math.max(0, 50 - (Date.now() - e))
    };
    return setTimeout( () => {
        n(t)
    }
    , 1)
}
)
  , WR = globalThis.cancelIdleCallback || (n => {
    clearTimeout(n)
}
)
  , cy = n => {
    const e = ft();
    e.isHydrating ? e.hooks.hookOnce("app:suspense:resolve", () => {
        Lh(n)
    }
    ) : Lh(n)
}
;
function uy(n={}) {
    const e = n.path || window.location.pathname;
    let t = {};
    try {
        t = Qo(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (n.force || (t == null ? void 0 : t.path) !== e || (t == null ? void 0 : t.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: e,
                expires: Date.now() + (n.ttl ?? 1e4)
            }))
        } catch {}
        if (n.persistState)
            try {
                sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                    state: ft().payload.state
                }))
            } catch {}
        window.location.pathname !== e ? window.location.href = e : window.location.reload()
    }
}
const gc = !1
  , hy = !1
  , fy = "#__nuxt";
function Dh(n, e={}) {
    const t = dy(n, e)
      , i = ft()
      , r = i._payloadCache = i._payloadCache || {};
    return t in r || (r[t] = py().then(s => s ? hm(t).then(o => o || (delete r[t],
    null)) : (r[t] = null,
    null))),
    r[t]
}
const Ih = "json";
function dy(n, e={}) {
    const t = new URL(n,"http://localhost");
    if (t.search)
        throw new Error("Payload URL cannot contain search params: " + n);
    if (t.host !== "localhost" || Ks(t.pathname, {
        acceptRelative: !0
    }))
        throw new Error("Payload URL must not include hostname: " + n);
    const i = e.hash || (e.fresh ? Date.now() : "");
    return qs(Aa().app.baseURL, t.pathname, i ? `_payload.${i}.${Ih}` : `_payload.${Ih}`)
}
async function hm(n) {
    const e = fetch(n).then(t => t.text().then(fm));
    try {
        return await e
    } catch (t) {
        console.warn("[nuxt] Cannot load payload ", n, t)
    }
    return null
}
async function py(n=um().path) {
    return !!ft().payload.prerenderedAt
}
let co = null;
async function my() {
    if (co)
        return co;
    const n = document.getElementById("__NUXT_DATA__");
    if (!n)
        return {};
    const e = fm(n.textContent || "")
      , t = n.dataset.src ? await hm(n.dataset.src) : void 0;
    return co = {
        ...e,
        ...t,
        ...window.__NUXT__
    },
    co
}
function fm(n) {
    return xx(n, ft()._payloadRevivers)
}
function gy(n, e) {
    ft()._payloadRevivers[n] = e
}
const Uh = {
    NuxtError: n => hu(n),
    EmptyShallowRef: n => Ps(n === "_" ? void 0 : n === "0n" ? BigInt(0) : Qo(n)),
    EmptyRef: n => Rn(n === "_" ? void 0 : n === "0n" ? BigInt(0) : Qo(n)),
    ShallowRef: n => Ps(n),
    ShallowReactive: n => Xs(n),
    Ref: n => Rn(n),
    Reactive: n => yi(n)
}
  , _y = ji({
    name: "nuxt:revive-payload:client",
    order: -30,
    async setup(n) {
        let e, t;
        for (const i in Uh)
            gy(i, Uh[i]);
        Object.assign(n.payload, ([e,t] = ia( () => n.runWithContext(my)),
        e = await e,
        t(),
        e)),
        window.__NUXT__ = n.payload
    }
})
  , vy = []
  , xy = ji({
    name: "nuxt:head",
    enforce: "pre",
    setup(n) {
        const e = Yx({
            plugins: vy
        });
        Jx( () => ft().vueApp._context.provides.usehead),
        n.vueApp.use(e);
        {
            let t = !0;
            const i = async () => {
                t = !1,
                await om(e)
            }
            ;
            e.hooks.hook("dom:beforeRender", r => {
                r.shouldRender = !t
            }
            ),
            n.hooks.hook("page:start", () => {
                t = !0
            }
            ),
            n.hooks.hook("page:finish", () => {
                n.isHydrating || i()
            }
            ),
            n.hooks.hook("app:error", i),
            n.hooks.hook("app:suspense:resolve", i)
        }
    }
});
/*!
  * vue-router v4.2.5
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
const mr = typeof window < "u";
function yy(n) {
    return n.__esModule || n[Symbol.toStringTag] === "Module"
}
const Qe = Object.assign;
function il(n, e) {
    const t = {};
    for (const i in e) {
        const r = e[i];
        t[i] = Mn(r) ? r.map(n) : n(r)
    }
    return t
}
const ys = () => {}
  , Mn = Array.isArray
  , My = /\/$/
  , Sy = n => n.replace(My, "");
function rl(n, e, t="/") {
    let i, r = {}, s = "", o = "";
    const a = e.indexOf("#");
    let l = e.indexOf("?");
    return a < l && a >= 0 && (l = -1),
    l > -1 && (i = e.slice(0, l),
    s = e.slice(l + 1, a > -1 ? a : e.length),
    r = n(s)),
    a > -1 && (i = i || e.slice(0, a),
    o = e.slice(a, e.length)),
    i = wy(i ?? e, t),
    {
        fullPath: i + (s && "?") + s + o,
        path: i,
        query: r,
        hash: o
    }
}
function Ey(n, e) {
    const t = e.query ? n(e.query) : "";
    return e.path + (t && "?") + t + (e.hash || "")
}
function Nh(n, e) {
    return !e || !n.toLowerCase().startsWith(e.toLowerCase()) ? n : n.slice(e.length) || "/"
}
function by(n, e, t) {
    const i = e.matched.length - 1
      , r = t.matched.length - 1;
    return i > -1 && i === r && Fr(e.matched[i], t.matched[r]) && dm(e.params, t.params) && n(e.query) === n(t.query) && e.hash === t.hash
}
function Fr(n, e) {
    return (n.aliasOf || n) === (e.aliasOf || e)
}
function dm(n, e) {
    if (Object.keys(n).length !== Object.keys(e).length)
        return !1;
    for (const t in n)
        if (!Ty(n[t], e[t]))
            return !1;
    return !0
}
function Ty(n, e) {
    return Mn(n) ? Fh(n, e) : Mn(e) ? Fh(e, n) : n === e
}
function Fh(n, e) {
    return Mn(e) ? n.length === e.length && n.every( (t, i) => t === e[i]) : n.length === 1 && n[0] === e
}
function wy(n, e) {
    if (n.startsWith("/"))
        return n;
    if (!n)
        return e;
    const t = e.split("/")
      , i = n.split("/")
      , r = i[i.length - 1];
    (r === ".." || r === ".") && i.push("");
    let s = t.length - 1, o, a;
    for (o = 0; o < i.length; o++)
        if (a = i[o],
        a !== ".")
            if (a === "..")
                s > 1 && s--;
            else
                break;
    return t.slice(0, s).join("/") + "/" + i.slice(o - (o === i.length ? 1 : 0)).join("/")
}
var Fs;
(function(n) {
    n.pop = "pop",
    n.push = "push"
}
)(Fs || (Fs = {}));
var Ms;
(function(n) {
    n.back = "back",
    n.forward = "forward",
    n.unknown = ""
}
)(Ms || (Ms = {}));
function Ay(n) {
    if (!n)
        if (mr) {
            const e = document.querySelector("base");
            n = e && e.getAttribute("href") || "/",
            n = n.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            n = "/";
    return n[0] !== "/" && n[0] !== "#" && (n = "/" + n),
    Sy(n)
}
const Ry = /^[^#]+#/;
function Cy(n, e) {
    return n.replace(Ry, "#") + e
}
function Py(n, e) {
    const t = document.documentElement.getBoundingClientRect()
      , i = n.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: i.left - t.left - (e.left || 0),
        top: i.top - t.top - (e.top || 0)
    }
}
const Pa = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});
function Ly(n) {
    let e;
    if ("el"in n) {
        const t = n.el
          , i = typeof t == "string" && t.startsWith("#")
          , r = typeof t == "string" ? i ? document.getElementById(t.slice(1)) : document.querySelector(t) : t;
        if (!r)
            return;
        e = Py(r, n)
    } else
        e = n;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}
function Oh(n, e) {
    return (history.state ? history.state.position - e : -1) + n
}
const _c = new Map;
function Dy(n, e) {
    _c.set(n, e)
}
function Iy(n) {
    const e = _c.get(n);
    return _c.delete(n),
    e
}
let Uy = () => location.protocol + "//" + location.host;
function pm(n, e) {
    const {pathname: t, search: i, hash: r} = e
      , s = n.indexOf("#");
    if (s > -1) {
        let a = r.includes(n.slice(s)) ? n.slice(s).length : 1
          , l = r.slice(a);
        return l[0] !== "/" && (l = "/" + l),
        Nh(l, "")
    }
    return Nh(t, n) + i + r
}
function Ny(n, e, t, i) {
    let r = []
      , s = []
      , o = null;
    const a = ({state: f}) => {
        const p = pm(n, location)
          , g = t.value
          , x = e.value;
        let m = 0;
        if (f) {
            if (t.value = p,
            e.value = f,
            o && o === g) {
                o = null;
                return
            }
            m = x ? f.position - x.position : 0
        } else
            i(p);
        r.forEach(d => {
            d(t.value, g, {
                delta: m,
                type: Fs.pop,
                direction: m ? m > 0 ? Ms.forward : Ms.back : Ms.unknown
            })
        }
        )
    }
    ;
    function l() {
        o = t.value
    }
    function c(f) {
        r.push(f);
        const p = () => {
            const g = r.indexOf(f);
            g > -1 && r.splice(g, 1)
        }
        ;
        return s.push(p),
        p
    }
    function u() {
        const {history: f} = window;
        f.state && f.replaceState(Qe({}, f.state, {
            scroll: Pa()
        }), "")
    }
    function h() {
        for (const f of s)
            f();
        s = [],
        window.removeEventListener("popstate", a),
        window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a),
    window.addEventListener("beforeunload", u, {
        passive: !0
    }),
    {
        pauseListeners: l,
        listen: c,
        destroy: h
    }
}
function zh(n, e, t, i=!1, r=!1) {
    return {
        back: n,
        current: e,
        forward: t,
        replaced: i,
        position: window.history.length,
        scroll: r ? Pa() : null
    }
}
function Fy(n) {
    const {history: e, location: t} = window
      , i = {
        value: pm(n, t)
    }
      , r = {
        value: e.state
    };
    r.value || s(i.value, {
        back: null,
        current: i.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function s(l, c, u) {
        const h = n.indexOf("#")
          , f = h > -1 ? (t.host && document.querySelector("base") ? n : n.slice(h)) + l : Uy() + n + l;
        try {
            e[u ? "replaceState" : "pushState"](c, "", f),
            r.value = c
        } catch (p) {
            console.error(p),
            t[u ? "replace" : "assign"](f)
        }
    }
    function o(l, c) {
        const u = Qe({}, e.state, zh(r.value.back, l, r.value.forward, !0), c, {
            position: r.value.position
        });
        s(l, u, !0),
        i.value = l
    }
    function a(l, c) {
        const u = Qe({}, r.value, e.state, {
            forward: l,
            scroll: Pa()
        });
        s(u.current, u, !0);
        const h = Qe({}, zh(i.value, l, null), {
            position: u.position + 1
        }, c);
        s(l, h, !1),
        i.value = l
    }
    return {
        location: i,
        state: r,
        push: a,
        replace: o
    }
}
function mm(n) {
    n = Ay(n);
    const e = Fy(n)
      , t = Ny(n, e.state, e.location, e.replace);
    function i(s, o=!0) {
        o || t.pauseListeners(),
        history.go(s)
    }
    const r = Qe({
        location: "",
        base: n,
        go: i,
        createHref: Cy.bind(null, n)
    }, e, t);
    return Object.defineProperty(r, "location", {
        enumerable: !0,
        get: () => e.location.value
    }),
    Object.defineProperty(r, "state", {
        enumerable: !0,
        get: () => e.state.value
    }),
    r
}
function Oy(n) {
    return n = location.host ? n || location.pathname + location.search : "",
    n.includes("#") || (n += "#"),
    mm(n)
}
function zy(n) {
    return typeof n == "string" || n && typeof n == "object"
}
function gm(n) {
    return typeof n == "string" || typeof n == "symbol"
}
const En = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
}
  , _m = Symbol("");
var Bh;
(function(n) {
    n[n.aborted = 4] = "aborted",
    n[n.cancelled = 8] = "cancelled",
    n[n.duplicated = 16] = "duplicated"
}
)(Bh || (Bh = {}));
function Or(n, e) {
    return Qe(new Error, {
        type: n,
        [_m]: !0
    }, e)
}
function Un(n, e) {
    return n instanceof Error && _m in n && (e == null || !!(n.type & e))
}
const Hh = "[^/]+?"
  , By = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , Hy = /[.+*?^${}()[\]/\\]/g;
function ky(n, e) {
    const t = Qe({}, By, e)
      , i = [];
    let r = t.start ? "^" : "";
    const s = [];
    for (const c of n) {
        const u = c.length ? [] : [90];
        t.strict && !c.length && (r += "/");
        for (let h = 0; h < c.length; h++) {
            const f = c[h];
            let p = 40 + (t.sensitive ? .25 : 0);
            if (f.type === 0)
                h || (r += "/"),
                r += f.value.replace(Hy, "\\$&"),
                p += 40;
            else if (f.type === 1) {
                const {value: g, repeatable: x, optional: m, regexp: d} = f;
                s.push({
                    name: g,
                    repeatable: x,
                    optional: m
                });
                const v = d || Hh;
                if (v !== Hh) {
                    p += 10;
                    try {
                        new RegExp(`(${v})`)
                    } catch (M) {
                        throw new Error(`Invalid custom RegExp for param "${g}" (${v}): ` + M.message)
                    }
                }
                let _ = x ? `((?:${v})(?:/(?:${v}))*)` : `(${v})`;
                h || (_ = m && c.length < 2 ? `(?:/${_})` : "/" + _),
                m && (_ += "?"),
                r += _,
                p += 20,
                m && (p += -8),
                x && (p += -20),
                v === ".*" && (p += -50)
            }
            u.push(p)
        }
        i.push(u)
    }
    if (t.strict && t.end) {
        const c = i.length - 1;
        i[c][i[c].length - 1] += .7000000000000001
    }
    t.strict || (r += "/?"),
    t.end ? r += "$" : t.strict && (r += "(?:/|$)");
    const o = new RegExp(r,t.sensitive ? "" : "i");
    function a(c) {
        const u = c.match(o)
          , h = {};
        if (!u)
            return null;
        for (let f = 1; f < u.length; f++) {
            const p = u[f] || ""
              , g = s[f - 1];
            h[g.name] = p && g.repeatable ? p.split("/") : p
        }
        return h
    }
    function l(c) {
        let u = ""
          , h = !1;
        for (const f of n) {
            (!h || !u.endsWith("/")) && (u += "/"),
            h = !1;
            for (const p of f)
                if (p.type === 0)
                    u += p.value;
                else if (p.type === 1) {
                    const {value: g, repeatable: x, optional: m} = p
                      , d = g in c ? c[g] : "";
                    if (Mn(d) && !x)
                        throw new Error(`Provided param "${g}" is an array but it is not repeatable (* or + modifiers)`);
                    const v = Mn(d) ? d.join("/") : d;
                    if (!v)
                        if (m)
                            f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : h = !0);
                        else
                            throw new Error(`Missing required param "${g}"`);
                    u += v
                }
        }
        return u || "/"
    }
    return {
        re: o,
        score: i,
        keys: s,
        parse: a,
        stringify: l
    }
}
function Gy(n, e) {
    let t = 0;
    for (; t < n.length && t < e.length; ) {
        const i = e[t] - n[t];
        if (i)
            return i;
        t++
    }
    return n.length < e.length ? n.length === 1 && n[0] === 40 + 40 ? -1 : 1 : n.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}
function Vy(n, e) {
    let t = 0;
    const i = n.score
      , r = e.score;
    for (; t < i.length && t < r.length; ) {
        const s = Gy(i[t], r[t]);
        if (s)
            return s;
        t++
    }
    if (Math.abs(r.length - i.length) === 1) {
        if (kh(i))
            return 1;
        if (kh(r))
            return -1
    }
    return r.length - i.length
}
function kh(n) {
    const e = n[n.length - 1];
    return n.length > 0 && e[e.length - 1] < 0
}
const Wy = {
    type: 0,
    value: ""
}
  , Xy = /[a-zA-Z0-9_]/;
function $y(n) {
    if (!n)
        return [[]];
    if (n === "/")
        return [[Wy]];
    if (!n.startsWith("/"))
        throw new Error(`Invalid path "${n}"`);
    function e(p) {
        throw new Error(`ERR (${t})/"${c}": ${p}`)
    }
    let t = 0
      , i = t;
    const r = [];
    let s;
    function o() {
        s && r.push(s),
        s = []
    }
    let a = 0, l, c = "", u = "";
    function h() {
        c && (t === 0 ? s.push({
            type: 0,
            value: c
        }) : t === 1 || t === 2 || t === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
        s.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : e("Invalid state to consume buffer"),
        c = "")
    }
    function f() {
        c += l
    }
    for (; a < n.length; ) {
        if (l = n[a++],
        l === "\\" && t !== 2) {
            i = t,
            t = 4;
            continue
        }
        switch (t) {
        case 0:
            l === "/" ? (c && h(),
            o()) : l === ":" ? (h(),
            t = 1) : f();
            break;
        case 4:
            f(),
            t = i;
            break;
        case 1:
            l === "(" ? t = 2 : Xy.test(l) ? f() : (h(),
            t = 0,
            l !== "*" && l !== "?" && l !== "+" && a--);
            break;
        case 2:
            l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : t = 3 : u += l;
            break;
        case 3:
            h(),
            t = 0,
            l !== "*" && l !== "?" && l !== "+" && a--,
            u = "";
            break;
        default:
            e("Unknown state");
            break
        }
    }
    return t === 2 && e(`Unfinished custom RegExp for param "${c}"`),
    h(),
    o(),
    r
}
function jy(n, e, t) {
    const i = ky($y(n.path), t)
      , r = Qe(i, {
        record: n,
        parent: e,
        children: [],
        alias: []
    });
    return e && !r.record.aliasOf == !e.record.aliasOf && e.children.push(r),
    r
}
function Ky(n, e) {
    const t = []
      , i = new Map;
    e = Wh({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);
    function r(u) {
        return i.get(u)
    }
    function s(u, h, f) {
        const p = !f
          , g = qy(u);
        g.aliasOf = f && f.record;
        const x = Wh(e, u)
          , m = [g];
        if ("alias"in u) {
            const _ = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const M of _)
                m.push(Qe({}, g, {
                    components: f ? f.record.components : g.components,
                    path: M,
                    aliasOf: f ? f.record : g
                }))
        }
        let d, v;
        for (const _ of m) {
            const {path: M} = _;
            if (h && M[0] !== "/") {
                const b = h.record.path
                  , A = b[b.length - 1] === "/" ? "" : "/";
                _.path = h.record.path + (M && A + M)
            }
            if (d = jy(_, h, x),
            f ? f.alias.push(d) : (v = v || d,
            v !== d && v.alias.push(d),
            p && u.name && !Vh(d) && o(u.name)),
            g.children) {
                const b = g.children;
                for (let A = 0; A < b.length; A++)
                    s(b[A], d, f && f.children[A])
            }
            f = f || d,
            (d.record.components && Object.keys(d.record.components).length || d.record.name || d.record.redirect) && l(d)
        }
        return v ? () => {
            o(v)
        }
        : ys
    }
    function o(u) {
        if (gm(u)) {
            const h = i.get(u);
            h && (i.delete(u),
            t.splice(t.indexOf(h), 1),
            h.children.forEach(o),
            h.alias.forEach(o))
        } else {
            const h = t.indexOf(u);
            h > -1 && (t.splice(h, 1),
            u.record.name && i.delete(u.record.name),
            u.children.forEach(o),
            u.alias.forEach(o))
        }
    }
    function a() {
        return t
    }
    function l(u) {
        let h = 0;
        for (; h < t.length && Vy(u, t[h]) >= 0 && (u.record.path !== t[h].record.path || !vm(u, t[h])); )
            h++;
        t.splice(h, 0, u),
        u.record.name && !Vh(u) && i.set(u.record.name, u)
    }
    function c(u, h) {
        let f, p = {}, g, x;
        if ("name"in u && u.name) {
            if (f = i.get(u.name),
            !f)
                throw Or(1, {
                    location: u
                });
            x = f.record.name,
            p = Qe(Gh(h.params, f.keys.filter(v => !v.optional).map(v => v.name)), u.params && Gh(u.params, f.keys.map(v => v.name))),
            g = f.stringify(p)
        } else if ("path"in u)
            g = u.path,
            f = t.find(v => v.re.test(g)),
            f && (p = f.parse(g),
            x = f.record.name);
        else {
            if (f = h.name ? i.get(h.name) : t.find(v => v.re.test(h.path)),
            !f)
                throw Or(1, {
                    location: u,
                    currentLocation: h
                });
            x = f.record.name,
            p = Qe({}, h.params, u.params),
            g = f.stringify(p)
        }
        const m = [];
        let d = f;
        for (; d; )
            m.unshift(d.record),
            d = d.parent;
        return {
            name: x,
            path: g,
            params: p,
            matched: m,
            meta: Jy(m)
        }
    }
    return n.forEach(u => s(u)),
    {
        addRoute: s,
        resolve: c,
        removeRoute: o,
        getRoutes: a,
        getRecordMatcher: r
    }
}
function Gh(n, e) {
    const t = {};
    for (const i of e)
        i in n && (t[i] = n[i]);
    return t
}
function qy(n) {
    return {
        path: n.path,
        redirect: n.redirect,
        name: n.name,
        meta: n.meta || {},
        aliasOf: void 0,
        beforeEnter: n.beforeEnter,
        props: Yy(n),
        children: n.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in n ? n.components || null : n.component && {
            default: n.component
        }
    }
}
function Yy(n) {
    const e = {}
      , t = n.props || !1;
    if ("component"in n)
        e.default = t;
    else
        for (const i in n.components)
            e[i] = typeof t == "object" ? t[i] : t;
    return e
}
function Vh(n) {
    for (; n; ) {
        if (n.record.aliasOf)
            return !0;
        n = n.parent
    }
    return !1
}
function Jy(n) {
    return n.reduce( (e, t) => Qe(e, t.meta), {})
}
function Wh(n, e) {
    const t = {};
    for (const i in n)
        t[i] = i in e ? e[i] : n[i];
    return t
}
function vm(n, e) {
    return e.children.some(t => t === n || vm(n, t))
}
const xm = /#/g
  , Zy = /&/g
  , Qy = /\//g
  , eM = /=/g
  , tM = /\?/g
  , ym = /\+/g
  , nM = /%5B/g
  , iM = /%5D/g
  , Mm = /%5E/g
  , rM = /%60/g
  , Sm = /%7B/g
  , sM = /%7C/g
  , Em = /%7D/g
  , oM = /%20/g;
function fu(n) {
    return encodeURI("" + n).replace(sM, "|").replace(nM, "[").replace(iM, "]")
}
function aM(n) {
    return fu(n).replace(Sm, "{").replace(Em, "}").replace(Mm, "^")
}
function vc(n) {
    return fu(n).replace(ym, "%2B").replace(oM, "+").replace(xm, "%23").replace(Zy, "%26").replace(rM, "`").replace(Sm, "{").replace(Em, "}").replace(Mm, "^")
}
function lM(n) {
    return vc(n).replace(eM, "%3D")
}
function cM(n) {
    return fu(n).replace(xm, "%23").replace(tM, "%3F")
}
function uM(n) {
    return n == null ? "" : cM(n).replace(Qy, "%2F")
}
function sa(n) {
    try {
        return decodeURIComponent("" + n)
    } catch {}
    return "" + n
}
function hM(n) {
    const e = {};
    if (n === "" || n === "?")
        return e;
    const i = (n[0] === "?" ? n.slice(1) : n).split("&");
    for (let r = 0; r < i.length; ++r) {
        const s = i[r].replace(ym, " ")
          , o = s.indexOf("=")
          , a = sa(o < 0 ? s : s.slice(0, o))
          , l = o < 0 ? null : sa(s.slice(o + 1));
        if (a in e) {
            let c = e[a];
            Mn(c) || (c = e[a] = [c]),
            c.push(l)
        } else
            e[a] = l
    }
    return e
}
function Xh(n) {
    let e = "";
    for (let t in n) {
        const i = n[t];
        if (t = lM(t),
        i == null) {
            i !== void 0 && (e += (e.length ? "&" : "") + t);
            continue
        }
        (Mn(i) ? i.map(s => s && vc(s)) : [i && vc(i)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + t,
            s != null && (e += "=" + s))
        }
        )
    }
    return e
}
function fM(n) {
    const e = {};
    for (const t in n) {
        const i = n[t];
        i !== void 0 && (e[t] = Mn(i) ? i.map(r => r == null ? null : "" + r) : i == null ? i : "" + i)
    }
    return e
}
const dM = Symbol("")
  , $h = Symbol("")
  , du = Symbol("")
  , bm = Symbol("")
  , xc = Symbol("");
function ts() {
    let n = [];
    function e(i) {
        return n.push(i),
        () => {
            const r = n.indexOf(i);
            r > -1 && n.splice(r, 1)
        }
    }
    function t() {
        n = []
    }
    return {
        add: e,
        list: () => n.slice(),
        reset: t
    }
}
function fi(n, e, t, i, r) {
    const s = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || []);
    return () => new Promise( (o, a) => {
        const l = h => {
            h === !1 ? a(Or(4, {
                from: t,
                to: e
            })) : h instanceof Error ? a(h) : zy(h) ? a(Or(2, {
                from: e,
                to: h
            })) : (s && i.enterCallbacks[r] === s && typeof h == "function" && s.push(h),
            o())
        }
          , c = n.call(i && i.instances[r], e, t, l);
        let u = Promise.resolve(c);
        n.length < 3 && (u = u.then(l)),
        u.catch(h => a(h))
    }
    )
}
function sl(n, e, t, i) {
    const r = [];
    for (const s of n)
        for (const o in s.components) {
            let a = s.components[o];
            if (!(e !== "beforeRouteEnter" && !s.instances[o]))
                if (pM(a)) {
                    const c = (a.__vccOpts || a)[e];
                    c && r.push(fi(c, t, i, s, o))
                } else {
                    let l = a();
                    r.push( () => l.then(c => {
                        if (!c)
                            return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
                        const u = yy(c) ? c.default : c;
                        s.components[o] = u;
                        const f = (u.__vccOpts || u)[e];
                        return f && fi(f, t, i, s, o)()
                    }
                    ))
                }
        }
    return r
}
function pM(n) {
    return typeof n == "object" || "displayName"in n || "props"in n || "__vccOpts"in n
}
function jh(n) {
    const e = Jt(du)
      , t = Jt(bm)
      , i = _n( () => e.resolve(st(n.to)))
      , r = _n( () => {
        const {matched: l} = i.value
          , {length: c} = l
          , u = l[c - 1]
          , h = t.matched;
        if (!u || !h.length)
            return -1;
        const f = h.findIndex(Fr.bind(null, u));
        if (f > -1)
            return f;
        const p = Kh(l[c - 2]);
        return c > 1 && Kh(u) === p && h[h.length - 1].path !== p ? h.findIndex(Fr.bind(null, l[c - 2])) : f
    }
    )
      , s = _n( () => r.value > -1 && vM(t.params, i.value.params))
      , o = _n( () => r.value > -1 && r.value === t.matched.length - 1 && dm(t.params, i.value.params));
    function a(l={}) {
        return _M(l) ? e[st(n.replace) ? "replace" : "push"](st(n.to)).catch(ys) : Promise.resolve()
    }
    return {
        route: i,
        href: _n( () => i.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const mM = $i({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: jh,
    setup(n, {slots: e}) {
        const t = yi(jh(n))
          , {options: i} = Jt(du)
          , r = _n( () => ({
            [qh(n.activeClass, i.linkActiveClass, "router-link-active")]: t.isActive,
            [qh(n.exactActiveClass, i.linkExactActiveClass, "router-link-exact-active")]: t.isExactActive
        }));
        return () => {
            const s = e.default && e.default(t);
            return n.custom ? s : Kn("a", {
                "aria-current": t.isExactActive ? n.ariaCurrentValue : null,
                href: t.href,
                onClick: t.navigate,
                class: r.value
            }, s)
        }
    }
})
  , gM = mM;
function _M(n) {
    if (!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) && !n.defaultPrevented && !(n.button !== void 0 && n.button !== 0)) {
        if (n.currentTarget && n.currentTarget.getAttribute) {
            const e = n.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e))
                return
        }
        return n.preventDefault && n.preventDefault(),
        !0
    }
}
function vM(n, e) {
    for (const t in e) {
        const i = e[t]
          , r = n[t];
        if (typeof i == "string") {
            if (i !== r)
                return !1
        } else if (!Mn(r) || r.length !== i.length || i.some( (s, o) => s !== r[o]))
            return !1
    }
    return !0
}
function Kh(n) {
    return n ? n.aliasOf ? n.aliasOf.path : n.path : ""
}
const qh = (n, e, t) => n ?? e ?? t
  , xM = $i({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(n, {attrs: e, slots: t}) {
        const i = Jt(xc)
          , r = _n( () => n.route || i.value)
          , s = Jt($h, 0)
          , o = _n( () => {
            let c = st(s);
            const {matched: u} = r.value;
            let h;
            for (; (h = u[c]) && !h.components; )
                c++;
            return c
        }
        )
          , a = _n( () => r.value.matched[o.value]);
        Rr($h, _n( () => o.value + 1)),
        Rr(dM, a),
        Rr(xc, r);
        const l = Rn();
        return ms( () => [l.value, a.value, n.name], ([c,u,h], [f,p,g]) => {
            u && (u.instances[h] = c,
            p && p !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = p.leaveGuards),
            u.updateGuards.size || (u.updateGuards = p.updateGuards))),
            c && u && (!p || !Fr(u, p) || !f) && (u.enterCallbacks[h] || []).forEach(x => x(c))
        }
        , {
            flush: "post"
        }),
        () => {
            const c = r.value
              , u = n.name
              , h = a.value
              , f = h && h.components[u];
            if (!f)
                return Yh(t.default, {
                    Component: f,
                    route: c
                });
            const p = h.props[u]
              , g = p ? p === !0 ? c.params : typeof p == "function" ? p(c) : p : null
              , m = Kn(f, Qe({}, g, e, {
                onVnodeUnmounted: d => {
                    d.component.isUnmounted && (h.instances[u] = null)
                }
                ,
                ref: l
            }));
            return Yh(t.default, {
                Component: m,
                route: c
            }) || m
        }
    }
});
function Yh(n, e) {
    if (!n)
        return null;
    const t = n(e);
    return t.length === 1 ? t[0] : t
}
const Tm = xM;
function yM(n) {
    const e = Ky(n.routes, n)
      , t = n.parseQuery || hM
      , i = n.stringifyQuery || Xh
      , r = n.history
      , s = ts()
      , o = ts()
      , a = ts()
      , l = Ps(En);
    let c = En;
    mr && n.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const u = il.bind(null, W => "" + W)
      , h = il.bind(null, uM)
      , f = il.bind(null, sa);
    function p(W, se) {
        let ce, ge;
        return gm(W) ? (ce = e.getRecordMatcher(W),
        ge = se) : ge = W,
        e.addRoute(ge, ce)
    }
    function g(W) {
        const se = e.getRecordMatcher(W);
        se && e.removeRoute(se)
    }
    function x() {
        return e.getRoutes().map(W => W.record)
    }
    function m(W) {
        return !!e.getRecordMatcher(W)
    }
    function d(W, se) {
        if (se = Qe({}, se || l.value),
        typeof W == "string") {
            const D = rl(t, W, se.path)
              , O = e.resolve({
                path: D.path
            }, se)
              , N = r.createHref(D.fullPath);
            return Qe(D, O, {
                params: f(O.params),
                hash: sa(D.hash),
                redirectedFrom: void 0,
                href: N
            })
        }
        let ce;
        if ("path"in W)
            ce = Qe({}, W, {
                path: rl(t, W.path, se.path).path
            });
        else {
            const D = Qe({}, W.params);
            for (const O in D)
                D[O] == null && delete D[O];
            ce = Qe({}, W, {
                params: h(D)
            }),
            se.params = h(se.params)
        }
        const ge = e.resolve(ce, se)
          , he = W.hash || "";
        ge.params = u(f(ge.params));
        const y = Ey(i, Qe({}, W, {
            hash: aM(he),
            path: ge.path
        }))
          , R = r.createHref(y);
        return Qe({
            fullPath: y,
            hash: he,
            query: i === Xh ? fM(W.query) : W.query || {}
        }, ge, {
            redirectedFrom: void 0,
            href: R
        })
    }
    function v(W) {
        return typeof W == "string" ? rl(t, W, l.value.path) : Qe({}, W)
    }
    function _(W, se) {
        if (c !== W)
            return Or(8, {
                from: se,
                to: W
            })
    }
    function M(W) {
        return C(W)
    }
    function b(W) {
        return M(Qe(v(W), {
            replace: !0
        }))
    }
    function A(W) {
        const se = W.matched[W.matched.length - 1];
        if (se && se.redirect) {
            const {redirect: ce} = se;
            let ge = typeof ce == "function" ? ce(W) : ce;
            return typeof ge == "string" && (ge = ge.includes("?") || ge.includes("#") ? ge = v(ge) : {
                path: ge
            },
            ge.params = {}),
            Qe({
                query: W.query,
                hash: W.hash,
                params: "path"in ge ? {} : W.params
            }, ge)
        }
    }
    function C(W, se) {
        const ce = c = d(W)
          , ge = l.value
          , he = W.state
          , y = W.force
          , R = W.replace === !0
          , D = A(ce);
        if (D)
            return C(Qe(v(D), {
                state: typeof D == "object" ? Qe({}, he, D.state) : he,
                force: y,
                replace: R
            }), se || ce);
        const O = ce;
        O.redirectedFrom = se;
        let N;
        return !y && by(i, ge, ce) && (N = Or(16, {
            to: O,
            from: ge
        }),
        B(ge, ge, !0, !1)),
        (N ? Promise.resolve(N) : T(O, ge)).catch(j => Un(j) ? Un(j, 2) ? j : le(j) : re(j, O, ge)).then(j => {
            if (j) {
                if (Un(j, 2))
                    return C(Qe({
                        replace: R
                    }, v(j.to), {
                        state: typeof j.to == "object" ? Qe({}, he, j.to.state) : he,
                        force: y
                    }), se || O)
            } else
                j = k(O, ge, !0, R, he);
            return F(O, ge, j),
            j
        }
        )
    }
    function P(W, se) {
        const ce = _(W, se);
        return ce ? Promise.reject(ce) : Promise.resolve()
    }
    function S(W) {
        const se = _e.values().next().value;
        return se && typeof se.runWithContext == "function" ? se.runWithContext(W) : W()
    }
    function T(W, se) {
        let ce;
        const [ge,he,y] = MM(W, se);
        ce = sl(ge.reverse(), "beforeRouteLeave", W, se);
        for (const D of ge)
            D.leaveGuards.forEach(O => {
                ce.push(fi(O, W, se))
            }
            );
        const R = P.bind(null, W, se);
        return ce.push(R),
        Ae(ce).then( () => {
            ce = [];
            for (const D of s.list())
                ce.push(fi(D, W, se));
            return ce.push(R),
            Ae(ce)
        }
        ).then( () => {
            ce = sl(he, "beforeRouteUpdate", W, se);
            for (const D of he)
                D.updateGuards.forEach(O => {
                    ce.push(fi(O, W, se))
                }
                );
            return ce.push(R),
            Ae(ce)
        }
        ).then( () => {
            ce = [];
            for (const D of y)
                if (D.beforeEnter)
                    if (Mn(D.beforeEnter))
                        for (const O of D.beforeEnter)
                            ce.push(fi(O, W, se));
                    else
                        ce.push(fi(D.beforeEnter, W, se));
            return ce.push(R),
            Ae(ce)
        }
        ).then( () => (W.matched.forEach(D => D.enterCallbacks = {}),
        ce = sl(y, "beforeRouteEnter", W, se),
        ce.push(R),
        Ae(ce))).then( () => {
            ce = [];
            for (const D of o.list())
                ce.push(fi(D, W, se));
            return ce.push(R),
            Ae(ce)
        }
        ).catch(D => Un(D, 8) ? D : Promise.reject(D))
    }
    function F(W, se, ce) {
        a.list().forEach(ge => S( () => ge(W, se, ce)))
    }
    function k(W, se, ce, ge, he) {
        const y = _(W, se);
        if (y)
            return y;
        const R = se === En
          , D = mr ? history.state : {};
        ce && (ge || R ? r.replace(W.fullPath, Qe({
            scroll: R && D && D.scroll
        }, he)) : r.push(W.fullPath, he)),
        l.value = W,
        B(W, se, ce, R),
        le()
    }
    let X;
    function L() {
        X || (X = r.listen( (W, se, ce) => {
            if (!Te.listening)
                return;
            const ge = d(W)
              , he = A(ge);
            if (he) {
                C(Qe(he, {
                    replace: !0
                }), ge).catch(ys);
                return
            }
            c = ge;
            const y = l.value;
            mr && Dy(Oh(y.fullPath, ce.delta), Pa()),
            T(ge, y).catch(R => Un(R, 12) ? R : Un(R, 2) ? (C(R.to, ge).then(D => {
                Un(D, 20) && !ce.delta && ce.type === Fs.pop && r.go(-1, !1)
            }
            ).catch(ys),
            Promise.reject()) : (ce.delta && r.go(-ce.delta, !1),
            re(R, ge, y))).then(R => {
                R = R || k(ge, y, !1),
                R && (ce.delta && !Un(R, 8) ? r.go(-ce.delta, !1) : ce.type === Fs.pop && Un(R, 20) && r.go(-1, !1)),
                F(ge, y, R)
            }
            ).catch(ys)
        }
        ))
    }
    let G = ts(), V = ts(), $;
    function re(W, se, ce) {
        le(W);
        const ge = V.list();
        return ge.length ? ge.forEach(he => he(W, se, ce)) : console.error(W),
        Promise.reject(W)
    }
    function ee() {
        return $ && l.value !== En ? Promise.resolve() : new Promise( (W, se) => {
            G.add([W, se])
        }
        )
    }
    function le(W) {
        return $ || ($ = !W,
        L(),
        G.list().forEach( ([se,ce]) => W ? ce(W) : se()),
        G.reset()),
        W
    }
    function B(W, se, ce, ge) {
        const {scrollBehavior: he} = n;
        if (!mr || !he)
            return Promise.resolve();
        const y = !ce && Iy(Oh(W.fullPath, 0)) || (ge || !ce) && history.state && history.state.scroll || null;
        return jr().then( () => he(W, se, y)).then(R => R && Ly(R)).catch(R => re(R, W, se))
    }
    const J = W => r.go(W);
    let fe;
    const _e = new Set
      , Te = {
        currentRoute: l,
        listening: !0,
        addRoute: p,
        removeRoute: g,
        hasRoute: m,
        getRoutes: x,
        resolve: d,
        options: n,
        push: M,
        replace: b,
        go: J,
        back: () => J(-1),
        forward: () => J(1),
        beforeEach: s.add,
        beforeResolve: o.add,
        afterEach: a.add,
        onError: V.add,
        isReady: ee,
        install(W) {
            const se = this;
            W.component("RouterLink", gM),
            W.component("RouterView", Tm),
            W.config.globalProperties.$router = se,
            Object.defineProperty(W.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => st(l)
            }),
            mr && !fe && l.value === En && (fe = !0,
            M(r.location).catch(he => {}
            ));
            const ce = {};
            for (const he in En)
                Object.defineProperty(ce, he, {
                    get: () => l.value[he],
                    enumerable: !0
                });
            W.provide(du, se),
            W.provide(bm, Xs(ce)),
            W.provide(xc, l);
            const ge = W.unmount;
            _e.add(W),
            W.unmount = function() {
                _e.delete(W),
                _e.size < 1 && (c = En,
                X && X(),
                X = null,
                l.value = En,
                fe = !1,
                $ = !1),
                ge()
            }
        }
    };
    function Ae(W) {
        return W.reduce( (se, ce) => se.then( () => S(ce)), Promise.resolve())
    }
    return Te
}
function MM(n, e) {
    const t = []
      , i = []
      , r = []
      , s = Math.max(e.matched.length, n.matched.length);
    for (let o = 0; o < s; o++) {
        const a = e.matched[o];
        a && (n.matched.find(c => Fr(c, a)) ? i.push(a) : t.push(a));
        const l = n.matched[o];
        l && (e.matched.find(c => Fr(c, l)) || r.push(l))
    }
    return [t, i, r]
}
const Jh = [{
    name: "index",
    path: "/",
    meta: {},
    alias: [],
    redirect: void 0,
    component: () => lc( () => import("./index.js"), ["./index.js", "./vue.js", "./index.css"], import.meta.url).then(n => n.default || n)
}]
  , SM = {
    scrollBehavior(n, e, t) {
        var c;
        const i = ft()
          , r = ((c = Ki().options) == null ? void 0 : c.scrollBehaviorType) ?? "auto";
        let s = t || void 0;
        const o = typeof n.meta.scrollToTop == "function" ? n.meta.scrollToTop(n, e) : n.meta.scrollToTop;
        if (!s && e && n && o !== !1 && EM(e, n) && (s = {
            left: 0,
            top: 0
        }),
        n.path === e.path) {
            if (e.hash && !n.hash)
                return {
                    left: 0,
                    top: 0
                };
            if (n.hash)
                return {
                    el: n.hash,
                    top: Zh(n.hash),
                    behavior: r
                }
        }
        const a = u => !!(u.meta.pageTransition ?? gc)
          , l = a(e) && a(n) ? "page:transition:finish" : "page:finish";
        return new Promise(u => {
            i.hooks.hookOnce(l, async () => {
                await jr(),
                n.hash && (s = {
                    el: n.hash,
                    top: Zh(n.hash),
                    behavior: r
                }),
                u(s)
            }
            )
        }
        )
    }
};
function Zh(n) {
    try {
        const e = document.querySelector(n);
        if (e)
            return parseFloat(getComputedStyle(e).scrollMarginTop)
    } catch {}
    return 0
}
function EM(n, e) {
    return e.path !== n.path || JSON.stringify(n.params) !== JSON.stringify(e.params)
}
const bM = {}
  , Bt = {
    ...bM,
    ...SM
}
  , TM = async n => {
    var l;
    let e, t;
    if (!((l = n.meta) != null && l.validate))
        return;
    const i = ft()
      , r = Ki();
    if (([e,t] = ia( () => Promise.resolve(n.meta.validate(n))),
    e = await e,
    t(),
    e) === !0)
        return;
    const o = hu({
        statusCode: 404,
        statusMessage: `Page Not Found: ${n.fullPath}`
    })
      , a = r.beforeResolve(c => {
        if (a(),
        c === n) {
            const u = r.afterEach(async () => {
                u(),
                await i.runWithContext( () => xr(o)),
                window.history.pushState({}, "", n.fullPath)
            }
            );
            return !1
        }
    }
    )
}
  , wM = [TM]
  , Ss = {};
function AM(n, e, t) {
    const {pathname: i, search: r, hash: s} = e
      , o = n.indexOf("#");
    if (o > -1) {
        const c = s.includes(n.slice(o)) ? n.slice(o).length : 1;
        let u = s.slice(c);
        return u[0] !== "/" && (u = "/" + u),
        vh(u, "")
    }
    const a = vh(i, n)
      , l = !t || C0(a, t, {
        trailingSlash: !0
    }) ? a : t;
    return l + (l.includes("?") ? "" : r) + s
}
const RM = ji({
    name: "nuxt:router",
    enforce: "pre",
    async setup(n) {
        var x, m;
        let e, t, i = Aa().app.baseURL;
        Bt.hashMode && !i.includes("#") && (i += "#");
        const r = ((x = Bt.history) == null ? void 0 : x.call(Bt, i)) ?? (Bt.hashMode ? Oy(i) : mm(i))
          , s = ((m = Bt.routes) == null ? void 0 : m.call(Bt, Jh)) ?? Jh;
        let o;
        const a = AM(i, window.location, n.payload.path)
          , l = yM({
            ...Bt,
            scrollBehavior: (d, v, _) => {
                var M;
                if (v === En) {
                    o = _;
                    return
                }
                return l.options.scrollBehavior = Bt.scrollBehavior,
                (M = Bt.scrollBehavior) == null ? void 0 : M.call(Bt, d, En, o || _)
            }
            ,
            history: r,
            routes: s
        });
        n.vueApp.use(l);
        const c = Ps(l.currentRoute.value);
        l.afterEach( (d, v) => {
            c.value = v
        }
        ),
        Object.defineProperty(n.vueApp.config.globalProperties, "previousRoute", {
            get: () => c.value
        });
        const u = Ps(l.resolve(a))
          , h = () => {
            u.value = l.currentRoute.value
        }
        ;
        n.hook("page:finish", h),
        l.afterEach( (d, v) => {
            var _, M, b, A;
            ((M = (_ = d.matched[0]) == null ? void 0 : _.components) == null ? void 0 : M.default) === ((A = (b = v.matched[0]) == null ? void 0 : b.components) == null ? void 0 : A.default) && h()
        }
        );
        const f = {};
        for (const d in u.value)
            Object.defineProperty(f, d, {
                get: () => u.value[d]
            });
        n._route = Xs(f),
        n._middleware = n._middleware || {
            global: [],
            named: {}
        };
        const p = Ca();
        try {
            [e,t] = ia( () => l.isReady()),
            await e,
            t()
        } catch (d) {
            [e,t] = ia( () => n.runWithContext( () => xr(d))),
            await e,
            t()
        }
        const g = n.payload.state._layout;
        return l.beforeEach(async (d, v) => {
            var _;
            d.meta = yi(d.meta),
            n.isHydrating && g && !Vi(d.meta.layout) && (d.meta.layout = g),
            n._processingMiddleware = !0;
            {
                const M = new Set([...wM, ...n._middleware.global]);
                for (const b of d.matched) {
                    const A = b.meta.middleware;
                    if (A)
                        if (Array.isArray(A))
                            for (const C of A)
                                M.add(C);
                        else
                            M.add(A)
                }
                for (const b of M) {
                    const A = typeof b == "string" ? n._middleware.named[b] || await ((_ = Ss[b]) == null ? void 0 : _.call(Ss).then(P => P.default || P)) : b;
                    if (!A)
                        throw new Error(`Unknown route middleware: '${b}'.`);
                    const C = await n.runWithContext( () => A(d, v));
                    if (!n.payload.serverRendered && n.isHydrating && (C === !1 || C instanceof Error)) {
                        const P = C || pc({
                            statusCode: 404,
                            statusMessage: `Page Not Found: ${a}`
                        });
                        return await n.runWithContext( () => xr(P)),
                        !1
                    }
                    if (C !== !0 && (C || C === !1))
                        return C
                }
            }
        }
        ),
        l.onError( () => {
            delete n._processingMiddleware
        }
        ),
        l.afterEach(async (d, v, _) => {
            delete n._processingMiddleware,
            !n.isHydrating && p.value && await n.runWithContext(ay),
            d.matched.length === 0 && await n.runWithContext( () => xr(pc({
                statusCode: 404,
                fatal: !1,
                statusMessage: `Page not found: ${d.fullPath}`
            })))
        }
        ),
        n.hooks.hookOnce("app:created", async () => {
            try {
                await l.replace({
                    ...l.resolve(a),
                    name: void 0,
                    force: !0
                }),
                l.options.scrollBehavior = Bt.scrollBehavior
            } catch (d) {
                await n.runWithContext( () => xr(d))
            }
        }
        ),
        {
            provide: {
                router: l
            }
        }
    }
})
  , CM = ji({
    name: "nuxt:payload",
    setup(n) {
        Ki().beforeResolve(async (e, t) => {
            if (e.path === t.path)
                return;
            const i = await Dh(e.path);
            i && Object.assign(n.static.data, i.data)
        }
        ),
        cy( () => {
            n.hooks.hook("link:prefetch", async e => {
                wa(e).protocol || await Dh(e)
            }
            )
        }
        )
    }
})
  , PM = ji({
    name: "nuxt:global-components"
})
  , uo = {}
  , LM = ji({
    name: "nuxt:prefetch",
    setup(n) {
        const e = Ki();
        n.hooks.hook("app:mounted", () => {
            e.beforeEach(async t => {
                var r;
                const i = (r = t == null ? void 0 : t.meta) == null ? void 0 : r.layout;
                i && typeof uo[i] == "function" && await uo[i]()
            }
            )
        }
        ),
        n.hooks.hook("link:prefetch", t => {
            var o, a, l, c;
            if (Ks(t))
                return;
            const i = e.resolve(t);
            if (!i)
                return;
            const r = (o = i == null ? void 0 : i.meta) == null ? void 0 : o.layout;
            let s = Array.isArray((a = i == null ? void 0 : i.meta) == null ? void 0 : a.middleware) ? (l = i == null ? void 0 : i.meta) == null ? void 0 : l.middleware : [(c = i == null ? void 0 : i.meta) == null ? void 0 : c.middleware];
            s = s.filter(u => typeof u == "string");
            for (const u of s)
                typeof Ss[u] == "function" && Ss[u]();
            r && typeof uo[r] == "function" && uo[r]()
        }
        )
    }
})
  , DM = ji({
    name: "nuxt:chunk-reload",
    setup(n) {
        const e = Ki()
          , t = Aa()
          , i = new Set;
        e.beforeEach( () => {
            i.clear()
        }
        ),
        n.hook("app:chunkError", ({error: s}) => {
            i.add(s)
        }
        );
        function r(s) {
            const a = "href"in s && s.href.startsWith("#") ? t.app.baseURL + s.href : qs(t.app.baseURL, s.fullPath);
            uy({
                path: a,
                persistState: !0
            })
        }
        n.hook("app:manifest:update", () => {
            e.beforeResolve(r)
        }
        ),
        e.onError( (s, o) => {
            i.has(s) && r(o)
        }
        )
    }
})
  , IM = [_y, xy, RM, CM, PM, LM, DM];
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const pu = "157"
  , UM = 0
  , Qh = 1
  , NM = 2
  , wm = 1
  , FM = 2
  , Gn = 3
  , Jn = 0
  , Wt = 1
  , An = 2
  , gi = 0
  , Cr = 1
  , ef = 2
  , tf = 3
  , nf = 4
  , OM = 5
  , gr = 100
  , zM = 101
  , BM = 102
  , rf = 103
  , sf = 104
  , HM = 200
  , kM = 201
  , GM = 202
  , VM = 203
  , Am = 204
  , Rm = 205
  , WM = 206
  , XM = 207
  , $M = 208
  , jM = 209
  , KM = 210
  , qM = 0
  , YM = 1
  , JM = 2
  , yc = 3
  , ZM = 4
  , QM = 5
  , eS = 6
  , tS = 7
  , Cm = 0
  , nS = 1
  , iS = 2
  , _i = 0
  , rS = 1
  , sS = 2
  , oS = 3
  , aS = 4
  , lS = 5
  , Pm = 300
  , zr = 301
  , Br = 302
  , oa = 303
  , Mc = 304
  , La = 306
  , Os = 1e3
  , qt = 1001
  , Sc = 1002
  , St = 1003
  , of = 1004
  , ol = 1005
  , Rt = 1006
  , cS = 1007
  , Hr = 1008
  , vi = 1009
  , uS = 1010
  , hS = 1011
  , mu = 1012
  , Lm = 1013
  , di = 1014
  , xn = 1015
  , $n = 1016
  , Dm = 1017
  , Im = 1018
  , Hi = 1020
  , fS = 1021
  , vn = 1023
  , dS = 1024
  , pS = 1025
  , ki = 1026
  , kr = 1027
  , mS = 1028
  , Um = 1029
  , gS = 1030
  , Nm = 1031
  , Fm = 1033
  , al = 33776
  , ll = 33777
  , cl = 33778
  , ul = 33779
  , af = 35840
  , lf = 35841
  , cf = 35842
  , uf = 35843
  , _S = 36196
  , hf = 37492
  , ff = 37496
  , df = 37808
  , pf = 37809
  , mf = 37810
  , gf = 37811
  , _f = 37812
  , vf = 37813
  , xf = 37814
  , yf = 37815
  , Mf = 37816
  , Sf = 37817
  , Ef = 37818
  , bf = 37819
  , Tf = 37820
  , wf = 37821
  , hl = 36492
  , Af = 36494
  , Rf = 36495
  , vS = 36283
  , Cf = 36284
  , Pf = 36285
  , Lf = 36286
  , Om = 3e3
  , Gi = 3001
  , xS = 3200
  , yS = 3201
  , Da = 0
  , MS = 1
  , on = ""
  , At = "srgb"
  , Ln = "srgb-linear"
  , gu = "display-p3"
  , Ia = "display-p3-linear"
  , aa = "linear"
  , it = "srgb"
  , la = "rec709"
  , ca = "p3"
  , fl = 7680
  , SS = 519
  , ES = 512
  , bS = 513
  , TS = 514
  , wS = 515
  , AS = 516
  , RS = 517
  , CS = 518
  , PS = 519
  , Df = 35044
  , If = "300 es"
  , Ec = 1035
  , jn = 2e3
  , ua = 2001;
class Kr {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const Pt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , dl = Math.PI / 180
  , bc = 180 / Math.PI;
function qr() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (Pt[n & 255] + Pt[n >> 8 & 255] + Pt[n >> 16 & 255] + Pt[n >> 24 & 255] + "-" + Pt[e & 255] + Pt[e >> 8 & 255] + "-" + Pt[e >> 16 & 15 | 64] + Pt[e >> 24 & 255] + "-" + Pt[t & 63 | 128] + Pt[t >> 8 & 255] + "-" + Pt[t >> 16 & 255] + Pt[t >> 24 & 255] + Pt[i & 255] + Pt[i >> 8 & 255] + Pt[i >> 16 & 255] + Pt[i >> 24 & 255]).toLowerCase()
}
function vt(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function LS(n, e) {
    return (n % e + e) % e
}
function pl(n, e, t) {
    return (1 - t) * n + t * e
}
function Uf(n) {
    return (n & n - 1) === 0 && n !== 0
}
function Tc(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function ns(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Ht(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
class xe {
    constructor(e=0, t=0) {
        xe.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(vt(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class $e {
    constructor(e, t, i, r, s, o, a, l, c) {
        $e.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, l, c)
    }
    set(e, t, i, r, s, o, a, l, c) {
        const u = this.elements;
        return u[0] = e,
        u[1] = r,
        u[2] = a,
        u[3] = t,
        u[4] = s,
        u[5] = l,
        u[6] = i,
        u[7] = o,
        u[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , c = i[1]
          , u = i[4]
          , h = i[7]
          , f = i[2]
          , p = i[5]
          , g = i[8]
          , x = r[0]
          , m = r[3]
          , d = r[6]
          , v = r[1]
          , _ = r[4]
          , M = r[7]
          , b = r[2]
          , A = r[5]
          , C = r[8];
        return s[0] = o * x + a * v + l * b,
        s[3] = o * m + a * _ + l * A,
        s[6] = o * d + a * M + l * C,
        s[1] = c * x + u * v + h * b,
        s[4] = c * m + u * _ + h * A,
        s[7] = c * d + u * M + h * C,
        s[2] = f * x + p * v + g * b,
        s[5] = f * m + p * _ + g * A,
        s[8] = f * d + p * M + g * C,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8];
        return t * o * u - t * a * c - i * s * u + i * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , h = u * o - a * c
          , f = a * l - u * s
          , p = c * s - o * l
          , g = t * h + i * f + r * p;
        if (g === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const x = 1 / g;
        return e[0] = h * x,
        e[1] = (r * c - u * i) * x,
        e[2] = (a * i - r * o) * x,
        e[3] = f * x,
        e[4] = (u * t - r * l) * x,
        e[5] = (r * s - a * t) * x,
        e[6] = p * x,
        e[7] = (i * l - c * t) * x,
        e[8] = (o * t - i * s) * x,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const l = Math.cos(s)
          , c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(ml.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(ml.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(ml.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const ml = new $e;
function zm(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
function zs(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function DS() {
    const n = zs("canvas");
    return n.style.display = "block",
    n
}
const Nf = {};
function Es(n) {
    n in Nf || (Nf[n] = !0,
    console.warn(n))
}
const Ff = new $e().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , Of = new $e().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , ho = {
    [Ln]: {
        transfer: aa,
        primaries: la,
        toReference: n => n,
        fromReference: n => n
    },
    [At]: {
        transfer: it,
        primaries: la,
        toReference: n => n.convertSRGBToLinear(),
        fromReference: n => n.convertLinearToSRGB()
    },
    [Ia]: {
        transfer: aa,
        primaries: ca,
        toReference: n => n.applyMatrix3(Of),
        fromReference: n => n.applyMatrix3(Ff)
    },
    [gu]: {
        transfer: it,
        primaries: ca,
        toReference: n => n.convertSRGBToLinear().applyMatrix3(Of),
        fromReference: n => n.applyMatrix3(Ff).convertLinearToSRGB()
    }
}
  , IS = new Set([Ln, Ia])
  , et = {
    enabled: !0,
    _workingColorSpace: Ln,
    get legacyMode() {
        return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        !this.enabled
    },
    set legacyMode(n) {
        console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
        this.enabled = !n
    },
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(n) {
        if (!IS.has(n))
            throw new Error(`Unsupported working color space, "${n}".`);
        this._workingColorSpace = n
    },
    convert: function(n, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return n;
        const i = ho[e].toReference
          , r = ho[t].fromReference;
        return r(i(n))
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this._workingColorSpace)
    },
    getPrimaries: function(n) {
        return ho[n].primaries
    },
    getTransfer: function(n) {
        return n === on ? aa : ho[n].transfer
    }
};
function Pr(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function gl(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Yi;
class Bm {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Yi === void 0 && (Yi = zs("canvas")),
            Yi.width = e.width,
            Yi.height = e.height;
            const i = Yi.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = Yi
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = zs("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = Pr(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Pr(t[i] / 255) * 255) : t[i] = Pr(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let US = 0;
class Hm {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: US++
        }),
        this.uuid = qr(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(_l(r[o].image)) : s.push(_l(r[o]))
            } else
                s = _l(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function _l(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? Bm.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let NS = 0;
class zt extends Kr {
    constructor(e=zt.DEFAULT_IMAGE, t=zt.DEFAULT_MAPPING, i=qt, r=qt, s=Rt, o=Hr, a=vn, l=vi, c=zt.DEFAULT_ANISOTROPY, u=on) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: NS++
        }),
        this.uuid = qr(),
        this.name = "",
        this.source = new Hm(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new xe(0,0),
        this.repeat = new xe(1,1),
        this.center = new xe(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new $e,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        typeof u == "string" ? this.colorSpace = u : (Es("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = u === Gi ? At : on),
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Pm)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Os:
                e.x = e.x - Math.floor(e.x);
                break;
            case qt:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Sc:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Os:
                e.y = e.y - Math.floor(e.y);
                break;
            case qt:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Sc:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    get encoding() {
        return Es("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace === At ? Gi : Om
    }
    set encoding(e) {
        Es("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = e === Gi ? At : on
    }
}
zt.DEFAULT_IMAGE = null;
zt.DEFAULT_MAPPING = Pm;
zt.DEFAULT_ANISOTROPY = 1;
class bt {
    constructor(e=0, t=0, i=0, r=1) {
        bt.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const l = e.elements
          , c = l[0]
          , u = l[4]
          , h = l[8]
          , f = l[1]
          , p = l[5]
          , g = l[9]
          , x = l[2]
          , m = l[6]
          , d = l[10];
        if (Math.abs(u - f) < .01 && Math.abs(h - x) < .01 && Math.abs(g - m) < .01) {
            if (Math.abs(u + f) < .1 && Math.abs(h + x) < .1 && Math.abs(g + m) < .1 && Math.abs(c + p + d - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const _ = (c + 1) / 2
              , M = (p + 1) / 2
              , b = (d + 1) / 2
              , A = (u + f) / 4
              , C = (h + x) / 4
              , P = (g + m) / 4;
            return _ > M && _ > b ? _ < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(_),
            r = A / i,
            s = C / i) : M > b ? M < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(M),
            i = A / r,
            s = P / r) : b < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(b),
            i = C / s,
            r = P / s),
            this.set(i, r, s, t),
            this
        }
        let v = Math.sqrt((m - g) * (m - g) + (h - x) * (h - x) + (f - u) * (f - u));
        return Math.abs(v) < .001 && (v = 1),
        this.x = (m - g) / v,
        this.y = (h - x) / v,
        this.z = (f - u) / v,
        this.w = Math.acos((c + p + d - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class FS extends Kr {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new bt(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new bt(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        i.encoding !== void 0 && (Es("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
        i.colorSpace = i.encoding === Gi ? At : on),
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Rt,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0
        }, i),
        this.texture = new zt(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = i.generateMipmaps,
        this.texture.internalFormat = i.internalFormat,
        this.depthBuffer = i.depthBuffer,
        this.stencilBuffer = i.stencilBuffer,
        this.depthTexture = i.depthTexture,
        this.samples = i.samples
    }
    setSize(e, t, i=1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e,
        this.height = t,
        this.depth = i,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = i,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Hm(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Wi extends FS {
    constructor(e=1, t=1, i={}) {
        super(e, t, i),
        this.isWebGLRenderTarget = !0
    }
}
class km extends zt {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = St,
        this.minFilter = St,
        this.wrapR = qt,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class OS extends zt {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = St,
        this.minFilter = St,
        this.wrapR = qt,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Ys {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let l = i[r + 0]
          , c = i[r + 1]
          , u = i[r + 2]
          , h = i[r + 3];
        const f = s[o + 0]
          , p = s[o + 1]
          , g = s[o + 2]
          , x = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = u,
            e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = f,
            e[t + 1] = p,
            e[t + 2] = g,
            e[t + 3] = x;
            return
        }
        if (h !== x || l !== f || c !== p || u !== g) {
            let m = 1 - a;
            const d = l * f + c * p + u * g + h * x
              , v = d >= 0 ? 1 : -1
              , _ = 1 - d * d;
            if (_ > Number.EPSILON) {
                const b = Math.sqrt(_)
                  , A = Math.atan2(b, d * v);
                m = Math.sin(m * A) / b,
                a = Math.sin(a * A) / b
            }
            const M = a * v;
            if (l = l * m + f * M,
            c = c * m + p * M,
            u = u * m + g * M,
            h = h * m + x * M,
            m === 1 - a) {
                const b = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
                l *= b,
                c *= b,
                u *= b,
                h *= b
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = u,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r]
          , l = i[r + 1]
          , c = i[r + 2]
          , u = i[r + 3]
          , h = s[o]
          , f = s[o + 1]
          , p = s[o + 2]
          , g = s[o + 3];
        return e[t] = a * g + u * h + l * p - c * f,
        e[t + 1] = l * g + u * f + c * h - a * p,
        e[t + 2] = c * g + u * p + a * f - l * h,
        e[t + 3] = u * g - a * h - l * f - c * p,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(i / 2)
          , u = a(r / 2)
          , h = a(s / 2)
          , f = l(i / 2)
          , p = l(r / 2)
          , g = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = f * u * h + c * p * g,
            this._y = c * p * h - f * u * g,
            this._z = c * u * g + f * p * h,
            this._w = c * u * h - f * p * g;
            break;
        case "YXZ":
            this._x = f * u * h + c * p * g,
            this._y = c * p * h - f * u * g,
            this._z = c * u * g - f * p * h,
            this._w = c * u * h + f * p * g;
            break;
        case "ZXY":
            this._x = f * u * h - c * p * g,
            this._y = c * p * h + f * u * g,
            this._z = c * u * g + f * p * h,
            this._w = c * u * h - f * p * g;
            break;
        case "ZYX":
            this._x = f * u * h - c * p * g,
            this._y = c * p * h + f * u * g,
            this._z = c * u * g - f * p * h,
            this._w = c * u * h + f * p * g;
            break;
        case "YZX":
            this._x = f * u * h + c * p * g,
            this._y = c * p * h + f * u * g,
            this._z = c * u * g - f * p * h,
            this._w = c * u * h - f * p * g;
            break;
        case "XZY":
            this._x = f * u * h - c * p * g,
            this._y = c * p * h - f * u * g,
            this._z = c * u * g + f * p * h,
            this._w = c * u * h + f * p * g;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , u = t[6]
          , h = t[10]
          , f = i + a + h;
        if (f > 0) {
            const p = .5 / Math.sqrt(f + 1);
            this._w = .25 / p,
            this._x = (u - l) * p,
            this._y = (s - c) * p,
            this._z = (o - r) * p
        } else if (i > a && i > h) {
            const p = 2 * Math.sqrt(1 + i - a - h);
            this._w = (u - l) / p,
            this._x = .25 * p,
            this._y = (r + o) / p,
            this._z = (s + c) / p
        } else if (a > h) {
            const p = 2 * Math.sqrt(1 + a - i - h);
            this._w = (s - c) / p,
            this._x = (r + o) / p,
            this._y = .25 * p,
            this._z = (l + u) / p
        } else {
            const p = 2 * Math.sqrt(1 + h - i - a);
            this._w = (o - r) / p,
            this._x = (s + c) / p,
            this._y = (l + u) / p,
            this._z = .25 * p
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(vt(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , u = t._w;
        return this._x = i * u + o * a + r * c - s * l,
        this._y = r * u + o * l + s * a - i * c,
        this._z = s * u + o * c + i * l - r * a,
        this._w = o * u - i * a - r * l - s * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const p = 1 - t;
            return this._w = p * o + t * this._w,
            this._x = p * i + t * this._x,
            this._y = p * r + t * this._y,
            this._z = p * s + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const c = Math.sqrt(l)
          , u = Math.atan2(c, a)
          , h = Math.sin((1 - t) * u) / c
          , f = Math.sin(t * u) / c;
        return this._w = o * h + this._w * f,
        this._x = i * h + this._x * f,
        this._y = r * h + this._y * f,
        this._z = s * h + this._z * f,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , i = Math.sqrt(e)
          , r = 2 * Math.PI * Math.random()
          , s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class H {
    constructor(e=0, t=0, i=0) {
        H.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(zf.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(zf.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = l * t + o * r - a * i
          , u = l * i + a * t - s * r
          , h = l * r + s * i - o * t
          , f = -s * t - o * i - a * r;
        return this.x = c * l + f * -s + u * -a - h * -o,
        this.y = u * l + f * -o + h * -s - c * -a,
        this.z = h * l + f * -a + c * -o - u * -s,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = r * l - s * a,
        this.y = s * o - i * l,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return vl.copy(this).projectOnVector(e),
        this.sub(vl)
    }
    reflect(e) {
        return this.sub(vl.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(vt(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t),
        this.y = i * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const vl = new H
  , zf = new Ys;
class Yr {
    constructor(e=new H(1 / 0,1 / 0,1 / 0), t=new H(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(Fn.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(Fn.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = Fn.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        if (e.updateWorldMatrix(!1, !1),
        e.boundingBox !== void 0)
            e.boundingBox === null && e.computeBoundingBox(),
            Ji.copy(e.boundingBox),
            Ji.applyMatrix4(e.matrixWorld),
            this.union(Ji);
        else {
            const r = e.geometry;
            if (r !== void 0)
                if (t && r.attributes !== void 0 && r.attributes.position !== void 0) {
                    const s = r.attributes.position;
                    for (let o = 0, a = s.count; o < a; o++)
                        Fn.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                        this.expandByPoint(Fn)
                } else
                    r.boundingBox === null && r.computeBoundingBox(),
                    Ji.copy(r.boundingBox),
                    Ji.applyMatrix4(e.matrixWorld),
                    this.union(Ji)
        }
        const i = e.children;
        for (let r = 0, s = i.length; r < s; r++)
            this.expandByObject(i[r], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Fn),
        Fn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(is),
        fo.subVectors(this.max, is),
        Zi.subVectors(e.a, is),
        Qi.subVectors(e.b, is),
        er.subVectors(e.c, is),
        si.subVectors(Qi, Zi),
        oi.subVectors(er, Qi),
        Ai.subVectors(Zi, er);
        let t = [0, -si.z, si.y, 0, -oi.z, oi.y, 0, -Ai.z, Ai.y, si.z, 0, -si.x, oi.z, 0, -oi.x, Ai.z, 0, -Ai.x, -si.y, si.x, 0, -oi.y, oi.x, 0, -Ai.y, Ai.x, 0];
        return !xl(t, Zi, Qi, er, fo) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !xl(t, Zi, Qi, er, fo)) ? !1 : (po.crossVectors(si, oi),
        t = [po.x, po.y, po.z],
        xl(t, Zi, Qi, er, fo))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Fn).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Fn).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Nn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Nn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Nn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Nn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Nn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Nn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Nn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Nn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Nn),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Nn = [new H, new H, new H, new H, new H, new H, new H, new H]
  , Fn = new H
  , Ji = new Yr
  , Zi = new H
  , Qi = new H
  , er = new H
  , si = new H
  , oi = new H
  , Ai = new H
  , is = new H
  , fo = new H
  , po = new H
  , Ri = new H;
function xl(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        Ri.fromArray(n, s);
        const a = r.x * Math.abs(Ri.x) + r.y * Math.abs(Ri.y) + r.z * Math.abs(Ri.z)
          , l = e.dot(Ri)
          , c = t.dot(Ri)
          , u = i.dot(Ri);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
            return !1
    }
    return !0
}
const zS = new Yr
  , rs = new H
  , yl = new H;
class Ua {
    constructor(e=new H, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : zS.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        rs.subVectors(e, this.center);
        const t = rs.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(rs, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (yl.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(rs.copy(e.center).add(yl)),
        this.expandByPoint(rs.copy(e.center).sub(yl))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const On = new H
  , Ml = new H
  , mo = new H
  , ai = new H
  , Sl = new H
  , go = new H
  , El = new H;
class _u {
    constructor(e=new H, t=new H(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, On)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = On.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (On.copy(this.origin).addScaledVector(this.direction, t),
        On.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        Ml.copy(e).add(t).multiplyScalar(.5),
        mo.copy(t).sub(e).normalize(),
        ai.copy(this.origin).sub(Ml);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(mo)
          , a = ai.dot(this.direction)
          , l = -ai.dot(mo)
          , c = ai.lengthSq()
          , u = Math.abs(1 - o * o);
        let h, f, p, g;
        if (u > 0)
            if (h = o * l - a,
            f = o * a - l,
            g = s * u,
            h >= 0)
                if (f >= -g)
                    if (f <= g) {
                        const x = 1 / u;
                        h *= x,
                        f *= x,
                        p = h * (h + o * f + 2 * a) + f * (o * h + f + 2 * l) + c
                    } else
                        f = s,
                        h = Math.max(0, -(o * f + a)),
                        p = -h * h + f * (f + 2 * l) + c;
                else
                    f = -s,
                    h = Math.max(0, -(o * f + a)),
                    p = -h * h + f * (f + 2 * l) + c;
            else
                f <= -g ? (h = Math.max(0, -(-o * s + a)),
                f = h > 0 ? -s : Math.min(Math.max(-s, -l), s),
                p = -h * h + f * (f + 2 * l) + c) : f <= g ? (h = 0,
                f = Math.min(Math.max(-s, -l), s),
                p = f * (f + 2 * l) + c) : (h = Math.max(0, -(o * s + a)),
                f = h > 0 ? s : Math.min(Math.max(-s, -l), s),
                p = -h * h + f * (f + 2 * l) + c);
        else
            f = o > 0 ? -s : s,
            h = Math.max(0, -(o * f + a)),
            p = -h * h + f * (f + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, h),
        r && r.copy(Ml).addScaledVector(mo, f),
        p
    }
    intersectSphere(e, t) {
        On.subVectors(e.center, this.origin);
        const i = On.dot(this.direction)
          , r = On.dot(On) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, l;
        const c = 1 / this.direction.x
          , u = 1 / this.direction.y
          , h = 1 / this.direction.z
          , f = this.origin;
        return c >= 0 ? (i = (e.min.x - f.x) * c,
        r = (e.max.x - f.x) * c) : (i = (e.max.x - f.x) * c,
        r = (e.min.x - f.x) * c),
        u >= 0 ? (s = (e.min.y - f.y) * u,
        o = (e.max.y - f.y) * u) : (s = (e.max.y - f.y) * u,
        o = (e.min.y - f.y) * u),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        h >= 0 ? (a = (e.min.z - f.z) * h,
        l = (e.max.z - f.z) * h) : (a = (e.max.z - f.z) * h,
        l = (e.min.z - f.z) * h),
        i > l || a > r) || ((a > i || i !== i) && (i = a),
        (l < r || r !== r) && (r = l),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, On) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        Sl.subVectors(t, e),
        go.subVectors(i, e),
        El.crossVectors(Sl, go);
        let o = this.direction.dot(El), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        ai.subVectors(this.origin, e);
        const l = a * this.direction.dot(go.crossVectors(ai, go));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(Sl.cross(ai));
        if (c < 0 || l + c > o)
            return null;
        const u = -a * ai.dot(El);
        return u < 0 ? null : this.at(u / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class ht {
    constructor(e, t, i, r, s, o, a, l, c, u, h, f, p, g, x, m) {
        ht.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, l, c, u, h, f, p, g, x, m)
    }
    set(e, t, i, r, s, o, a, l, c, u, h, f, p, g, x, m) {
        const d = this.elements;
        return d[0] = e,
        d[4] = t,
        d[8] = i,
        d[12] = r,
        d[1] = s,
        d[5] = o,
        d[9] = a,
        d[13] = l,
        d[2] = c,
        d[6] = u,
        d[10] = h,
        d[14] = f,
        d[3] = p,
        d[7] = g,
        d[11] = x,
        d[15] = m,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new ht().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / tr.setFromMatrixColumn(e, 0).length()
          , s = 1 / tr.setFromMatrixColumn(e, 1).length()
          , o = 1 / tr.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(r)
          , c = Math.sin(r)
          , u = Math.cos(s)
          , h = Math.sin(s);
        if (e.order === "XYZ") {
            const f = o * u
              , p = o * h
              , g = a * u
              , x = a * h;
            t[0] = l * u,
            t[4] = -l * h,
            t[8] = c,
            t[1] = p + g * c,
            t[5] = f - x * c,
            t[9] = -a * l,
            t[2] = x - f * c,
            t[6] = g + p * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const f = l * u
              , p = l * h
              , g = c * u
              , x = c * h;
            t[0] = f + x * a,
            t[4] = g * a - p,
            t[8] = o * c,
            t[1] = o * h,
            t[5] = o * u,
            t[9] = -a,
            t[2] = p * a - g,
            t[6] = x + f * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const f = l * u
              , p = l * h
              , g = c * u
              , x = c * h;
            t[0] = f - x * a,
            t[4] = -o * h,
            t[8] = g + p * a,
            t[1] = p + g * a,
            t[5] = o * u,
            t[9] = x - f * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const f = o * u
              , p = o * h
              , g = a * u
              , x = a * h;
            t[0] = l * u,
            t[4] = g * c - p,
            t[8] = f * c + x,
            t[1] = l * h,
            t[5] = x * c + f,
            t[9] = p * c - g,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const f = o * l
              , p = o * c
              , g = a * l
              , x = a * c;
            t[0] = l * u,
            t[4] = x - f * h,
            t[8] = g * h + p,
            t[1] = h,
            t[5] = o * u,
            t[9] = -a * u,
            t[2] = -c * u,
            t[6] = p * h + g,
            t[10] = f - x * h
        } else if (e.order === "XZY") {
            const f = o * l
              , p = o * c
              , g = a * l
              , x = a * c;
            t[0] = l * u,
            t[4] = -h,
            t[8] = c * u,
            t[1] = f * h + x,
            t[5] = o * u,
            t[9] = p * h - g,
            t[2] = g * h - p,
            t[6] = a * u,
            t[10] = x * h + f
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(BS, e, HS)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return jt.subVectors(e, t),
        jt.lengthSq() === 0 && (jt.z = 1),
        jt.normalize(),
        li.crossVectors(i, jt),
        li.lengthSq() === 0 && (Math.abs(i.z) === 1 ? jt.x += 1e-4 : jt.z += 1e-4,
        jt.normalize(),
        li.crossVectors(i, jt)),
        li.normalize(),
        _o.crossVectors(jt, li),
        r[0] = li.x,
        r[4] = _o.x,
        r[8] = jt.x,
        r[1] = li.y,
        r[5] = _o.y,
        r[9] = jt.y,
        r[2] = li.z,
        r[6] = _o.z,
        r[10] = jt.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , c = i[12]
          , u = i[1]
          , h = i[5]
          , f = i[9]
          , p = i[13]
          , g = i[2]
          , x = i[6]
          , m = i[10]
          , d = i[14]
          , v = i[3]
          , _ = i[7]
          , M = i[11]
          , b = i[15]
          , A = r[0]
          , C = r[4]
          , P = r[8]
          , S = r[12]
          , T = r[1]
          , F = r[5]
          , k = r[9]
          , X = r[13]
          , L = r[2]
          , G = r[6]
          , V = r[10]
          , $ = r[14]
          , re = r[3]
          , ee = r[7]
          , le = r[11]
          , B = r[15];
        return s[0] = o * A + a * T + l * L + c * re,
        s[4] = o * C + a * F + l * G + c * ee,
        s[8] = o * P + a * k + l * V + c * le,
        s[12] = o * S + a * X + l * $ + c * B,
        s[1] = u * A + h * T + f * L + p * re,
        s[5] = u * C + h * F + f * G + p * ee,
        s[9] = u * P + h * k + f * V + p * le,
        s[13] = u * S + h * X + f * $ + p * B,
        s[2] = g * A + x * T + m * L + d * re,
        s[6] = g * C + x * F + m * G + d * ee,
        s[10] = g * P + x * k + m * V + d * le,
        s[14] = g * S + x * X + m * $ + d * B,
        s[3] = v * A + _ * T + M * L + b * re,
        s[7] = v * C + _ * F + M * G + b * ee,
        s[11] = v * P + _ * k + M * V + b * le,
        s[15] = v * S + _ * X + M * $ + b * B,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , u = e[2]
          , h = e[6]
          , f = e[10]
          , p = e[14]
          , g = e[3]
          , x = e[7]
          , m = e[11]
          , d = e[15];
        return g * (+s * l * h - r * c * h - s * a * f + i * c * f + r * a * p - i * l * p) + x * (+t * l * p - t * c * f + s * o * f - r * o * p + r * c * u - s * l * u) + m * (+t * c * h - t * a * p - s * o * h + i * o * p + s * a * u - i * c * u) + d * (-r * a * u - t * l * h + t * a * f + r * o * h - i * o * f + i * l * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , h = e[9]
          , f = e[10]
          , p = e[11]
          , g = e[12]
          , x = e[13]
          , m = e[14]
          , d = e[15]
          , v = h * m * c - x * f * c + x * l * p - a * m * p - h * l * d + a * f * d
          , _ = g * f * c - u * m * c - g * l * p + o * m * p + u * l * d - o * f * d
          , M = u * x * c - g * h * c + g * a * p - o * x * p - u * a * d + o * h * d
          , b = g * h * l - u * x * l - g * a * f + o * x * f + u * a * m - o * h * m
          , A = t * v + i * _ + r * M + s * b;
        if (A === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const C = 1 / A;
        return e[0] = v * C,
        e[1] = (x * f * s - h * m * s - x * r * p + i * m * p + h * r * d - i * f * d) * C,
        e[2] = (a * m * s - x * l * s + x * r * c - i * m * c - a * r * d + i * l * d) * C,
        e[3] = (h * l * s - a * f * s - h * r * c + i * f * c + a * r * p - i * l * p) * C,
        e[4] = _ * C,
        e[5] = (u * m * s - g * f * s + g * r * p - t * m * p - u * r * d + t * f * d) * C,
        e[6] = (g * l * s - o * m * s - g * r * c + t * m * c + o * r * d - t * l * d) * C,
        e[7] = (o * f * s - u * l * s + u * r * c - t * f * c - o * r * p + t * l * p) * C,
        e[8] = M * C,
        e[9] = (g * h * s - u * x * s - g * i * p + t * x * p + u * i * d - t * h * d) * C,
        e[10] = (o * x * s - g * a * s + g * i * c - t * x * c - o * i * d + t * a * d) * C,
        e[11] = (u * a * s - o * h * s - u * i * c + t * h * c + o * i * p - t * a * p) * C,
        e[12] = b * C,
        e[13] = (u * x * r - g * h * r + g * i * f - t * x * f - u * i * m + t * h * m) * C,
        e[14] = (g * a * r - o * x * r - g * i * l + t * x * l + o * i * m - t * a * m) * C,
        e[15] = (o * h * r - u * a * r + u * i * l - t * h * l - o * i * f + t * a * f) * C,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , c = s * o
          , u = s * a;
        return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, u * a + i, u * l - r * o, 0, c * l - r * a, u * l + r * o, s * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = s + s
          , u = o + o
          , h = a + a
          , f = s * c
          , p = s * u
          , g = s * h
          , x = o * u
          , m = o * h
          , d = a * h
          , v = l * c
          , _ = l * u
          , M = l * h
          , b = i.x
          , A = i.y
          , C = i.z;
        return r[0] = (1 - (x + d)) * b,
        r[1] = (p + M) * b,
        r[2] = (g - _) * b,
        r[3] = 0,
        r[4] = (p - M) * A,
        r[5] = (1 - (f + d)) * A,
        r[6] = (m + v) * A,
        r[7] = 0,
        r[8] = (g + _) * C,
        r[9] = (m - v) * C,
        r[10] = (1 - (f + x)) * C,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = tr.set(r[0], r[1], r[2]).length();
        const o = tr.set(r[4], r[5], r[6]).length()
          , a = tr.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        hn.copy(this);
        const c = 1 / s
          , u = 1 / o
          , h = 1 / a;
        return hn.elements[0] *= c,
        hn.elements[1] *= c,
        hn.elements[2] *= c,
        hn.elements[4] *= u,
        hn.elements[5] *= u,
        hn.elements[6] *= u,
        hn.elements[8] *= h,
        hn.elements[9] *= h,
        hn.elements[10] *= h,
        t.setFromRotationMatrix(hn),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, r, s, o, a=jn) {
        const l = this.elements
          , c = 2 * s / (t - e)
          , u = 2 * s / (i - r)
          , h = (t + e) / (t - e)
          , f = (i + r) / (i - r);
        let p, g;
        if (a === jn)
            p = -(o + s) / (o - s),
            g = -2 * o * s / (o - s);
        else if (a === ua)
            p = -o / (o - s),
            g = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = h,
        l[12] = 0,
        l[1] = 0,
        l[5] = u,
        l[9] = f,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = p,
        l[14] = g,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o, a=jn) {
        const l = this.elements
          , c = 1 / (t - e)
          , u = 1 / (i - r)
          , h = 1 / (o - s)
          , f = (t + e) * c
          , p = (i + r) * u;
        let g, x;
        if (a === jn)
            g = (o + s) * h,
            x = -2 * h;
        else if (a === ua)
            g = s * h,
            x = -1 * h;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -f,
        l[1] = 0,
        l[5] = 2 * u,
        l[9] = 0,
        l[13] = -p,
        l[2] = 0,
        l[6] = 0,
        l[10] = x,
        l[14] = -g,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const tr = new H
  , hn = new ht
  , BS = new H(0,0,0)
  , HS = new H(1,1,1)
  , li = new H
  , _o = new H
  , jt = new H
  , Bf = new ht
  , Hf = new Ys;
class Na {
    constructor(e=0, t=0, i=0, r=Na.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , l = r[1]
          , c = r[5]
          , u = r[9]
          , h = r[2]
          , f = r[6]
          , p = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(vt(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, p),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-vt(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, p),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(vt(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, p),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-vt(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, p),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(vt(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(a, p));
            break;
        case "XZY":
            this._z = Math.asin(-vt(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, p),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return Bf.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Bf, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return Hf.setFromEuler(this),
        this.setFromQuaternion(Hf, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Na.DEFAULT_ORDER = "XYZ";
class vu {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let kS = 0;
const kf = new H
  , nr = new Ys
  , zn = new ht
  , vo = new H
  , ss = new H
  , GS = new H
  , VS = new Ys
  , Gf = new H(1,0,0)
  , Vf = new H(0,1,0)
  , Wf = new H(0,0,1)
  , WS = {
    type: "added"
}
  , XS = {
    type: "removed"
};
class Ct extends Kr {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: kS++
        }),
        this.uuid = qr(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Ct.DEFAULT_UP.clone();
        const e = new H
          , t = new Na
          , i = new Ys
          , r = new H(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new ht
            },
            normalMatrix: {
                value: new $e
            }
        }),
        this.matrix = new ht,
        this.matrixWorld = new ht,
        this.matrixAutoUpdate = Ct.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = Ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.layers = new vu,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return nr.setFromAxisAngle(e, t),
        this.quaternion.multiply(nr),
        this
    }
    rotateOnWorldAxis(e, t) {
        return nr.setFromAxisAngle(e, t),
        this.quaternion.premultiply(nr),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(Gf, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(Vf, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Wf, e)
    }
    translateOnAxis(e, t) {
        return kf.copy(e).applyQuaternion(this.quaternion),
        this.position.add(kf.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(Gf, e)
    }
    translateY(e) {
        return this.translateOnAxis(Vf, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Wf, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(zn.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? vo.copy(e) : vo.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        ss.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? zn.lookAt(ss, vo, this.up) : zn.lookAt(vo, ss, this.up),
        this.quaternion.setFromRotationMatrix(zn),
        r && (zn.extractRotation(r.matrixWorld),
        nr.setFromRotationMatrix(zn),
        this.quaternion.premultiply(nr.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(WS)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(XS)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        zn.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        zn.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(zn),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t) {
        let i = [];
        this[e] === t && i.push(this);
        for (let r = 0, s = this.children.length; r < s; r++) {
            const o = this.children[r].getObjectsByProperty(e, t);
            o.length > 0 && (i = i.concat(o))
        }
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(ss, e, GS),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(ss, VS, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const h = l[c];
                        s(e.shapes, h)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(e.materials, this.material[l]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , u = o(e.images)
              , h = o(e.shapes)
              , f = o(e.skeletons)
              , p = o(e.animations)
              , g = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            u.length > 0 && (i.images = u),
            h.length > 0 && (i.shapes = h),
            f.length > 0 && (i.skeletons = f),
            p.length > 0 && (i.animations = p),
            g.length > 0 && (i.nodes = g)
        }
        return i.object = r,
        i;
        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata,
                l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
Ct.DEFAULT_UP = new H(0,1,0);
Ct.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const fn = new H
  , Bn = new H
  , bl = new H
  , Hn = new H
  , ir = new H
  , rr = new H
  , Xf = new H
  , Tl = new H
  , wl = new H
  , Al = new H;
let xo = !1;
class pn {
    constructor(e=new H, t=new H, i=new H) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        fn.subVectors(e, t),
        r.cross(fn);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        fn.subVectors(r, t),
        Bn.subVectors(i, t),
        bl.subVectors(e, t);
        const o = fn.dot(fn)
          , a = fn.dot(Bn)
          , l = fn.dot(bl)
          , c = Bn.dot(Bn)
          , u = Bn.dot(bl)
          , h = o * c - a * a;
        if (h === 0)
            return s.set(-2, -1, -1);
        const f = 1 / h
          , p = (c * l - a * u) * f
          , g = (o * u - a * l) * f;
        return s.set(1 - p - g, g, p)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, Hn),
        Hn.x >= 0 && Hn.y >= 0 && Hn.x + Hn.y <= 1
    }
    static getUV(e, t, i, r, s, o, a, l) {
        return xo === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        xo = !0),
        this.getInterpolation(e, t, i, r, s, o, a, l)
    }
    static getInterpolation(e, t, i, r, s, o, a, l) {
        return this.getBarycoord(e, t, i, r, Hn),
        l.setScalar(0),
        l.addScaledVector(s, Hn.x),
        l.addScaledVector(o, Hn.y),
        l.addScaledVector(a, Hn.z),
        l
    }
    static isFrontFacing(e, t, i, r) {
        return fn.subVectors(i, t),
        Bn.subVectors(e, t),
        fn.cross(Bn).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return fn.subVectors(this.c, this.b),
        Bn.subVectors(this.a, this.b),
        fn.cross(Bn).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return pn.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return pn.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, r, s) {
        return xo === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        xo = !0),
        pn.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    getInterpolation(e, t, i, r, s) {
        return pn.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return pn.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return pn.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        ir.subVectors(r, i),
        rr.subVectors(s, i),
        Tl.subVectors(e, i);
        const l = ir.dot(Tl)
          , c = rr.dot(Tl);
        if (l <= 0 && c <= 0)
            return t.copy(i);
        wl.subVectors(e, r);
        const u = ir.dot(wl)
          , h = rr.dot(wl);
        if (u >= 0 && h <= u)
            return t.copy(r);
        const f = l * h - u * c;
        if (f <= 0 && l >= 0 && u <= 0)
            return o = l / (l - u),
            t.copy(i).addScaledVector(ir, o);
        Al.subVectors(e, s);
        const p = ir.dot(Al)
          , g = rr.dot(Al);
        if (g >= 0 && p <= g)
            return t.copy(s);
        const x = p * c - l * g;
        if (x <= 0 && c >= 0 && g <= 0)
            return a = c / (c - g),
            t.copy(i).addScaledVector(rr, a);
        const m = u * g - p * h;
        if (m <= 0 && h - u >= 0 && p - g >= 0)
            return Xf.subVectors(s, r),
            a = (h - u) / (h - u + (p - g)),
            t.copy(r).addScaledVector(Xf, a);
        const d = 1 / (m + x + f);
        return o = x * d,
        a = f * d,
        t.copy(i).addScaledVector(ir, o).addScaledVector(rr, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let $S = 0;
class Mi extends Kr {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: $S++
        }),
        this.uuid = qr(),
        this.name = "",
        this.type = "Material",
        this.blending = Cr,
        this.side = Jn,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = Am,
        this.blendDst = Rm,
        this.blendEquation = gr,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = yc,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = SS,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = fl,
        this.stencilZFail = fl,
        this.stencilZPass = fl,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Cr && (i.blending = this.blending),
        this.side !== Jn && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        i.depthFunc = this.depthFunc,
        i.depthTest = this.depthTest,
        i.depthWrite = this.depthWrite,
        i.colorWrite = this.colorWrite,
        i.stencilWrite = this.stencilWrite,
        i.stencilWriteMask = this.stencilWriteMask,
        i.stencilFunc = this.stencilFunc,
        i.stencilRef = this.stencilRef,
        i.stencilFuncMask = this.stencilFuncMask,
        i.stencilFail = this.stencilFail,
        i.stencilZFail = this.stencilZFail,
        i.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
const Gm = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , ci = {
    h: 0,
    s: 0,
    l: 0
}
  , yo = {
    h: 0,
    s: 0,
    l: 0
};
function Rl(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Xe {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else
            this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=At) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        et.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=et.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        et.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=et.workingColorSpace) {
        if (e = LS(e, 1),
        t = vt(t, 0, 1),
        i = vt(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = Rl(o, s, e + 1 / 3),
            this.g = Rl(o, s, e),
            this.b = Rl(o, s, e - 1 / 3)
        }
        return et.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=At) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=At) {
        const i = Gm[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Pr(e.r),
        this.g = Pr(e.g),
        this.b = Pr(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = gl(e.r),
        this.g = gl(e.g),
        this.b = gl(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=At) {
        return et.fromWorkingColorSpace(Lt.copy(this), e),
        Math.round(vt(Lt.r * 255, 0, 255)) * 65536 + Math.round(vt(Lt.g * 255, 0, 255)) * 256 + Math.round(vt(Lt.b * 255, 0, 255))
    }
    getHexString(e=At) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=et.workingColorSpace) {
        et.fromWorkingColorSpace(Lt.copy(this), t);
        const i = Lt.r
          , r = Lt.g
          , s = Lt.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let l, c;
        const u = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const h = o - a;
            switch (c = u <= .5 ? h / (o + a) : h / (2 - o - a),
            o) {
            case i:
                l = (r - s) / h + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - i) / h + 2;
                break;
            case s:
                l = (i - r) / h + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = u,
        e
    }
    getRGB(e, t=et.workingColorSpace) {
        return et.fromWorkingColorSpace(Lt.copy(this), t),
        e.r = Lt.r,
        e.g = Lt.g,
        e.b = Lt.b,
        e
    }
    getStyle(e=At) {
        et.fromWorkingColorSpace(Lt.copy(this), e);
        const t = Lt.r
          , i = Lt.g
          , r = Lt.b;
        return e !== At ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(ci),
        this.setHSL(ci.h + e, ci.s + t, ci.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(ci),
        e.getHSL(yo);
        const i = pl(ci.h, yo.h, t)
          , r = pl(ci.s, yo.s, t)
          , s = pl(ci.l, yo.l, t);
        return this.setHSL(i, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * r,
        this.g = s[1] * t + s[4] * i + s[7] * r,
        this.b = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Lt = new Xe;
Xe.NAMES = Gm;
class Vm extends Mi {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Xe(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Cm,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Xn = jS();
function jS() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (i[l] = 0,
        i[l | 256] = 32768,
        r[l] = 24,
        r[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14,
        i[l | 256] = 1024 >> -c - 14 | 32768,
        r[l] = -c - 1,
        r[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10,
        i[l | 256] = c + 15 << 10 | 32768,
        r[l] = 13,
        r[l | 256] = 13) : c < 128 ? (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 24,
        r[l | 256] = 24) : (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 13,
        r[l | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13
          , u = 0;
        for (; !(c & 8388608); )
            c <<= 1,
            u -= 8388608;
        c &= -8388609,
        u += 947912704,
        s[l] = c | u
    }
    for (let l = 1024; l < 2048; ++l)
        s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function KS(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = vt(n, -65504, 65504),
    Xn.floatView[0] = n;
    const e = Xn.uint32View[0]
      , t = e >> 23 & 511;
    return Xn.baseTable[t] + ((e & 8388607) >> Xn.shiftTable[t])
}
function qS(n) {
    const e = n >> 10;
    return Xn.uint32View[0] = Xn.mantissaTable[Xn.offsetTable[e] + (n & 1023)] + Xn.exponentTable[e],
    Xn.floatView[0]
}
const Mo = {
    toHalfFloat: KS,
    fromHalfFloat: qS
}
  , mt = new H
  , So = new xe;
class un {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = Df,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.gpuType = xn,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                So.fromBufferAttribute(this, t),
                So.applyMatrix3(e),
                this.setXY(t, So.x, So.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                mt.fromBufferAttribute(this, t),
                mt.applyMatrix3(e),
                this.setXYZ(t, mt.x, mt.y, mt.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            mt.fromBufferAttribute(this, t),
            mt.applyMatrix4(e),
            this.setXYZ(t, mt.x, mt.y, mt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            mt.fromBufferAttribute(this, t),
            mt.applyNormalMatrix(e),
            this.setXYZ(t, mt.x, mt.y, mt.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            mt.fromBufferAttribute(this, t),
            mt.transformDirection(e),
            this.setXYZ(t, mt.x, mt.y, mt.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = ns(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = Ht(i, this.array)),
        this.array[e * this.itemSize + t] = i,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = ns(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Ht(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = ns(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Ht(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = ns(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Ht(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = ns(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Ht(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = Ht(t, this.array),
        i = Ht(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = Ht(t, this.array),
        i = Ht(i, this.array),
        r = Ht(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = Ht(t, this.array),
        i = Ht(i, this.array),
        r = Ht(r, this.array),
        s = Ht(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Df && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
}
class Wm extends un {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class Xm extends un {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class Tt extends un {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let YS = 0;
const tn = new ht
  , Cl = new Ct
  , sr = new H
  , Kt = new Yr
  , os = new Yr
  , Mt = new H;
class Zt extends Kr {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: YS++
        }),
        this.uuid = qr(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (zm(e) ? Xm : Wm)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new $e().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return tn.makeRotationFromQuaternion(e),
        this.applyMatrix4(tn),
        this
    }
    rotateX(e) {
        return tn.makeRotationX(e),
        this.applyMatrix4(tn),
        this
    }
    rotateY(e) {
        return tn.makeRotationY(e),
        this.applyMatrix4(tn),
        this
    }
    rotateZ(e) {
        return tn.makeRotationZ(e),
        this.applyMatrix4(tn),
        this
    }
    translate(e, t, i) {
        return tn.makeTranslation(e, t, i),
        this.applyMatrix4(tn),
        this
    }
    scale(e, t, i) {
        return tn.makeScale(e, t, i),
        this.applyMatrix4(tn),
        this
    }
    lookAt(e) {
        return Cl.lookAt(e),
        Cl.updateMatrix(),
        this.applyMatrix4(Cl.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(sr).negate(),
        this.translate(sr.x, sr.y, sr.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new Tt(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Yr);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new H(-1 / 0,-1 / 0,-1 / 0), new H(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Kt.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (Mt.addVectors(this.boundingBox.min, Kt.min),
                    this.boundingBox.expandByPoint(Mt),
                    Mt.addVectors(this.boundingBox.max, Kt.max),
                    this.boundingBox.expandByPoint(Mt)) : (this.boundingBox.expandByPoint(Kt.min),
                    this.boundingBox.expandByPoint(Kt.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Ua);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new H, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Kt.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    os.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Mt.addVectors(Kt.min, os.min),
                    Kt.expandByPoint(Mt),
                    Mt.addVectors(Kt.max, os.max),
                    Kt.expandByPoint(Mt)) : (Kt.expandByPoint(os.min),
                    Kt.expandByPoint(os.max))
                }
            Kt.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Mt.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared(Mt));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++)
                        Mt.fromBufferAttribute(a, c),
                        l && (sr.fromBufferAttribute(e, c),
                        Mt.add(sr)),
                        r = Math.max(r, i.distanceToSquared(Mt))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array
          , r = t.position.array
          , s = t.normal.array
          , o = t.uv.array
          , a = r.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new un(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , c = []
          , u = [];
        for (let T = 0; T < a; T++)
            c[T] = new H,
            u[T] = new H;
        const h = new H
          , f = new H
          , p = new H
          , g = new xe
          , x = new xe
          , m = new xe
          , d = new H
          , v = new H;
        function _(T, F, k) {
            h.fromArray(r, T * 3),
            f.fromArray(r, F * 3),
            p.fromArray(r, k * 3),
            g.fromArray(o, T * 2),
            x.fromArray(o, F * 2),
            m.fromArray(o, k * 2),
            f.sub(h),
            p.sub(h),
            x.sub(g),
            m.sub(g);
            const X = 1 / (x.x * m.y - m.x * x.y);
            isFinite(X) && (d.copy(f).multiplyScalar(m.y).addScaledVector(p, -x.y).multiplyScalar(X),
            v.copy(p).multiplyScalar(x.x).addScaledVector(f, -m.x).multiplyScalar(X),
            c[T].add(d),
            c[F].add(d),
            c[k].add(d),
            u[T].add(v),
            u[F].add(v),
            u[k].add(v))
        }
        let M = this.groups;
        M.length === 0 && (M = [{
            start: 0,
            count: i.length
        }]);
        for (let T = 0, F = M.length; T < F; ++T) {
            const k = M[T]
              , X = k.start
              , L = k.count;
            for (let G = X, V = X + L; G < V; G += 3)
                _(i[G + 0], i[G + 1], i[G + 2])
        }
        const b = new H
          , A = new H
          , C = new H
          , P = new H;
        function S(T) {
            C.fromArray(s, T * 3),
            P.copy(C);
            const F = c[T];
            b.copy(F),
            b.sub(C.multiplyScalar(C.dot(F))).normalize(),
            A.crossVectors(P, F);
            const X = A.dot(u[T]) < 0 ? -1 : 1;
            l[T * 4] = b.x,
            l[T * 4 + 1] = b.y,
            l[T * 4 + 2] = b.z,
            l[T * 4 + 3] = X
        }
        for (let T = 0, F = M.length; T < F; ++T) {
            const k = M[T]
              , X = k.start
              , L = k.count;
            for (let G = X, V = X + L; G < V; G += 3)
                S(i[G + 0]),
                S(i[G + 1]),
                S(i[G + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new un(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let f = 0, p = i.count; f < p; f++)
                    i.setXYZ(f, 0, 0, 0);
            const r = new H
              , s = new H
              , o = new H
              , a = new H
              , l = new H
              , c = new H
              , u = new H
              , h = new H;
            if (e)
                for (let f = 0, p = e.count; f < p; f += 3) {
                    const g = e.getX(f + 0)
                      , x = e.getX(f + 1)
                      , m = e.getX(f + 2);
                    r.fromBufferAttribute(t, g),
                    s.fromBufferAttribute(t, x),
                    o.fromBufferAttribute(t, m),
                    u.subVectors(o, s),
                    h.subVectors(r, s),
                    u.cross(h),
                    a.fromBufferAttribute(i, g),
                    l.fromBufferAttribute(i, x),
                    c.fromBufferAttribute(i, m),
                    a.add(u),
                    l.add(u),
                    c.add(u),
                    i.setXYZ(g, a.x, a.y, a.z),
                    i.setXYZ(x, l.x, l.y, l.z),
                    i.setXYZ(m, c.x, c.y, c.z)
                }
            else
                for (let f = 0, p = t.count; f < p; f += 3)
                    r.fromBufferAttribute(t, f + 0),
                    s.fromBufferAttribute(t, f + 1),
                    o.fromBufferAttribute(t, f + 2),
                    u.subVectors(o, s),
                    h.subVectors(r, s),
                    u.cross(h),
                    i.setXYZ(f + 0, u.x, u.y, u.z),
                    i.setXYZ(f + 1, u.x, u.y, u.z),
                    i.setXYZ(f + 2, u.x, u.y, u.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            Mt.fromBufferAttribute(e, t),
            Mt.normalize(),
            e.setXYZ(t, Mt.x, Mt.y, Mt.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , u = a.itemSize
              , h = a.normalized
              , f = new c.constructor(l.length * u);
            let p = 0
              , g = 0;
            for (let x = 0, m = l.length; x < m; x++) {
                a.isInterleavedBufferAttribute ? p = l[x] * a.data.stride + a.offset : p = l[x] * u;
                for (let d = 0; d < u; d++)
                    f[g++] = c[p++]
            }
            return new un(f,u,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Zt
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const l = r[a]
              , c = e(l, i);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , c = s[a];
            for (let u = 0, h = c.length; u < h; u++) {
                const f = c[u]
                  , p = e(f, i);
                l.push(p)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , u = [];
            for (let h = 0, f = c.length; h < f; h++) {
                const p = c[h];
                u.push(p.toJSON(e.data))
            }
            u.length > 0 && (r[l] = u,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const c in r) {
            const u = r[c];
            this.setAttribute(c, u.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const u = []
              , h = s[c];
            for (let f = 0, p = h.length; f < p; f++)
                u.push(h[f].clone(t));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const h = o[c];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const $f = new ht
  , Ci = new _u
  , Eo = new Ua
  , jf = new H
  , or = new H
  , ar = new H
  , lr = new H
  , Pl = new H
  , bo = new H
  , To = new xe
  , wo = new xe
  , Ao = new xe
  , Kf = new H
  , qf = new H
  , Yf = new H
  , Ro = new H
  , Co = new H;
class Vt extends Ct {
    constructor(e=new Zt, t=new Vm) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            bo.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const u = a[l]
                  , h = s[l];
                u !== 0 && (Pl.fromBufferAttribute(h, e),
                o ? bo.addScaledVector(Pl, u) : bo.addScaledVector(Pl.sub(t), u))
            }
            t.add(bo)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        Eo.copy(i.boundingSphere),
        Eo.applyMatrix4(s),
        Ci.copy(e.ray).recast(e.near),
        !(Eo.containsPoint(Ci.origin) === !1 && (Ci.intersectSphere(Eo, jf) === null || Ci.origin.distanceToSquared(jf) > (e.far - e.near) ** 2)) && ($f.copy(s).invert(),
        Ci.copy(e.ray).applyMatrix4($f),
        !(i.boundingBox !== null && Ci.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Ci)))
    }
    _computeIntersections(e, t, i) {
        let r;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , l = s.attributes.position
          , c = s.attributes.uv
          , u = s.attributes.uv1
          , h = s.attributes.normal
          , f = s.groups
          , p = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let g = 0, x = f.length; g < x; g++) {
                    const m = f[g]
                      , d = o[m.materialIndex]
                      , v = Math.max(m.start, p.start)
                      , _ = Math.min(a.count, Math.min(m.start + m.count, p.start + p.count));
                    for (let M = v, b = _; M < b; M += 3) {
                        const A = a.getX(M)
                          , C = a.getX(M + 1)
                          , P = a.getX(M + 2);
                        r = Po(this, d, e, i, c, u, h, A, C, P),
                        r && (r.faceIndex = Math.floor(M / 3),
                        r.face.materialIndex = m.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const g = Math.max(0, p.start)
                  , x = Math.min(a.count, p.start + p.count);
                for (let m = g, d = x; m < d; m += 3) {
                    const v = a.getX(m)
                      , _ = a.getX(m + 1)
                      , M = a.getX(m + 2);
                    r = Po(this, o, e, i, c, u, h, v, _, M),
                    r && (r.faceIndex = Math.floor(m / 3),
                    t.push(r))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let g = 0, x = f.length; g < x; g++) {
                    const m = f[g]
                      , d = o[m.materialIndex]
                      , v = Math.max(m.start, p.start)
                      , _ = Math.min(l.count, Math.min(m.start + m.count, p.start + p.count));
                    for (let M = v, b = _; M < b; M += 3) {
                        const A = M
                          , C = M + 1
                          , P = M + 2;
                        r = Po(this, d, e, i, c, u, h, A, C, P),
                        r && (r.faceIndex = Math.floor(M / 3),
                        r.face.materialIndex = m.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const g = Math.max(0, p.start)
                  , x = Math.min(l.count, p.start + p.count);
                for (let m = g, d = x; m < d; m += 3) {
                    const v = m
                      , _ = m + 1
                      , M = m + 2;
                    r = Po(this, o, e, i, c, u, h, v, _, M),
                    r && (r.faceIndex = Math.floor(m / 3),
                    t.push(r))
                }
            }
    }
}
function JS(n, e, t, i, r, s, o, a) {
    let l;
    if (e.side === Wt ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === Jn, a),
    l === null)
        return null;
    Co.copy(a),
    Co.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo(Co);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Co.clone(),
        object: n
    }
}
function Po(n, e, t, i, r, s, o, a, l, c) {
    n.getVertexPosition(a, or),
    n.getVertexPosition(l, ar),
    n.getVertexPosition(c, lr);
    const u = JS(n, e, t, i, or, ar, lr, Ro);
    if (u) {
        r && (To.fromBufferAttribute(r, a),
        wo.fromBufferAttribute(r, l),
        Ao.fromBufferAttribute(r, c),
        u.uv = pn.getInterpolation(Ro, or, ar, lr, To, wo, Ao, new xe)),
        s && (To.fromBufferAttribute(s, a),
        wo.fromBufferAttribute(s, l),
        Ao.fromBufferAttribute(s, c),
        u.uv1 = pn.getInterpolation(Ro, or, ar, lr, To, wo, Ao, new xe),
        u.uv2 = u.uv1),
        o && (Kf.fromBufferAttribute(o, a),
        qf.fromBufferAttribute(o, l),
        Yf.fromBufferAttribute(o, c),
        u.normal = pn.getInterpolation(Ro, or, ar, lr, Kf, qf, Yf, new H),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
        const h = {
            a,
            b: l,
            c,
            normal: new H,
            materialIndex: 0
        };
        pn.getNormal(or, ar, lr, h.normal),
        u.face = h
    }
    return u
}
class Js extends Zt {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , c = []
          , u = []
          , h = [];
        let f = 0
          , p = 0;
        g("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        g("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        g("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        g("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        g("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        g("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new Tt(c,3)),
        this.setAttribute("normal", new Tt(u,3)),
        this.setAttribute("uv", new Tt(h,2));
        function g(x, m, d, v, _, M, b, A, C, P, S) {
            const T = M / C
              , F = b / P
              , k = M / 2
              , X = b / 2
              , L = A / 2
              , G = C + 1
              , V = P + 1;
            let $ = 0
              , re = 0;
            const ee = new H;
            for (let le = 0; le < V; le++) {
                const B = le * F - X;
                for (let J = 0; J < G; J++) {
                    const fe = J * T - k;
                    ee[x] = fe * v,
                    ee[m] = B * _,
                    ee[d] = L,
                    c.push(ee.x, ee.y, ee.z),
                    ee[x] = 0,
                    ee[m] = 0,
                    ee[d] = A > 0 ? 1 : -1,
                    u.push(ee.x, ee.y, ee.z),
                    h.push(J / C),
                    h.push(1 - le / P),
                    $ += 1
                }
            }
            for (let le = 0; le < P; le++)
                for (let B = 0; B < C; B++) {
                    const J = f + B + G * le
                      , fe = f + B + G * (le + 1)
                      , _e = f + (B + 1) + G * (le + 1)
                      , Te = f + (B + 1) + G * le;
                    l.push(J, fe, Te),
                    l.push(fe, _e, Te),
                    re += 6
                }
            a.addGroup(p, re, S),
            p += re,
            f += $
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Js(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Gr(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function Ot(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = Gr(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function ZS(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function $m(n) {
    return n.getRenderTarget() === null ? n.outputColorSpace : et.workingColorSpace
}
const wc = {
    clone: Gr,
    merge: Ot
};
var QS = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , eE = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Zn extends Mi {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = QS,
        this.fragmentShader = eE,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Gr(e.uniforms),
        this.uniformsGroups = ZS(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class jm extends Ct {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new ht,
        this.projectionMatrix = new ht,
        this.projectionMatrixInverse = new ht,
        this.coordinateSystem = jn
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class sn extends jm {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = bc * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(dl * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return bc * 2 * Math.atan(Math.tan(dl * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(dl * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            s += o.offsetX * r / l,
            t -= o.offsetY * i / c,
            r *= o.width / l,
            i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const cr = -90
  , ur = 1;
class tE extends Ct {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new sn(cr,ur,e,t);
        r.layers = this.layers,
        this.add(r);
        const s = new sn(cr,ur,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new sn(cr,ur,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new sn(cr,ur,e,t);
        a.layers = this.layers,
        this.add(a);
        const l = new sn(cr,ur,e,t);
        l.layers = this.layers,
        this.add(l);
        const c = new sn(cr,ur,e,t);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [i,r,s,o,a,l] = t;
        for (const c of t)
            this.remove(c);
        if (e === jn)
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === ua)
            i.up.set(0, -1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: i, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,l,c,u] = this.children
          , h = e.getRenderTarget()
          , f = e.getActiveCubeFace()
          , p = e.getActiveMipmapLevel()
          , g = e.xr.enabled;
        e.xr.enabled = !1;
        const x = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0, r),
        e.render(t, s),
        e.setRenderTarget(i, 1, r),
        e.render(t, o),
        e.setRenderTarget(i, 2, r),
        e.render(t, a),
        e.setRenderTarget(i, 3, r),
        e.render(t, l),
        e.setRenderTarget(i, 4, r),
        e.render(t, c),
        i.texture.generateMipmaps = x,
        e.setRenderTarget(i, 5, r),
        e.render(t, u),
        e.setRenderTarget(h, f, p),
        e.xr.enabled = g,
        i.texture.needsPMREMUpdate = !0
    }
}
class Km extends zt {
    constructor(e, t, i, r, s, o, a, l, c, u) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : zr,
        super(e, t, i, r, s, o, a, l, c, u),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class nE extends Wi {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        t.encoding !== void 0 && (Es("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
        t.colorSpace = t.encoding === Gi ? At : on),
        this.texture = new Km(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Rt
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new Js(5,5,5)
          , s = new Zn({
            name: "CubemapFromEquirect",
            uniforms: Gr(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Wt,
            blending: gi
        });
        s.uniforms.tEquirect.value = t;
        const o = new Vt(r,s)
          , a = t.minFilter;
        return t.minFilter === Hr && (t.minFilter = Rt),
        new tE(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const Ll = new H
  , iE = new H
  , rE = new $e;
class Ii {
    constructor(e=new H(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = Ll.subVectors(i, t).cross(iE.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(Ll)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || rE.getNormalMatrix(e)
          , r = this.coplanarPoint(Ll).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Pi = new Ua
  , Lo = new H;
class xu {
    constructor(e=new Ii, t=new Ii, i=new Ii, r=new Ii, s=new Ii, o=new Ii) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t=jn) {
        const i = this.planes
          , r = e.elements
          , s = r[0]
          , o = r[1]
          , a = r[2]
          , l = r[3]
          , c = r[4]
          , u = r[5]
          , h = r[6]
          , f = r[7]
          , p = r[8]
          , g = r[9]
          , x = r[10]
          , m = r[11]
          , d = r[12]
          , v = r[13]
          , _ = r[14]
          , M = r[15];
        if (i[0].setComponents(l - s, f - c, m - p, M - d).normalize(),
        i[1].setComponents(l + s, f + c, m + p, M + d).normalize(),
        i[2].setComponents(l + o, f + u, m + g, M + v).normalize(),
        i[3].setComponents(l - o, f - u, m - g, M - v).normalize(),
        i[4].setComponents(l - a, f - h, m - x, M - _).normalize(),
        t === jn)
            i[5].setComponents(l + a, f + h, m + x, M + _).normalize();
        else if (t === ua)
            i[5].setComponents(a, h, x, _).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Pi.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Pi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Pi)
    }
    intersectsSprite(e) {
        return Pi.center.set(0, 0, 0),
        Pi.radius = .7071067811865476,
        Pi.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Pi)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (Lo.x = r.normal.x > 0 ? e.max.x : e.min.x,
            Lo.y = r.normal.y > 0 ? e.max.y : e.min.y,
            Lo.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(Lo) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function qm() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function sE(n, e) {
    const t = e.isWebGL2
      , i = new WeakMap;
    function r(c, u) {
        const h = c.array
          , f = c.usage
          , p = n.createBuffer();
        n.bindBuffer(u, p),
        n.bufferData(u, h, f),
        c.onUploadCallback();
        let g;
        if (h instanceof Float32Array)
            g = n.FLOAT;
        else if (h instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
                if (t)
                    g = n.HALF_FLOAT;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                g = n.UNSIGNED_SHORT;
        else if (h instanceof Int16Array)
            g = n.SHORT;
        else if (h instanceof Uint32Array)
            g = n.UNSIGNED_INT;
        else if (h instanceof Int32Array)
            g = n.INT;
        else if (h instanceof Int8Array)
            g = n.BYTE;
        else if (h instanceof Uint8Array)
            g = n.UNSIGNED_BYTE;
        else if (h instanceof Uint8ClampedArray)
            g = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: p,
            type: g,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: c.version
        }
    }
    function s(c, u, h) {
        const f = u.array
          , p = u.updateRange;
        n.bindBuffer(h, c),
        p.count === -1 ? n.bufferSubData(h, 0, f) : (t ? n.bufferSubData(h, p.offset * f.BYTES_PER_ELEMENT, f, p.offset, p.count) : n.bufferSubData(h, p.offset * f.BYTES_PER_ELEMENT, f.subarray(p.offset, p.offset + p.count)),
        p.count = -1),
        u.onUploadCallback()
    }
    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data),
        i.get(c)
    }
    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        const u = i.get(c);
        u && (n.deleteBuffer(u.buffer),
        i.delete(c))
    }
    function l(c, u) {
        if (c.isGLBufferAttribute) {
            const f = i.get(c);
            (!f || f.version < c.version) && i.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        const h = i.get(c);
        h === void 0 ? i.set(c, r(c, u)) : h.version < c.version && (s(h.buffer, c, u),
        h.version = c.version)
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class Fa extends Zt {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , l = Math.floor(r)
          , c = a + 1
          , u = l + 1
          , h = e / a
          , f = t / l
          , p = []
          , g = []
          , x = []
          , m = [];
        for (let d = 0; d < u; d++) {
            const v = d * f - o;
            for (let _ = 0; _ < c; _++) {
                const M = _ * h - s;
                g.push(M, -v, 0),
                x.push(0, 0, 1),
                m.push(_ / a),
                m.push(1 - d / l)
            }
        }
        for (let d = 0; d < l; d++)
            for (let v = 0; v < a; v++) {
                const _ = v + c * d
                  , M = v + c * (d + 1)
                  , b = v + 1 + c * (d + 1)
                  , A = v + 1 + c * d;
                p.push(_, M, A),
                p.push(M, b, A)
            }
        this.setIndex(p),
        this.setAttribute("position", new Tt(g,3)),
        this.setAttribute("normal", new Tt(x,3)),
        this.setAttribute("uv", new Tt(m,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Fa(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var oE = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , aE = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , lE = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , cE = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , uE = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , hE = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , fE = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , dE = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , pE = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , mE = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , gE = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , _E = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , vE = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , xE = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , yE = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , ME = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , SE = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , EE = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , bE = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , TE = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , wE = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , AE = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , RE = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , CE = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , PE = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , LE = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , DE = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , IE = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , UE = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , NE = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`
  , FE = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , OE = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , zE = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , BE = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , HE = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , kE = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , GE = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , VE = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , WE = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , XE = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , $E = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , jE = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , KE = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , qE = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , YE = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , JE = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , ZE = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , QE = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , eb = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , tb = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , nb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`
  , ib = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , rb = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal;
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , sb = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , ob = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , ab = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , lb = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , cb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , ub = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , hb = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , fb = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , db = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , pb = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , mb = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , gb = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , _b = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , vb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , xb = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , yb = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , Mb = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , Sb = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , Eb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , bb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Tb = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , wb = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , Ab = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , Rb = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , Cb = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , Pb = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , Lb = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , Db = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , Ib = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , Ub = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , Nb = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , Fb = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , Ob = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , zb = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , Bb = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , Hb = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , kb = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , Gb = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , Vb = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , Wb = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
  , Xb = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , $b = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , jb = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , Kb = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , qb = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , Yb = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , Jb = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , Zb = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , Qb = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , eT = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , tT = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , nT = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const iT = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , rT = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , sT = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , oT = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , aT = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , lT = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , cT = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , uT = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , hT = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , fT = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , dT = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , pT = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , mT = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , gT = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , _T = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , vT = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , xT = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , yT = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , MT = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , ST = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , ET = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , bT = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , TT = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , wT = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , AT = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , RT = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , CT = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , PT = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , LT = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , DT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , IT = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , UT = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , NT = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , FT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , We = {
    alphahash_fragment: oE,
    alphahash_pars_fragment: aE,
    alphamap_fragment: lE,
    alphamap_pars_fragment: cE,
    alphatest_fragment: uE,
    alphatest_pars_fragment: hE,
    aomap_fragment: fE,
    aomap_pars_fragment: dE,
    begin_vertex: pE,
    beginnormal_vertex: mE,
    bsdfs: gE,
    iridescence_fragment: _E,
    bumpmap_pars_fragment: vE,
    clipping_planes_fragment: xE,
    clipping_planes_pars_fragment: yE,
    clipping_planes_pars_vertex: ME,
    clipping_planes_vertex: SE,
    color_fragment: EE,
    color_pars_fragment: bE,
    color_pars_vertex: TE,
    color_vertex: wE,
    common: AE,
    cube_uv_reflection_fragment: RE,
    defaultnormal_vertex: CE,
    displacementmap_pars_vertex: PE,
    displacementmap_vertex: LE,
    emissivemap_fragment: DE,
    emissivemap_pars_fragment: IE,
    colorspace_fragment: UE,
    colorspace_pars_fragment: NE,
    envmap_fragment: FE,
    envmap_common_pars_fragment: OE,
    envmap_pars_fragment: zE,
    envmap_pars_vertex: BE,
    envmap_physical_pars_fragment: JE,
    envmap_vertex: HE,
    fog_vertex: kE,
    fog_pars_vertex: GE,
    fog_fragment: VE,
    fog_pars_fragment: WE,
    gradientmap_pars_fragment: XE,
    lightmap_fragment: $E,
    lightmap_pars_fragment: jE,
    lights_lambert_fragment: KE,
    lights_lambert_pars_fragment: qE,
    lights_pars_begin: YE,
    lights_toon_fragment: ZE,
    lights_toon_pars_fragment: QE,
    lights_phong_fragment: eb,
    lights_phong_pars_fragment: tb,
    lights_physical_fragment: nb,
    lights_physical_pars_fragment: ib,
    lights_fragment_begin: rb,
    lights_fragment_maps: sb,
    lights_fragment_end: ob,
    logdepthbuf_fragment: ab,
    logdepthbuf_pars_fragment: lb,
    logdepthbuf_pars_vertex: cb,
    logdepthbuf_vertex: ub,
    map_fragment: hb,
    map_pars_fragment: fb,
    map_particle_fragment: db,
    map_particle_pars_fragment: pb,
    metalnessmap_fragment: mb,
    metalnessmap_pars_fragment: gb,
    morphcolor_vertex: _b,
    morphnormal_vertex: vb,
    morphtarget_pars_vertex: xb,
    morphtarget_vertex: yb,
    normal_fragment_begin: Mb,
    normal_fragment_maps: Sb,
    normal_pars_fragment: Eb,
    normal_pars_vertex: bb,
    normal_vertex: Tb,
    normalmap_pars_fragment: wb,
    clearcoat_normal_fragment_begin: Ab,
    clearcoat_normal_fragment_maps: Rb,
    clearcoat_pars_fragment: Cb,
    iridescence_pars_fragment: Pb,
    opaque_fragment: Lb,
    packing: Db,
    premultiplied_alpha_fragment: Ib,
    project_vertex: Ub,
    dithering_fragment: Nb,
    dithering_pars_fragment: Fb,
    roughnessmap_fragment: Ob,
    roughnessmap_pars_fragment: zb,
    shadowmap_pars_fragment: Bb,
    shadowmap_pars_vertex: Hb,
    shadowmap_vertex: kb,
    shadowmask_pars_fragment: Gb,
    skinbase_vertex: Vb,
    skinning_pars_vertex: Wb,
    skinning_vertex: Xb,
    skinnormal_vertex: $b,
    specularmap_fragment: jb,
    specularmap_pars_fragment: Kb,
    tonemapping_fragment: qb,
    tonemapping_pars_fragment: Yb,
    transmission_fragment: Jb,
    transmission_pars_fragment: Zb,
    uv_pars_fragment: Qb,
    uv_pars_vertex: eT,
    uv_vertex: tT,
    worldpos_vertex: nT,
    background_vert: iT,
    background_frag: rT,
    backgroundCube_vert: sT,
    backgroundCube_frag: oT,
    cube_vert: aT,
    cube_frag: lT,
    depth_vert: cT,
    depth_frag: uT,
    distanceRGBA_vert: hT,
    distanceRGBA_frag: fT,
    equirect_vert: dT,
    equirect_frag: pT,
    linedashed_vert: mT,
    linedashed_frag: gT,
    meshbasic_vert: _T,
    meshbasic_frag: vT,
    meshlambert_vert: xT,
    meshlambert_frag: yT,
    meshmatcap_vert: MT,
    meshmatcap_frag: ST,
    meshnormal_vert: ET,
    meshnormal_frag: bT,
    meshphong_vert: TT,
    meshphong_frag: wT,
    meshphysical_vert: AT,
    meshphysical_frag: RT,
    meshtoon_vert: CT,
    meshtoon_frag: PT,
    points_vert: LT,
    points_frag: DT,
    shadow_vert: IT,
    shadow_frag: UT,
    sprite_vert: NT,
    sprite_frag: FT
}
  , Me = {
    common: {
        diffuse: {
            value: new Xe(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new $e
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new $e
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new $e
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new $e
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new $e
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new $e
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new $e
        },
        normalScale: {
            value: new xe(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new $e
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new $e
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new $e
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new $e
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Xe(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Xe(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new $e
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new $e
        }
    },
    sprite: {
        diffuse: {
            value: new Xe(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new xe(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new $e
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new $e
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Tn = {
    basic: {
        uniforms: Ot([Me.common, Me.specularmap, Me.envmap, Me.aomap, Me.lightmap, Me.fog]),
        vertexShader: We.meshbasic_vert,
        fragmentShader: We.meshbasic_frag
    },
    lambert: {
        uniforms: Ot([Me.common, Me.specularmap, Me.envmap, Me.aomap, Me.lightmap, Me.emissivemap, Me.bumpmap, Me.normalmap, Me.displacementmap, Me.fog, Me.lights, {
            emissive: {
                value: new Xe(0)
            }
        }]),
        vertexShader: We.meshlambert_vert,
        fragmentShader: We.meshlambert_frag
    },
    phong: {
        uniforms: Ot([Me.common, Me.specularmap, Me.envmap, Me.aomap, Me.lightmap, Me.emissivemap, Me.bumpmap, Me.normalmap, Me.displacementmap, Me.fog, Me.lights, {
            emissive: {
                value: new Xe(0)
            },
            specular: {
                value: new Xe(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: We.meshphong_vert,
        fragmentShader: We.meshphong_frag
    },
    standard: {
        uniforms: Ot([Me.common, Me.envmap, Me.aomap, Me.lightmap, Me.emissivemap, Me.bumpmap, Me.normalmap, Me.displacementmap, Me.roughnessmap, Me.metalnessmap, Me.fog, Me.lights, {
            emissive: {
                value: new Xe(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: We.meshphysical_vert,
        fragmentShader: We.meshphysical_frag
    },
    toon: {
        uniforms: Ot([Me.common, Me.aomap, Me.lightmap, Me.emissivemap, Me.bumpmap, Me.normalmap, Me.displacementmap, Me.gradientmap, Me.fog, Me.lights, {
            emissive: {
                value: new Xe(0)
            }
        }]),
        vertexShader: We.meshtoon_vert,
        fragmentShader: We.meshtoon_frag
    },
    matcap: {
        uniforms: Ot([Me.common, Me.bumpmap, Me.normalmap, Me.displacementmap, Me.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: We.meshmatcap_vert,
        fragmentShader: We.meshmatcap_frag
    },
    points: {
        uniforms: Ot([Me.points, Me.fog]),
        vertexShader: We.points_vert,
        fragmentShader: We.points_frag
    },
    dashed: {
        uniforms: Ot([Me.common, Me.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: We.linedashed_vert,
        fragmentShader: We.linedashed_frag
    },
    depth: {
        uniforms: Ot([Me.common, Me.displacementmap]),
        vertexShader: We.depth_vert,
        fragmentShader: We.depth_frag
    },
    normal: {
        uniforms: Ot([Me.common, Me.bumpmap, Me.normalmap, Me.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: We.meshnormal_vert,
        fragmentShader: We.meshnormal_frag
    },
    sprite: {
        uniforms: Ot([Me.sprite, Me.fog]),
        vertexShader: We.sprite_vert,
        fragmentShader: We.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new $e
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: We.background_vert,
        fragmentShader: We.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: We.backgroundCube_vert,
        fragmentShader: We.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: We.cube_vert,
        fragmentShader: We.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: We.equirect_vert,
        fragmentShader: We.equirect_frag
    },
    distanceRGBA: {
        uniforms: Ot([Me.common, Me.displacementmap, {
            referencePosition: {
                value: new H
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: We.distanceRGBA_vert,
        fragmentShader: We.distanceRGBA_frag
    },
    shadow: {
        uniforms: Ot([Me.lights, Me.fog, {
            color: {
                value: new Xe(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: We.shadow_vert,
        fragmentShader: We.shadow_frag
    }
};
Tn.physical = {
    uniforms: Ot([Tn.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new $e
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new $e
        },
        clearcoatNormalScale: {
            value: new xe(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new $e
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new $e
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new $e
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Xe(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new $e
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new $e
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new $e
        },
        transmissionSamplerSize: {
            value: new xe
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new $e
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Xe(0)
        },
        specularColor: {
            value: new Xe(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new $e
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new $e
        },
        anisotropyVector: {
            value: new xe
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new $e
        }
    }]),
    vertexShader: We.meshphysical_vert,
    fragmentShader: We.meshphysical_frag
};
const Do = {
    r: 0,
    b: 0,
    g: 0
};
function OT(n, e, t, i, r, s, o) {
    const a = new Xe(0);
    let l = s === !0 ? 0 : 1, c, u, h = null, f = 0, p = null;
    function g(m, d) {
        let v = !1
          , _ = d.isScene === !0 ? d.background : null;
        _ && _.isTexture && (_ = (d.backgroundBlurriness > 0 ? t : e).get(_)),
        _ === null ? x(a, l) : _ && _.isColor && (x(_, 1),
        v = !0);
        const M = n.xr.getEnvironmentBlendMode();
        M === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : M === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
        (n.autoClear || v) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
        _ && (_.isCubeTexture || _.mapping === La) ? (u === void 0 && (u = new Vt(new Js(1,1,1),new Zn({
            name: "BackgroundCubeMaterial",
            uniforms: Gr(Tn.backgroundCube.uniforms),
            vertexShader: Tn.backgroundCube.vertexShader,
            fragmentShader: Tn.backgroundCube.fragmentShader,
            side: Wt,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        u.geometry.deleteAttribute("normal"),
        u.geometry.deleteAttribute("uv"),
        u.onBeforeRender = function(b, A, C) {
            this.matrixWorld.copyPosition(C.matrixWorld)
        }
        ,
        Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(u)),
        u.material.uniforms.envMap.value = _,
        u.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1,
        u.material.uniforms.backgroundBlurriness.value = d.backgroundBlurriness,
        u.material.uniforms.backgroundIntensity.value = d.backgroundIntensity,
        u.material.toneMapped = et.getTransfer(_.colorSpace) !== it,
        (h !== _ || f !== _.version || p !== n.toneMapping) && (u.material.needsUpdate = !0,
        h = _,
        f = _.version,
        p = n.toneMapping),
        u.layers.enableAll(),
        m.unshift(u, u.geometry, u.material, 0, 0, null)) : _ && _.isTexture && (c === void 0 && (c = new Vt(new Fa(2,2),new Zn({
            name: "BackgroundMaterial",
            uniforms: Gr(Tn.background.uniforms),
            vertexShader: Tn.background.vertexShader,
            fragmentShader: Tn.background.fragmentShader,
            side: Jn,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(c)),
        c.material.uniforms.t2D.value = _,
        c.material.uniforms.backgroundIntensity.value = d.backgroundIntensity,
        c.material.toneMapped = et.getTransfer(_.colorSpace) !== it,
        _.matrixAutoUpdate === !0 && _.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(_.matrix),
        (h !== _ || f !== _.version || p !== n.toneMapping) && (c.material.needsUpdate = !0,
        h = _,
        f = _.version,
        p = n.toneMapping),
        c.layers.enableAll(),
        m.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function x(m, d) {
        m.getRGB(Do, $m(n)),
        i.buffers.color.setClear(Do.r, Do.g, Do.b, d, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(m, d=1) {
            a.set(m),
            l = d,
            x(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(m) {
            l = m,
            x(a, l)
        },
        render: g
    }
}
function zT(n, e, t, i) {
    const r = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = i.isWebGL2 || s !== null
      , a = {}
      , l = m(null);
    let c = l
      , u = !1;
    function h(L, G, V, $, re) {
        let ee = !1;
        if (o) {
            const le = x($, V, G);
            c !== le && (c = le,
            p(c.object)),
            ee = d(L, $, V, re),
            ee && v(L, $, V, re)
        } else {
            const le = G.wireframe === !0;
            (c.geometry !== $.id || c.program !== V.id || c.wireframe !== le) && (c.geometry = $.id,
            c.program = V.id,
            c.wireframe = le,
            ee = !0)
        }
        re !== null && t.update(re, n.ELEMENT_ARRAY_BUFFER),
        (ee || u) && (u = !1,
        P(L, G, V, $),
        re !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(re).buffer))
    }
    function f() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }
    function p(L) {
        return i.isWebGL2 ? n.bindVertexArray(L) : s.bindVertexArrayOES(L)
    }
    function g(L) {
        return i.isWebGL2 ? n.deleteVertexArray(L) : s.deleteVertexArrayOES(L)
    }
    function x(L, G, V) {
        const $ = V.wireframe === !0;
        let re = a[L.id];
        re === void 0 && (re = {},
        a[L.id] = re);
        let ee = re[G.id];
        ee === void 0 && (ee = {},
        re[G.id] = ee);
        let le = ee[$];
        return le === void 0 && (le = m(f()),
        ee[$] = le),
        le
    }
    function m(L) {
        const G = []
          , V = []
          , $ = [];
        for (let re = 0; re < r; re++)
            G[re] = 0,
            V[re] = 0,
            $[re] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: G,
            enabledAttributes: V,
            attributeDivisors: $,
            object: L,
            attributes: {},
            index: null
        }
    }
    function d(L, G, V, $) {
        const re = c.attributes
          , ee = G.attributes;
        let le = 0;
        const B = V.getAttributes();
        for (const J in B)
            if (B[J].location >= 0) {
                const _e = re[J];
                let Te = ee[J];
                if (Te === void 0 && (J === "instanceMatrix" && L.instanceMatrix && (Te = L.instanceMatrix),
                J === "instanceColor" && L.instanceColor && (Te = L.instanceColor)),
                _e === void 0 || _e.attribute !== Te || Te && _e.data !== Te.data)
                    return !0;
                le++
            }
        return c.attributesNum !== le || c.index !== $
    }
    function v(L, G, V, $) {
        const re = {}
          , ee = G.attributes;
        let le = 0;
        const B = V.getAttributes();
        for (const J in B)
            if (B[J].location >= 0) {
                let _e = ee[J];
                _e === void 0 && (J === "instanceMatrix" && L.instanceMatrix && (_e = L.instanceMatrix),
                J === "instanceColor" && L.instanceColor && (_e = L.instanceColor));
                const Te = {};
                Te.attribute = _e,
                _e && _e.data && (Te.data = _e.data),
                re[J] = Te,
                le++
            }
        c.attributes = re,
        c.attributesNum = le,
        c.index = $
    }
    function _() {
        const L = c.newAttributes;
        for (let G = 0, V = L.length; G < V; G++)
            L[G] = 0
    }
    function M(L) {
        b(L, 0)
    }
    function b(L, G) {
        const V = c.newAttributes
          , $ = c.enabledAttributes
          , re = c.attributeDivisors;
        V[L] = 1,
        $[L] === 0 && (n.enableVertexAttribArray(L),
        $[L] = 1),
        re[L] !== G && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](L, G),
        re[L] = G)
    }
    function A() {
        const L = c.newAttributes
          , G = c.enabledAttributes;
        for (let V = 0, $ = G.length; V < $; V++)
            G[V] !== L[V] && (n.disableVertexAttribArray(V),
            G[V] = 0)
    }
    function C(L, G, V, $, re, ee, le) {
        le === !0 ? n.vertexAttribIPointer(L, G, V, re, ee) : n.vertexAttribPointer(L, G, V, $, re, ee)
    }
    function P(L, G, V, $) {
        if (i.isWebGL2 === !1 && (L.isInstancedMesh || $.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        _();
        const re = $.attributes
          , ee = V.getAttributes()
          , le = G.defaultAttributeValues;
        for (const B in ee) {
            const J = ee[B];
            if (J.location >= 0) {
                let fe = re[B];
                if (fe === void 0 && (B === "instanceMatrix" && L.instanceMatrix && (fe = L.instanceMatrix),
                B === "instanceColor" && L.instanceColor && (fe = L.instanceColor)),
                fe !== void 0) {
                    const _e = fe.normalized
                      , Te = fe.itemSize
                      , Ae = t.get(fe);
                    if (Ae === void 0)
                        continue;
                    const W = Ae.buffer
                      , se = Ae.type
                      , ce = Ae.bytesPerElement
                      , ge = i.isWebGL2 === !0 && (se === n.INT || se === n.UNSIGNED_INT || fe.gpuType === Lm);
                    if (fe.isInterleavedBufferAttribute) {
                        const he = fe.data
                          , y = he.stride
                          , R = fe.offset;
                        if (he.isInstancedInterleavedBuffer) {
                            for (let D = 0; D < J.locationSize; D++)
                                b(J.location + D, he.meshPerAttribute);
                            L.isInstancedMesh !== !0 && $._maxInstanceCount === void 0 && ($._maxInstanceCount = he.meshPerAttribute * he.count)
                        } else
                            for (let D = 0; D < J.locationSize; D++)
                                M(J.location + D);
                        n.bindBuffer(n.ARRAY_BUFFER, W);
                        for (let D = 0; D < J.locationSize; D++)
                            C(J.location + D, Te / J.locationSize, se, _e, y * ce, (R + Te / J.locationSize * D) * ce, ge)
                    } else {
                        if (fe.isInstancedBufferAttribute) {
                            for (let he = 0; he < J.locationSize; he++)
                                b(J.location + he, fe.meshPerAttribute);
                            L.isInstancedMesh !== !0 && $._maxInstanceCount === void 0 && ($._maxInstanceCount = fe.meshPerAttribute * fe.count)
                        } else
                            for (let he = 0; he < J.locationSize; he++)
                                M(J.location + he);
                        n.bindBuffer(n.ARRAY_BUFFER, W);
                        for (let he = 0; he < J.locationSize; he++)
                            C(J.location + he, Te / J.locationSize, se, _e, Te * ce, Te / J.locationSize * he * ce, ge)
                    }
                } else if (le !== void 0) {
                    const _e = le[B];
                    if (_e !== void 0)
                        switch (_e.length) {
                        case 2:
                            n.vertexAttrib2fv(J.location, _e);
                            break;
                        case 3:
                            n.vertexAttrib3fv(J.location, _e);
                            break;
                        case 4:
                            n.vertexAttrib4fv(J.location, _e);
                            break;
                        default:
                            n.vertexAttrib1fv(J.location, _e)
                        }
                }
            }
        }
        A()
    }
    function S() {
        k();
        for (const L in a) {
            const G = a[L];
            for (const V in G) {
                const $ = G[V];
                for (const re in $)
                    g($[re].object),
                    delete $[re];
                delete G[V]
            }
            delete a[L]
        }
    }
    function T(L) {
        if (a[L.id] === void 0)
            return;
        const G = a[L.id];
        for (const V in G) {
            const $ = G[V];
            for (const re in $)
                g($[re].object),
                delete $[re];
            delete G[V]
        }
        delete a[L.id]
    }
    function F(L) {
        for (const G in a) {
            const V = a[G];
            if (V[L.id] === void 0)
                continue;
            const $ = V[L.id];
            for (const re in $)
                g($[re].object),
                delete $[re];
            delete V[L.id]
        }
    }
    function k() {
        X(),
        u = !0,
        c !== l && (c = l,
        p(c.object))
    }
    function X() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: h,
        reset: k,
        resetDefaultState: X,
        dispose: S,
        releaseStatesOfGeometry: T,
        releaseStatesOfProgram: F,
        initAttributes: _,
        enableAttribute: M,
        disableUnusedAttributes: A
    }
}
function BT(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(c) {
        s = c
    }
    function a(c, u) {
        n.drawArrays(s, c, u),
        t.update(u, s, 1)
    }
    function l(c, u, h) {
        if (h === 0)
            return;
        let f, p;
        if (r)
            f = n,
            p = "drawArraysInstanced";
        else if (f = e.get("ANGLE_instanced_arrays"),
        p = "drawArraysInstancedANGLE",
        f === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        f[p](s, c, u, h),
        t.update(u, s, h)
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = l
}
function HT(n, e, t) {
    let i;
    function r() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const C = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function s(C) {
        if (C === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            C = "mediump"
        }
        return C === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
    a = l);
    const c = o || e.has("WEBGL_draw_buffers")
      , u = t.logarithmicDepthBuffer === !0
      , h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , f = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , p = n.getParameter(n.MAX_TEXTURE_SIZE)
      , g = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , x = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , m = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , d = n.getParameter(n.MAX_VARYING_VECTORS)
      , v = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , _ = f > 0
      , M = o || e.has("OES_texture_float")
      , b = _ && M
      , A = o ? n.getParameter(n.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: u,
        maxTextures: h,
        maxVertexTextures: f,
        maxTextureSize: p,
        maxCubemapSize: g,
        maxAttributes: x,
        maxVertexUniforms: m,
        maxVaryings: d,
        maxFragmentUniforms: v,
        vertexTextures: _,
        floatFragmentTextures: M,
        floatVertexTextures: b,
        maxSamples: A
    }
}
function kT(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new Ii
      , a = new $e
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, f) {
        const p = h.length !== 0 || f || i !== 0 || r;
        return r = f,
        i = h.length,
        p
    }
    ,
    this.beginShadows = function() {
        s = !0,
        u(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(h, f) {
        t = u(h, f, 0)
    }
    ,
    this.setState = function(h, f, p) {
        const g = h.clippingPlanes
          , x = h.clipIntersection
          , m = h.clipShadows
          , d = n.get(h);
        if (!r || g === null || g.length === 0 || s && !m)
            s ? u(null) : c();
        else {
            const v = s ? 0 : i
              , _ = v * 4;
            let M = d.clippingState || null;
            l.value = M,
            M = u(g, f, _, p);
            for (let b = 0; b !== _; ++b)
                M[b] = t[b];
            d.clippingState = M,
            this.numIntersection = x ? this.numPlanes : 0,
            this.numPlanes += v
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function u(h, f, p, g) {
        const x = h !== null ? h.length : 0;
        let m = null;
        if (x !== 0) {
            if (m = l.value,
            g !== !0 || m === null) {
                const d = p + x * 4
                  , v = f.matrixWorldInverse;
                a.getNormalMatrix(v),
                (m === null || m.length < d) && (m = new Float32Array(d));
                for (let _ = 0, M = p; _ !== x; ++_,
                M += 4)
                    o.copy(h[_]).applyMatrix4(v, a),
                    o.normal.toArray(m, M),
                    m[M + 3] = o.constant
            }
            l.value = m,
            l.needsUpdate = !0
        }
        return e.numPlanes = x,
        e.numIntersection = 0,
        m
    }
}
function GT(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === oa ? o.mapping = zr : a === Mc && (o.mapping = Br),
        o
    }
    function i(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === oa || a === Mc)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new nE(l.height / 2);
                        return c.fromEquirectangularTexture(n, o),
                        e.set(o, c),
                        o.addEventListener("dispose", r),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class Ym extends jm {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + t
          , l = r - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= u * this.view.offsetY,
            l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const yr = 4
  , Jf = [.125, .215, .35, .446, .526, .582]
  , Oi = 20
  , Dl = new Ym
  , Zf = new Xe;
let Il = null;
const Ui = (1 + Math.sqrt(5)) / 2
  , hr = 1 / Ui
  , Qf = [new H(1,1,1), new H(-1,1,1), new H(1,1,-1), new H(-1,1,-1), new H(0,Ui,hr), new H(0,Ui,-hr), new H(hr,0,Ui), new H(-hr,0,Ui), new H(Ui,hr,0), new H(-Ui,hr,0)];
class ed {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        Il = this._renderer.getRenderTarget(),
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = id(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = nd(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Il),
        e.scissorTest = !1,
        Io(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === zr || e.mapping === Br ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Il = this._renderer.getRenderTarget();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: Rt,
            minFilter: Rt,
            generateMipmaps: !1,
            type: $n,
            format: vn,
            colorSpace: Ln,
            depthBuffer: !1
        }
          , r = td(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = td(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = VT(s)),
            this._blurMaterial = WT(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new Vt(this._lodPlanes[0],e);
        this._renderer.compile(t, Dl)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new sn(90,1,t,i)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , u = this._renderer
          , h = u.autoClear
          , f = u.toneMapping;
        u.getClearColor(Zf),
        u.toneMapping = _i,
        u.autoClear = !1;
        const p = new Vm({
            name: "PMREM.Background",
            side: Wt,
            depthWrite: !1,
            depthTest: !1
        })
          , g = new Vt(new Js,p);
        let x = !1;
        const m = e.background;
        m ? m.isColor && (p.color.copy(m),
        e.background = null,
        x = !0) : (p.color.copy(Zf),
        x = !0);
        for (let d = 0; d < 6; d++) {
            const v = d % 3;
            v === 0 ? (a.up.set(0, l[d], 0),
            a.lookAt(c[d], 0, 0)) : v === 1 ? (a.up.set(0, 0, l[d]),
            a.lookAt(0, c[d], 0)) : (a.up.set(0, l[d], 0),
            a.lookAt(0, 0, c[d]));
            const _ = this._cubeSize;
            Io(r, v * _, d > 2 ? _ : 0, _, _),
            u.setRenderTarget(r),
            x && u.render(g, a),
            u.render(e, a)
        }
        g.geometry.dispose(),
        g.material.dispose(),
        u.toneMapping = f,
        u.autoClear = h,
        e.background = m
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === zr || e.mapping === Br;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = id()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = nd());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new Vt(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Io(t, 0, 0, 3 * l, 2 * l),
        i.setRenderTarget(t),
        i.render(o, Dl)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , o = Qf[(r - 1) % Qf.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3
          , h = new Vt(this._lodPlanes[r],c)
          , f = c.uniforms
          , p = this._sizeLods[i] - 1
          , g = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Oi - 1)
          , x = s / g
          , m = isFinite(s) ? 1 + Math.floor(u * x) : Oi;
        m > Oi && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Oi}`);
        const d = [];
        let v = 0;
        for (let C = 0; C < Oi; ++C) {
            const P = C / x
              , S = Math.exp(-P * P / 2);
            d.push(S),
            C === 0 ? v += S : C < m && (v += 2 * S)
        }
        for (let C = 0; C < d.length; C++)
            d[C] = d[C] / v;
        f.envMap.value = e.texture,
        f.samples.value = m,
        f.weights.value = d,
        f.latitudinal.value = o === "latitudinal",
        a && (f.poleAxis.value = a);
        const {_lodMax: _} = this;
        f.dTheta.value = g,
        f.mipInt.value = _ - i;
        const M = this._sizeLods[r]
          , b = 3 * M * (r > _ - yr ? r - _ + yr : 0)
          , A = 4 * (this._cubeSize - M);
        Io(t, b, A, 3 * M, 2 * M),
        l.setRenderTarget(t),
        l.render(h, Dl)
    }
}
function VT(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - yr + 1 + Jf.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > n - yr ? l = Jf[o - n + yr - 1] : o === 0 && (l = 0),
        i.push(l);
        const c = 1 / (a - 2)
          , u = -c
          , h = 1 + c
          , f = [u, u, h, u, h, h, u, u, h, h, u, h]
          , p = 6
          , g = 6
          , x = 3
          , m = 2
          , d = 1
          , v = new Float32Array(x * g * p)
          , _ = new Float32Array(m * g * p)
          , M = new Float32Array(d * g * p);
        for (let A = 0; A < p; A++) {
            const C = A % 3 * 2 / 3 - 1
              , P = A > 2 ? 0 : -1
              , S = [C, P, 0, C + 2 / 3, P, 0, C + 2 / 3, P + 1, 0, C, P, 0, C + 2 / 3, P + 1, 0, C, P + 1, 0];
            v.set(S, x * g * A),
            _.set(f, m * g * A);
            const T = [A, A, A, A, A, A];
            M.set(T, d * g * A)
        }
        const b = new Zt;
        b.setAttribute("position", new un(v,x)),
        b.setAttribute("uv", new un(_,m)),
        b.setAttribute("faceIndex", new un(M,d)),
        e.push(b),
        r > yr && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function td(n, e, t) {
    const i = new Wi(n,e,t);
    return i.texture.mapping = La,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function Io(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function WT(n, e, t) {
    const i = new Float32Array(Oi)
      , r = new H(0,1,0);
    return new Zn({
        name: "SphericalGaussianBlur",
        defines: {
            n: Oi,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: yu(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: gi,
        depthTest: !1,
        depthWrite: !1
    })
}
function nd() {
    return new Zn({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: yu(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: gi,
        depthTest: !1,
        depthWrite: !1
    })
}
function id() {
    return new Zn({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: yu(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: gi,
        depthTest: !1,
        depthWrite: !1
    })
}
function yu() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function XT(n) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === oa || l === Mc
              , u = l === zr || l === Br;
            if (c || u)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return t === null && (t = new ed(n)),
                    h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                    e.set(a, h),
                    h.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const h = a.image;
                        if (c && h && h.height > 0 || u && h && r(h)) {
                            t === null && (t = new ed(n));
                            const f = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, f),
                            a.addEventListener("dispose", s),
                            f.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function r(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++)
            a[u] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function $T(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function jT(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(h) {
        const f = h.target;
        f.index !== null && e.remove(f.index);
        for (const g in f.attributes)
            e.remove(f.attributes[g]);
        for (const g in f.morphAttributes) {
            const x = f.morphAttributes[g];
            for (let m = 0, d = x.length; m < d; m++)
                e.remove(x[m])
        }
        f.removeEventListener("dispose", o),
        delete r[f.id];
        const p = s.get(f);
        p && (e.remove(p),
        s.delete(f)),
        i.releaseStatesOfGeometry(f),
        f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
        t.memory.geometries--
    }
    function a(h, f) {
        return r[f.id] === !0 || (f.addEventListener("dispose", o),
        r[f.id] = !0,
        t.memory.geometries++),
        f
    }
    function l(h) {
        const f = h.attributes;
        for (const g in f)
            e.update(f[g], n.ARRAY_BUFFER);
        const p = h.morphAttributes;
        for (const g in p) {
            const x = p[g];
            for (let m = 0, d = x.length; m < d; m++)
                e.update(x[m], n.ARRAY_BUFFER)
        }
    }
    function c(h) {
        const f = []
          , p = h.index
          , g = h.attributes.position;
        let x = 0;
        if (p !== null) {
            const v = p.array;
            x = p.version;
            for (let _ = 0, M = v.length; _ < M; _ += 3) {
                const b = v[_ + 0]
                  , A = v[_ + 1]
                  , C = v[_ + 2];
                f.push(b, A, A, C, C, b)
            }
        } else if (g !== void 0) {
            const v = g.array;
            x = g.version;
            for (let _ = 0, M = v.length / 3 - 1; _ < M; _ += 3) {
                const b = _ + 0
                  , A = _ + 1
                  , C = _ + 2;
                f.push(b, A, A, C, C, b)
            }
        } else
            return;
        const m = new (zm(f) ? Xm : Wm)(f,1);
        m.version = x;
        const d = s.get(h);
        d && e.remove(d),
        s.set(h, m)
    }
    function u(h) {
        const f = s.get(h);
        if (f) {
            const p = h.index;
            p !== null && f.version < p.version && c(h)
        } else
            c(h);
        return s.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}
function KT(n, e, t, i) {
    const r = i.isWebGL2;
    let s;
    function o(f) {
        s = f
    }
    let a, l;
    function c(f) {
        a = f.type,
        l = f.bytesPerElement
    }
    function u(f, p) {
        n.drawElements(s, p, a, f * l),
        t.update(p, s, 1)
    }
    function h(f, p, g) {
        if (g === 0)
            return;
        let x, m;
        if (r)
            x = n,
            m = "drawElementsInstanced";
        else if (x = e.get("ANGLE_instanced_arrays"),
        m = "drawElementsInstancedANGLE",
        x === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        x[m](s, p, a, f * l, g),
        t.update(p, s, g)
    }
    this.setMode = o,
    this.setIndex = c,
    this.render = u,
    this.renderInstances = h
}
function qT(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (t.calls++,
        o) {
        case n.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case n.LINES:
            t.lines += a * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += a * s;
            break;
        case n.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function YT(n, e) {
    return n[0] - e[0]
}
function JT(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}
function ZT(n, e, t) {
    const i = {}
      , r = new Float32Array(8)
      , s = new WeakMap
      , o = new bt
      , a = [];
    for (let c = 0; c < 8; c++)
        a[c] = [c, 0];
    function l(c, u, h) {
        const f = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const p = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color
              , g = p !== void 0 ? p.length : 0;
            let x = s.get(u);
            if (x === void 0 || x.count !== g) {
                let L = function() {
                    k.dispose(),
                    s.delete(u),
                    u.removeEventListener("dispose", L)
                };
                x !== void 0 && x.texture.dispose();
                const v = u.morphAttributes.position !== void 0
                  , _ = u.morphAttributes.normal !== void 0
                  , M = u.morphAttributes.color !== void 0
                  , b = u.morphAttributes.position || []
                  , A = u.morphAttributes.normal || []
                  , C = u.morphAttributes.color || [];
                let P = 0;
                v === !0 && (P = 1),
                _ === !0 && (P = 2),
                M === !0 && (P = 3);
                let S = u.attributes.position.count * P
                  , T = 1;
                S > e.maxTextureSize && (T = Math.ceil(S / e.maxTextureSize),
                S = e.maxTextureSize);
                const F = new Float32Array(S * T * 4 * g)
                  , k = new km(F,S,T,g);
                k.type = xn,
                k.needsUpdate = !0;
                const X = P * 4;
                for (let G = 0; G < g; G++) {
                    const V = b[G]
                      , $ = A[G]
                      , re = C[G]
                      , ee = S * T * 4 * G;
                    for (let le = 0; le < V.count; le++) {
                        const B = le * X;
                        v === !0 && (o.fromBufferAttribute(V, le),
                        F[ee + B + 0] = o.x,
                        F[ee + B + 1] = o.y,
                        F[ee + B + 2] = o.z,
                        F[ee + B + 3] = 0),
                        _ === !0 && (o.fromBufferAttribute($, le),
                        F[ee + B + 4] = o.x,
                        F[ee + B + 5] = o.y,
                        F[ee + B + 6] = o.z,
                        F[ee + B + 7] = 0),
                        M === !0 && (o.fromBufferAttribute(re, le),
                        F[ee + B + 8] = o.x,
                        F[ee + B + 9] = o.y,
                        F[ee + B + 10] = o.z,
                        F[ee + B + 11] = re.itemSize === 4 ? o.w : 1)
                    }
                }
                x = {
                    count: g,
                    texture: k,
                    size: new xe(S,T)
                },
                s.set(u, x),
                u.addEventListener("dispose", L)
            }
            let m = 0;
            for (let v = 0; v < f.length; v++)
                m += f[v];
            const d = u.morphTargetsRelative ? 1 : 1 - m;
            h.getUniforms().setValue(n, "morphTargetBaseInfluence", d),
            h.getUniforms().setValue(n, "morphTargetInfluences", f),
            h.getUniforms().setValue(n, "morphTargetsTexture", x.texture, t),
            h.getUniforms().setValue(n, "morphTargetsTextureSize", x.size)
        } else {
            const p = f === void 0 ? 0 : f.length;
            let g = i[u.id];
            if (g === void 0 || g.length !== p) {
                g = [];
                for (let _ = 0; _ < p; _++)
                    g[_] = [_, 0];
                i[u.id] = g
            }
            for (let _ = 0; _ < p; _++) {
                const M = g[_];
                M[0] = _,
                M[1] = f[_]
            }
            g.sort(JT);
            for (let _ = 0; _ < 8; _++)
                _ < p && g[_][1] ? (a[_][0] = g[_][0],
                a[_][1] = g[_][1]) : (a[_][0] = Number.MAX_SAFE_INTEGER,
                a[_][1] = 0);
            a.sort(YT);
            const x = u.morphAttributes.position
              , m = u.morphAttributes.normal;
            let d = 0;
            for (let _ = 0; _ < 8; _++) {
                const M = a[_]
                  , b = M[0]
                  , A = M[1];
                b !== Number.MAX_SAFE_INTEGER && A ? (x && u.getAttribute("morphTarget" + _) !== x[b] && u.setAttribute("morphTarget" + _, x[b]),
                m && u.getAttribute("morphNormal" + _) !== m[b] && u.setAttribute("morphNormal" + _, m[b]),
                r[_] = A,
                d += A) : (x && u.hasAttribute("morphTarget" + _) === !0 && u.deleteAttribute("morphTarget" + _),
                m && u.hasAttribute("morphNormal" + _) === !0 && u.deleteAttribute("morphNormal" + _),
                r[_] = 0)
            }
            const v = u.morphTargetsRelative ? 1 : 1 - d;
            h.getUniforms().setValue(n, "morphTargetBaseInfluence", v),
            h.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: l
    }
}
function QT(n, e, t, i) {
    let r = new WeakMap;
    function s(l) {
        const c = i.render.frame
          , u = l.geometry
          , h = e.get(l, u);
        if (r.get(h) !== c && (e.update(h),
        r.set(h, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        r.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
        r.set(l, c))),
        l.isSkinnedMesh) {
            const f = l.skeleton;
            r.get(f) !== c && (f.update(),
            r.set(f, c))
        }
        return h
    }
    function o() {
        r = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const Jm = new zt
  , Zm = new km
  , Qm = new OS
  , eg = new Km
  , rd = []
  , sd = []
  , od = new Float32Array(16)
  , ad = new Float32Array(9)
  , ld = new Float32Array(4);
function Jr(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = rd[r];
    if (s === void 0 && (s = new Float32Array(r),
    rd[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function xt(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function yt(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function Oa(n, e) {
    let t = sd[e];
    t === void 0 && (t = new Int32Array(e),
    sd[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function ew(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function tw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (xt(t, e))
            return;
        n.uniform2fv(this.addr, e),
        yt(t, e)
    }
}
function nw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (xt(t, e))
            return;
        n.uniform3fv(this.addr, e),
        yt(t, e)
    }
}
function iw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (xt(t, e))
            return;
        n.uniform4fv(this.addr, e),
        yt(t, e)
    }
}
function rw(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (xt(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        yt(t, e)
    } else {
        if (xt(t, i))
            return;
        ld.set(i),
        n.uniformMatrix2fv(this.addr, !1, ld),
        yt(t, i)
    }
}
function sw(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (xt(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        yt(t, e)
    } else {
        if (xt(t, i))
            return;
        ad.set(i),
        n.uniformMatrix3fv(this.addr, !1, ad),
        yt(t, i)
    }
}
function ow(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (xt(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        yt(t, e)
    } else {
        if (xt(t, i))
            return;
        od.set(i),
        n.uniformMatrix4fv(this.addr, !1, od),
        yt(t, i)
    }
}
function aw(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function lw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (xt(t, e))
            return;
        n.uniform2iv(this.addr, e),
        yt(t, e)
    }
}
function cw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (xt(t, e))
            return;
        n.uniform3iv(this.addr, e),
        yt(t, e)
    }
}
function uw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (xt(t, e))
            return;
        n.uniform4iv(this.addr, e),
        yt(t, e)
    }
}
function hw(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function fw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (xt(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        yt(t, e)
    }
}
function dw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (xt(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        yt(t, e)
    }
}
function pw(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (xt(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        yt(t, e)
    }
}
function mw(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2D(e || Jm, r)
}
function gw(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || Qm, r)
}
function _w(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || eg, r)
}
function vw(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || Zm, r)
}
function xw(n) {
    switch (n) {
    case 5126:
        return ew;
    case 35664:
        return tw;
    case 35665:
        return nw;
    case 35666:
        return iw;
    case 35674:
        return rw;
    case 35675:
        return sw;
    case 35676:
        return ow;
    case 5124:
    case 35670:
        return aw;
    case 35667:
    case 35671:
        return lw;
    case 35668:
    case 35672:
        return cw;
    case 35669:
    case 35673:
        return uw;
    case 5125:
        return hw;
    case 36294:
        return fw;
    case 36295:
        return dw;
    case 36296:
        return pw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return mw;
    case 35679:
    case 36299:
    case 36307:
        return gw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return _w;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return vw
    }
}
function yw(n, e) {
    n.uniform1fv(this.addr, e)
}
function Mw(n, e) {
    const t = Jr(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function Sw(n, e) {
    const t = Jr(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function Ew(n, e) {
    const t = Jr(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function bw(n, e) {
    const t = Jr(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function Tw(n, e) {
    const t = Jr(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function ww(n, e) {
    const t = Jr(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function Aw(n, e) {
    n.uniform1iv(this.addr, e)
}
function Rw(n, e) {
    n.uniform2iv(this.addr, e)
}
function Cw(n, e) {
    n.uniform3iv(this.addr, e)
}
function Pw(n, e) {
    n.uniform4iv(this.addr, e)
}
function Lw(n, e) {
    n.uniform1uiv(this.addr, e)
}
function Dw(n, e) {
    n.uniform2uiv(this.addr, e)
}
function Iw(n, e) {
    n.uniform3uiv(this.addr, e)
}
function Uw(n, e) {
    n.uniform4uiv(this.addr, e)
}
function Nw(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = Oa(t, r);
    xt(i, s) || (n.uniform1iv(this.addr, s),
    yt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || Jm, s[o])
}
function Fw(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = Oa(t, r);
    xt(i, s) || (n.uniform1iv(this.addr, s),
    yt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || Qm, s[o])
}
function Ow(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = Oa(t, r);
    xt(i, s) || (n.uniform1iv(this.addr, s),
    yt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || eg, s[o])
}
function zw(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = Oa(t, r);
    xt(i, s) || (n.uniform1iv(this.addr, s),
    yt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || Zm, s[o])
}
function Bw(n) {
    switch (n) {
    case 5126:
        return yw;
    case 35664:
        return Mw;
    case 35665:
        return Sw;
    case 35666:
        return Ew;
    case 35674:
        return bw;
    case 35675:
        return Tw;
    case 35676:
        return ww;
    case 5124:
    case 35670:
        return Aw;
    case 35667:
    case 35671:
        return Rw;
    case 35668:
    case 35672:
        return Cw;
    case 35669:
    case 35673:
        return Pw;
    case 5125:
        return Lw;
    case 36294:
        return Dw;
    case 36295:
        return Iw;
    case 36296:
        return Uw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return Nw;
    case 35679:
    case 36299:
    case 36307:
        return Fw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return Ow;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return zw
    }
}
class Hw {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.setValue = xw(t.type)
    }
}
class kw {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.size = t.size,
        this.setValue = Bw(t.type)
    }
}
class Gw {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const Ul = /(\w+)(\])?(\[|\.)?/g;
function cd(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function Vw(n, e, t) {
    const i = n.name
      , r = i.length;
    for (Ul.lastIndex = 0; ; ) {
        const s = Ul.exec(i)
          , o = Ul.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , c = s[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === r) {
            cd(t, c === void 0 ? new Hw(a,n,e) : new kw(a,n,e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new Gw(a),
            cd(t, h)),
            t = h
        }
    }
}
class Go {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            Vw(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function ud(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
let Ww = 0;
function Xw(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function $w(n) {
    const e = et.getPrimaries(et.workingColorSpace)
      , t = et.getPrimaries(n);
    let i;
    switch (e === t ? i = "" : e === ca && t === la ? i = "LinearDisplayP3ToLinearSRGB" : e === la && t === ca && (i = "LinearSRGBToLinearDisplayP3"),
    n) {
    case Ln:
    case Ia:
        return [i, "LinearTransferOETF"];
    case At:
    case gu:
        return [i, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
    }
}
function hd(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + Xw(n.getShaderSource(e), o)
    } else
        return r
}
function jw(n, e) {
    const t = $w(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function Kw(n, e) {
    let t;
    switch (e) {
    case rS:
        t = "Linear";
        break;
    case sS:
        t = "Reinhard";
        break;
    case oS:
        t = "OptimizedCineon";
        break;
    case aS:
        t = "ACESFilmic";
        break;
    case lS:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function qw(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(fs).join(`
`)
}
function Yw(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function Jw(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2),
        s.type === n.FLOAT_MAT3 && (a = 3),
        s.type === n.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function fs(n) {
    return n !== ""
}
function fd(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function dd(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Zw = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ac(n) {
    return n.replace(Zw, e1)
}
const Qw = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function e1(n, e) {
    let t = We[e];
    if (t === void 0) {
        const i = Qw.get(e);
        if (i !== void 0)
            t = We[i],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Ac(t)
}
const t1 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function pd(n) {
    return n.replace(t1, n1)
}
function n1(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function md(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function i1(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === wm ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === FM ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Gn && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function r1(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case zr:
        case Br:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case La:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function s1(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case Br:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function o1(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case Cm:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case nS:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case iS:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function a1(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function l1(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = i1(t)
      , c = r1(t)
      , u = s1(t)
      , h = o1(t)
      , f = a1(t)
      , p = t.isWebGL2 ? "" : qw(t)
      , g = Yw(s)
      , x = r.createProgram();
    let m, d, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(fs).join(`
`),
    m.length > 0 && (m += `
`),
    d = [p, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(fs).join(`
`),
    d.length > 0 && (d += `
`)) : (m = [md(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(fs).join(`
`),
    d = [p, md(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== _i ? "#define TONE_MAPPING" : "", t.toneMapping !== _i ? We.tonemapping_pars_fragment : "", t.toneMapping !== _i ? Kw("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", We.colorspace_pars_fragment, jw("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(fs).join(`
`)),
    o = Ac(o),
    o = fd(o, t),
    o = dd(o, t),
    a = Ac(a),
    a = fd(a, t),
    a = dd(a, t),
    o = pd(o),
    a = pd(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`,
    m = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m,
    d = ["#define varying in", t.glslVersion === If ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === If ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + d);
    const _ = v + m + o
      , M = v + d + a
      , b = ud(r, r.VERTEX_SHADER, _)
      , A = ud(r, r.FRAGMENT_SHADER, M);
    if (r.attachShader(x, b),
    r.attachShader(x, A),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(x, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(x, 0, "position"),
    r.linkProgram(x),
    n.debug.checkShaderErrors) {
        const S = r.getProgramInfoLog(x).trim()
          , T = r.getShaderInfoLog(b).trim()
          , F = r.getShaderInfoLog(A).trim();
        let k = !0
          , X = !0;
        if (r.getProgramParameter(x, r.LINK_STATUS) === !1)
            if (k = !1,
            typeof n.debug.onShaderError == "function")
                n.debug.onShaderError(r, x, b, A);
            else {
                const L = hd(r, b, "vertex")
                  , G = hd(r, A, "fragment");
                console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, r.VALIDATE_STATUS) + `

Program Info Log: ` + S + `
` + L + `
` + G)
            }
        else
            S !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", S) : (T === "" || F === "") && (X = !1);
        X && (this.diagnostics = {
            runnable: k,
            programLog: S,
            vertexShader: {
                log: T,
                prefix: m
            },
            fragmentShader: {
                log: F,
                prefix: d
            }
        })
    }
    r.deleteShader(b),
    r.deleteShader(A);
    let C;
    this.getUniforms = function() {
        return C === void 0 && (C = new Go(r,x)),
        C
    }
    ;
    let P;
    return this.getAttributes = function() {
        return P === void 0 && (P = Jw(r, x)),
        P
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(x),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = Ww++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = x,
    this.vertexShader = b,
    this.fragmentShader = A,
    this
}
let c1 = 0;
class u1 {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new h1(e),
        t.set(e, i)),
        i
    }
}
class h1 {
    constructor(e) {
        this.id = c1++,
        this.code = e,
        this.usedTimes = 0
    }
}
function f1(n, e, t, i, r, s, o) {
    const a = new vu
      , l = new u1
      , c = []
      , u = r.isWebGL2
      , h = r.logarithmicDepthBuffer
      , f = r.vertexTextures;
    let p = r.precision;
    const g = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function x(S) {
        return S === 0 ? "uv" : `uv${S}`
    }
    function m(S, T, F, k, X) {
        const L = k.fog
          , G = X.geometry
          , V = S.isMeshStandardMaterial ? k.environment : null
          , $ = (S.isMeshStandardMaterial ? t : e).get(S.envMap || V)
          , re = $ && $.mapping === La ? $.image.height : null
          , ee = g[S.type];
        S.precision !== null && (p = r.getMaxPrecision(S.precision),
        p !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", p, "instead."));
        const le = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color
          , B = le !== void 0 ? le.length : 0;
        let J = 0;
        G.morphAttributes.position !== void 0 && (J = 1),
        G.morphAttributes.normal !== void 0 && (J = 2),
        G.morphAttributes.color !== void 0 && (J = 3);
        let fe, _e, Te, Ae;
        if (ee) {
            const nt = Tn[ee];
            fe = nt.vertexShader,
            _e = nt.fragmentShader
        } else
            fe = S.vertexShader,
            _e = S.fragmentShader,
            l.update(S),
            Te = l.getVertexShaderID(S),
            Ae = l.getFragmentShaderID(S);
        const W = n.getRenderTarget()
          , se = X.isInstancedMesh === !0
          , ce = !!S.map
          , ge = !!S.matcap
          , he = !!$
          , y = !!S.aoMap
          , R = !!S.lightMap
          , D = !!S.bumpMap
          , O = !!S.normalMap
          , N = !!S.displacementMap
          , j = !!S.emissiveMap
          , Z = !!S.metalnessMap
          , Y = !!S.roughnessMap
          , oe = S.anisotropy > 0
          , Q = S.clearcoat > 0
          , be = S.iridescence > 0
          , w = S.sheen > 0
          , E = S.transmission > 0
          , z = oe && !!S.anisotropyMap
          , ie = Q && !!S.clearcoatMap
          , ae = Q && !!S.clearcoatNormalMap
          , ue = Q && !!S.clearcoatRoughnessMap
          , Se = be && !!S.iridescenceMap
          , pe = be && !!S.iridescenceThicknessMap
          , Ee = w && !!S.sheenColorMap
          , Ne = w && !!S.sheenRoughnessMap
          , je = !!S.specularMap
          , me = !!S.specularColorMap
          , ke = !!S.specularIntensityMap
          , Le = E && !!S.transmissionMap
          , Fe = E && !!S.thicknessMap
          , Ue = !!S.gradientMap
          , U = !!S.alphaMap
          , ye = S.alphaTest > 0
          , ve = !!S.alphaHash
          , Re = !!S.extensions
          , we = !!G.attributes.uv1
          , de = !!G.attributes.uv2
          , Pe = !!G.attributes.uv3;
        let Ge = _i;
        return S.toneMapped && (W === null || W.isXRRenderTarget === !0) && (Ge = n.toneMapping),
        {
            isWebGL2: u,
            shaderID: ee,
            shaderType: S.type,
            shaderName: S.name,
            vertexShader: fe,
            fragmentShader: _e,
            defines: S.defines,
            customVertexShaderID: Te,
            customFragmentShaderID: Ae,
            isRawShaderMaterial: S.isRawShaderMaterial === !0,
            glslVersion: S.glslVersion,
            precision: p,
            instancing: se,
            instancingColor: se && X.instanceColor !== null,
            supportsVertexTextures: f,
            outputColorSpace: W === null ? n.outputColorSpace : W.isXRRenderTarget === !0 ? W.texture.colorSpace : Ln,
            map: ce,
            matcap: ge,
            envMap: he,
            envMapMode: he && $.mapping,
            envMapCubeUVHeight: re,
            aoMap: y,
            lightMap: R,
            bumpMap: D,
            normalMap: O,
            displacementMap: f && N,
            emissiveMap: j,
            normalMapObjectSpace: O && S.normalMapType === MS,
            normalMapTangentSpace: O && S.normalMapType === Da,
            metalnessMap: Z,
            roughnessMap: Y,
            anisotropy: oe,
            anisotropyMap: z,
            clearcoat: Q,
            clearcoatMap: ie,
            clearcoatNormalMap: ae,
            clearcoatRoughnessMap: ue,
            iridescence: be,
            iridescenceMap: Se,
            iridescenceThicknessMap: pe,
            sheen: w,
            sheenColorMap: Ee,
            sheenRoughnessMap: Ne,
            specularMap: je,
            specularColorMap: me,
            specularIntensityMap: ke,
            transmission: E,
            transmissionMap: Le,
            thicknessMap: Fe,
            gradientMap: Ue,
            opaque: S.transparent === !1 && S.blending === Cr,
            alphaMap: U,
            alphaTest: ye,
            alphaHash: ve,
            combine: S.combine,
            mapUv: ce && x(S.map.channel),
            aoMapUv: y && x(S.aoMap.channel),
            lightMapUv: R && x(S.lightMap.channel),
            bumpMapUv: D && x(S.bumpMap.channel),
            normalMapUv: O && x(S.normalMap.channel),
            displacementMapUv: N && x(S.displacementMap.channel),
            emissiveMapUv: j && x(S.emissiveMap.channel),
            metalnessMapUv: Z && x(S.metalnessMap.channel),
            roughnessMapUv: Y && x(S.roughnessMap.channel),
            anisotropyMapUv: z && x(S.anisotropyMap.channel),
            clearcoatMapUv: ie && x(S.clearcoatMap.channel),
            clearcoatNormalMapUv: ae && x(S.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: ue && x(S.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Se && x(S.iridescenceMap.channel),
            iridescenceThicknessMapUv: pe && x(S.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ee && x(S.sheenColorMap.channel),
            sheenRoughnessMapUv: Ne && x(S.sheenRoughnessMap.channel),
            specularMapUv: je && x(S.specularMap.channel),
            specularColorMapUv: me && x(S.specularColorMap.channel),
            specularIntensityMapUv: ke && x(S.specularIntensityMap.channel),
            transmissionMapUv: Le && x(S.transmissionMap.channel),
            thicknessMapUv: Fe && x(S.thicknessMap.channel),
            alphaMapUv: U && x(S.alphaMap.channel),
            vertexTangents: !!G.attributes.tangent && (O || oe),
            vertexColors: S.vertexColors,
            vertexAlphas: S.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
            vertexUv1s: we,
            vertexUv2s: de,
            vertexUv3s: Pe,
            pointsUvs: X.isPoints === !0 && !!G.attributes.uv && (ce || U),
            fog: !!L,
            useFog: S.fog === !0,
            fogExp2: L && L.isFogExp2,
            flatShading: S.flatShading === !0,
            sizeAttenuation: S.sizeAttenuation === !0,
            logarithmicDepthBuffer: h,
            skinning: X.isSkinnedMesh === !0,
            morphTargets: G.morphAttributes.position !== void 0,
            morphNormals: G.morphAttributes.normal !== void 0,
            morphColors: G.morphAttributes.color !== void 0,
            morphTargetsCount: B,
            morphTextureStride: J,
            numDirLights: T.directional.length,
            numPointLights: T.point.length,
            numSpotLights: T.spot.length,
            numSpotLightMaps: T.spotLightMap.length,
            numRectAreaLights: T.rectArea.length,
            numHemiLights: T.hemi.length,
            numDirLightShadows: T.directionalShadowMap.length,
            numPointLightShadows: T.pointShadowMap.length,
            numSpotLightShadows: T.spotShadowMap.length,
            numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
            numLightProbes: T.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: S.dithering,
            shadowMapEnabled: n.shadowMap.enabled && F.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Ge,
            useLegacyLights: n._useLegacyLights,
            decodeVideoTexture: ce && S.map.isVideoTexture === !0 && et.getTransfer(S.map.colorSpace) === it,
            premultipliedAlpha: S.premultipliedAlpha,
            doubleSided: S.side === An,
            flipSided: S.side === Wt,
            useDepthPacking: S.depthPacking >= 0,
            depthPacking: S.depthPacking || 0,
            index0AttributeName: S.index0AttributeName,
            extensionDerivatives: Re && S.extensions.derivatives === !0,
            extensionFragDepth: Re && S.extensions.fragDepth === !0,
            extensionDrawBuffers: Re && S.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: Re && S.extensions.shaderTextureLOD === !0,
            rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: S.customProgramCacheKey()
        }
    }
    function d(S) {
        const T = [];
        if (S.shaderID ? T.push(S.shaderID) : (T.push(S.customVertexShaderID),
        T.push(S.customFragmentShaderID)),
        S.defines !== void 0)
            for (const F in S.defines)
                T.push(F),
                T.push(S.defines[F]);
        return S.isRawShaderMaterial === !1 && (v(T, S),
        _(T, S),
        T.push(n.outputColorSpace)),
        T.push(S.customProgramCacheKey),
        T.join()
    }
    function v(S, T) {
        S.push(T.precision),
        S.push(T.outputColorSpace),
        S.push(T.envMapMode),
        S.push(T.envMapCubeUVHeight),
        S.push(T.mapUv),
        S.push(T.alphaMapUv),
        S.push(T.lightMapUv),
        S.push(T.aoMapUv),
        S.push(T.bumpMapUv),
        S.push(T.normalMapUv),
        S.push(T.displacementMapUv),
        S.push(T.emissiveMapUv),
        S.push(T.metalnessMapUv),
        S.push(T.roughnessMapUv),
        S.push(T.anisotropyMapUv),
        S.push(T.clearcoatMapUv),
        S.push(T.clearcoatNormalMapUv),
        S.push(T.clearcoatRoughnessMapUv),
        S.push(T.iridescenceMapUv),
        S.push(T.iridescenceThicknessMapUv),
        S.push(T.sheenColorMapUv),
        S.push(T.sheenRoughnessMapUv),
        S.push(T.specularMapUv),
        S.push(T.specularColorMapUv),
        S.push(T.specularIntensityMapUv),
        S.push(T.transmissionMapUv),
        S.push(T.thicknessMapUv),
        S.push(T.combine),
        S.push(T.fogExp2),
        S.push(T.sizeAttenuation),
        S.push(T.morphTargetsCount),
        S.push(T.morphAttributeCount),
        S.push(T.numDirLights),
        S.push(T.numPointLights),
        S.push(T.numSpotLights),
        S.push(T.numSpotLightMaps),
        S.push(T.numHemiLights),
        S.push(T.numRectAreaLights),
        S.push(T.numDirLightShadows),
        S.push(T.numPointLightShadows),
        S.push(T.numSpotLightShadows),
        S.push(T.numSpotLightShadowsWithMaps),
        S.push(T.numLightProbes),
        S.push(T.shadowMapType),
        S.push(T.toneMapping),
        S.push(T.numClippingPlanes),
        S.push(T.numClipIntersection),
        S.push(T.depthPacking)
    }
    function _(S, T) {
        a.disableAll(),
        T.isWebGL2 && a.enable(0),
        T.supportsVertexTextures && a.enable(1),
        T.instancing && a.enable(2),
        T.instancingColor && a.enable(3),
        T.matcap && a.enable(4),
        T.envMap && a.enable(5),
        T.normalMapObjectSpace && a.enable(6),
        T.normalMapTangentSpace && a.enable(7),
        T.clearcoat && a.enable(8),
        T.iridescence && a.enable(9),
        T.alphaTest && a.enable(10),
        T.vertexColors && a.enable(11),
        T.vertexAlphas && a.enable(12),
        T.vertexUv1s && a.enable(13),
        T.vertexUv2s && a.enable(14),
        T.vertexUv3s && a.enable(15),
        T.vertexTangents && a.enable(16),
        T.anisotropy && a.enable(17),
        S.push(a.mask),
        a.disableAll(),
        T.fog && a.enable(0),
        T.useFog && a.enable(1),
        T.flatShading && a.enable(2),
        T.logarithmicDepthBuffer && a.enable(3),
        T.skinning && a.enable(4),
        T.morphTargets && a.enable(5),
        T.morphNormals && a.enable(6),
        T.morphColors && a.enable(7),
        T.premultipliedAlpha && a.enable(8),
        T.shadowMapEnabled && a.enable(9),
        T.useLegacyLights && a.enable(10),
        T.doubleSided && a.enable(11),
        T.flipSided && a.enable(12),
        T.useDepthPacking && a.enable(13),
        T.dithering && a.enable(14),
        T.transmission && a.enable(15),
        T.sheen && a.enable(16),
        T.opaque && a.enable(17),
        T.pointsUvs && a.enable(18),
        T.decodeVideoTexture && a.enable(19),
        S.push(a.mask)
    }
    function M(S) {
        const T = g[S.type];
        let F;
        if (T) {
            const k = Tn[T];
            F = wc.clone(k.uniforms)
        } else
            F = S.uniforms;
        return F
    }
    function b(S, T) {
        let F;
        for (let k = 0, X = c.length; k < X; k++) {
            const L = c[k];
            if (L.cacheKey === T) {
                F = L,
                ++F.usedTimes;
                break
            }
        }
        return F === void 0 && (F = new l1(n,T,S,s),
        c.push(F)),
        F
    }
    function A(S) {
        if (--S.usedTimes === 0) {
            const T = c.indexOf(S);
            c[T] = c[c.length - 1],
            c.pop(),
            S.destroy()
        }
    }
    function C(S) {
        l.remove(S)
    }
    function P() {
        l.dispose()
    }
    return {
        getParameters: m,
        getProgramCacheKey: d,
        getUniforms: M,
        acquireProgram: b,
        releaseProgram: A,
        releaseShaderCache: C,
        programs: c,
        dispose: P
    }
}
function d1() {
    let n = new WeakMap;
    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {},
        n.set(s, o)),
        o
    }
    function t(s) {
        n.delete(s)
    }
    function i(s, o, a) {
        n.get(s)[o] = a
    }
    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}
function p1(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function gd(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function _d() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(h, f, p, g, x, m) {
        let d = n[e];
        return d === void 0 ? (d = {
            id: h.id,
            object: h,
            geometry: f,
            material: p,
            groupOrder: g,
            renderOrder: h.renderOrder,
            z: x,
            group: m
        },
        n[e] = d) : (d.id = h.id,
        d.object = h,
        d.geometry = f,
        d.material = p,
        d.groupOrder = g,
        d.renderOrder = h.renderOrder,
        d.z = x,
        d.group = m),
        e++,
        d
    }
    function a(h, f, p, g, x, m) {
        const d = o(h, f, p, g, x, m);
        p.transmission > 0 ? i.push(d) : p.transparent === !0 ? r.push(d) : t.push(d)
    }
    function l(h, f, p, g, x, m) {
        const d = o(h, f, p, g, x, m);
        p.transmission > 0 ? i.unshift(d) : p.transparent === !0 ? r.unshift(d) : t.unshift(d)
    }
    function c(h, f) {
        t.length > 1 && t.sort(h || p1),
        i.length > 1 && i.sort(f || gd),
        r.length > 1 && r.sort(f || gd)
    }
    function u() {
        for (let h = e, f = n.length; h < f; h++) {
            const p = n[h];
            if (p.id === null)
                break;
            p.id = null,
            p.object = null,
            p.geometry = null,
            p.material = null,
            p.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}
function m1() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new _d,
        n.set(i, [o])) : r >= s.length ? (o = new _d,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function g1() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new H,
                    color: new Xe
                };
                break;
            case "SpotLight":
                t = {
                    position: new H,
                    direction: new H,
                    color: new Xe,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new H,
                    color: new Xe,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new H,
                    skyColor: new Xe,
                    groundColor: new Xe
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Xe,
                    position: new H,
                    halfWidth: new H,
                    halfHeight: new H
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function _1() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new xe
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new xe
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new xe,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let v1 = 0;
function x1(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function y1(n, e) {
    const t = new g1
      , i = _1()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let u = 0; u < 9; u++)
        r.probe.push(new H);
    const s = new H
      , o = new ht
      , a = new ht;
    function l(u, h) {
        let f = 0
          , p = 0
          , g = 0;
        for (let k = 0; k < 9; k++)
            r.probe[k].set(0, 0, 0);
        let x = 0
          , m = 0
          , d = 0
          , v = 0
          , _ = 0
          , M = 0
          , b = 0
          , A = 0
          , C = 0
          , P = 0
          , S = 0;
        u.sort(x1);
        const T = h === !0 ? Math.PI : 1;
        for (let k = 0, X = u.length; k < X; k++) {
            const L = u[k]
              , G = L.color
              , V = L.intensity
              , $ = L.distance
              , re = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
            if (L.isAmbientLight)
                f += G.r * V * T,
                p += G.g * V * T,
                g += G.b * V * T;
            else if (L.isLightProbe) {
                for (let ee = 0; ee < 9; ee++)
                    r.probe[ee].addScaledVector(L.sh.coefficients[ee], V);
                S++
            } else if (L.isDirectionalLight) {
                const ee = t.get(L);
                if (ee.color.copy(L.color).multiplyScalar(L.intensity * T),
                L.castShadow) {
                    const le = L.shadow
                      , B = i.get(L);
                    B.shadowBias = le.bias,
                    B.shadowNormalBias = le.normalBias,
                    B.shadowRadius = le.radius,
                    B.shadowMapSize = le.mapSize,
                    r.directionalShadow[x] = B,
                    r.directionalShadowMap[x] = re,
                    r.directionalShadowMatrix[x] = L.shadow.matrix,
                    M++
                }
                r.directional[x] = ee,
                x++
            } else if (L.isSpotLight) {
                const ee = t.get(L);
                ee.position.setFromMatrixPosition(L.matrixWorld),
                ee.color.copy(G).multiplyScalar(V * T),
                ee.distance = $,
                ee.coneCos = Math.cos(L.angle),
                ee.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)),
                ee.decay = L.decay,
                r.spot[d] = ee;
                const le = L.shadow;
                if (L.map && (r.spotLightMap[C] = L.map,
                C++,
                le.updateMatrices(L),
                L.castShadow && P++),
                r.spotLightMatrix[d] = le.matrix,
                L.castShadow) {
                    const B = i.get(L);
                    B.shadowBias = le.bias,
                    B.shadowNormalBias = le.normalBias,
                    B.shadowRadius = le.radius,
                    B.shadowMapSize = le.mapSize,
                    r.spotShadow[d] = B,
                    r.spotShadowMap[d] = re,
                    A++
                }
                d++
            } else if (L.isRectAreaLight) {
                const ee = t.get(L);
                ee.color.copy(G).multiplyScalar(V),
                ee.halfWidth.set(L.width * .5, 0, 0),
                ee.halfHeight.set(0, L.height * .5, 0),
                r.rectArea[v] = ee,
                v++
            } else if (L.isPointLight) {
                const ee = t.get(L);
                if (ee.color.copy(L.color).multiplyScalar(L.intensity * T),
                ee.distance = L.distance,
                ee.decay = L.decay,
                L.castShadow) {
                    const le = L.shadow
                      , B = i.get(L);
                    B.shadowBias = le.bias,
                    B.shadowNormalBias = le.normalBias,
                    B.shadowRadius = le.radius,
                    B.shadowMapSize = le.mapSize,
                    B.shadowCameraNear = le.camera.near,
                    B.shadowCameraFar = le.camera.far,
                    r.pointShadow[m] = B,
                    r.pointShadowMap[m] = re,
                    r.pointShadowMatrix[m] = L.shadow.matrix,
                    b++
                }
                r.point[m] = ee,
                m++
            } else if (L.isHemisphereLight) {
                const ee = t.get(L);
                ee.skyColor.copy(L.color).multiplyScalar(V * T),
                ee.groundColor.copy(L.groundColor).multiplyScalar(V * T),
                r.hemi[_] = ee,
                _++
            }
        }
        v > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Me.LTC_FLOAT_1,
        r.rectAreaLTC2 = Me.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Me.LTC_HALF_1,
        r.rectAreaLTC2 = Me.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        r.ambient[0] = f,
        r.ambient[1] = p,
        r.ambient[2] = g;
        const F = r.hash;
        (F.directionalLength !== x || F.pointLength !== m || F.spotLength !== d || F.rectAreaLength !== v || F.hemiLength !== _ || F.numDirectionalShadows !== M || F.numPointShadows !== b || F.numSpotShadows !== A || F.numSpotMaps !== C || F.numLightProbes !== S) && (r.directional.length = x,
        r.spot.length = d,
        r.rectArea.length = v,
        r.point.length = m,
        r.hemi.length = _,
        r.directionalShadow.length = M,
        r.directionalShadowMap.length = M,
        r.pointShadow.length = b,
        r.pointShadowMap.length = b,
        r.spotShadow.length = A,
        r.spotShadowMap.length = A,
        r.directionalShadowMatrix.length = M,
        r.pointShadowMatrix.length = b,
        r.spotLightMatrix.length = A + C - P,
        r.spotLightMap.length = C,
        r.numSpotLightShadowsWithMaps = P,
        r.numLightProbes = S,
        F.directionalLength = x,
        F.pointLength = m,
        F.spotLength = d,
        F.rectAreaLength = v,
        F.hemiLength = _,
        F.numDirectionalShadows = M,
        F.numPointShadows = b,
        F.numSpotShadows = A,
        F.numSpotMaps = C,
        F.numLightProbes = S,
        r.version = v1++)
    }
    function c(u, h) {
        let f = 0
          , p = 0
          , g = 0
          , x = 0
          , m = 0;
        const d = h.matrixWorldInverse;
        for (let v = 0, _ = u.length; v < _; v++) {
            const M = u[v];
            if (M.isDirectionalLight) {
                const b = r.directional[f];
                b.direction.setFromMatrixPosition(M.matrixWorld),
                s.setFromMatrixPosition(M.target.matrixWorld),
                b.direction.sub(s),
                b.direction.transformDirection(d),
                f++
            } else if (M.isSpotLight) {
                const b = r.spot[g];
                b.position.setFromMatrixPosition(M.matrixWorld),
                b.position.applyMatrix4(d),
                b.direction.setFromMatrixPosition(M.matrixWorld),
                s.setFromMatrixPosition(M.target.matrixWorld),
                b.direction.sub(s),
                b.direction.transformDirection(d),
                g++
            } else if (M.isRectAreaLight) {
                const b = r.rectArea[x];
                b.position.setFromMatrixPosition(M.matrixWorld),
                b.position.applyMatrix4(d),
                a.identity(),
                o.copy(M.matrixWorld),
                o.premultiply(d),
                a.extractRotation(o),
                b.halfWidth.set(M.width * .5, 0, 0),
                b.halfHeight.set(0, M.height * .5, 0),
                b.halfWidth.applyMatrix4(a),
                b.halfHeight.applyMatrix4(a),
                x++
            } else if (M.isPointLight) {
                const b = r.point[p];
                b.position.setFromMatrixPosition(M.matrixWorld),
                b.position.applyMatrix4(d),
                p++
            } else if (M.isHemisphereLight) {
                const b = r.hemi[m];
                b.direction.setFromMatrixPosition(M.matrixWorld),
                b.direction.transformDirection(d),
                m++
            }
        }
    }
    return {
        setup: l,
        setupView: c,
        state: r
    }
}
function vd(n, e) {
    const t = new y1(n,e)
      , i = []
      , r = [];
    function s() {
        i.length = 0,
        r.length = 0
    }
    function o(h) {
        i.push(h)
    }
    function a(h) {
        r.push(h)
    }
    function l(h) {
        t.setup(i, h)
    }
    function c(h) {
        t.setupView(i, h)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    }
}
function M1(n, e) {
    let t = new WeakMap;
    function i(s, o=0) {
        const a = t.get(s);
        let l;
        return a === void 0 ? (l = new vd(n,e),
        t.set(s, [l])) : o >= a.length ? (l = new vd(n,e),
        a.push(l)) : l = a[o],
        l
    }
    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class S1 extends Mi {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = xS,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class E1 extends Mi {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const b1 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , T1 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function w1(n, e, t) {
    let i = new xu;
    const r = new xe
      , s = new xe
      , o = new bt
      , a = new S1({
        depthPacking: yS
    })
      , l = new E1
      , c = {}
      , u = t.maxTextureSize
      , h = {
        [Jn]: Wt,
        [Wt]: Jn,
        [An]: An
    }
      , f = new Zn({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new xe
            },
            radius: {
                value: 4
            }
        },
        vertexShader: b1,
        fragmentShader: T1
    })
      , p = f.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const g = new Zt;
    g.setAttribute("position", new un(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const x = new Vt(g,f)
      , m = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = wm;
    let d = this.type;
    this.render = function(b, A, C) {
        if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || b.length === 0)
            return;
        const P = n.getRenderTarget()
          , S = n.getActiveCubeFace()
          , T = n.getActiveMipmapLevel()
          , F = n.state;
        F.setBlending(gi),
        F.buffers.color.setClear(1, 1, 1, 1),
        F.buffers.depth.setTest(!0),
        F.setScissorTest(!1);
        const k = d !== Gn && this.type === Gn
          , X = d === Gn && this.type !== Gn;
        for (let L = 0, G = b.length; L < G; L++) {
            const V = b[L]
              , $ = V.shadow;
            if ($ === void 0) {
                console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
                continue
            }
            if ($.autoUpdate === !1 && $.needsUpdate === !1)
                continue;
            r.copy($.mapSize);
            const re = $.getFrameExtents();
            if (r.multiply(re),
            s.copy($.mapSize),
            (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / re.x),
            r.x = s.x * re.x,
            $.mapSize.x = s.x),
            r.y > u && (s.y = Math.floor(u / re.y),
            r.y = s.y * re.y,
            $.mapSize.y = s.y)),
            $.map === null || k === !0 || X === !0) {
                const le = this.type !== Gn ? {
                    minFilter: St,
                    magFilter: St
                } : {};
                $.map !== null && $.map.dispose(),
                $.map = new Wi(r.x,r.y,le),
                $.map.texture.name = V.name + ".shadowMap",
                $.camera.updateProjectionMatrix()
            }
            n.setRenderTarget($.map),
            n.clear();
            const ee = $.getViewportCount();
            for (let le = 0; le < ee; le++) {
                const B = $.getViewport(le);
                o.set(s.x * B.x, s.y * B.y, s.x * B.z, s.y * B.w),
                F.viewport(o),
                $.updateMatrices(V, le),
                i = $.getFrustum(),
                M(A, C, $.camera, V, this.type)
            }
            $.isPointLightShadow !== !0 && this.type === Gn && v($, C),
            $.needsUpdate = !1
        }
        d = this.type,
        m.needsUpdate = !1,
        n.setRenderTarget(P, S, T)
    }
    ;
    function v(b, A) {
        const C = e.update(x);
        f.defines.VSM_SAMPLES !== b.blurSamples && (f.defines.VSM_SAMPLES = b.blurSamples,
        p.defines.VSM_SAMPLES = b.blurSamples,
        f.needsUpdate = !0,
        p.needsUpdate = !0),
        b.mapPass === null && (b.mapPass = new Wi(r.x,r.y)),
        f.uniforms.shadow_pass.value = b.map.texture,
        f.uniforms.resolution.value = b.mapSize,
        f.uniforms.radius.value = b.radius,
        n.setRenderTarget(b.mapPass),
        n.clear(),
        n.renderBufferDirect(A, null, C, f, x, null),
        p.uniforms.shadow_pass.value = b.mapPass.texture,
        p.uniforms.resolution.value = b.mapSize,
        p.uniforms.radius.value = b.radius,
        n.setRenderTarget(b.map),
        n.clear(),
        n.renderBufferDirect(A, null, C, p, x, null)
    }
    function _(b, A, C, P) {
        let S = null;
        const T = C.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
        if (T !== void 0)
            S = T;
        else if (S = C.isPointLight === !0 ? l : a,
        n.localClippingEnabled && A.clipShadows === !0 && Array.isArray(A.clippingPlanes) && A.clippingPlanes.length !== 0 || A.displacementMap && A.displacementScale !== 0 || A.alphaMap && A.alphaTest > 0 || A.map && A.alphaTest > 0) {
            const F = S.uuid
              , k = A.uuid;
            let X = c[F];
            X === void 0 && (X = {},
            c[F] = X);
            let L = X[k];
            L === void 0 && (L = S.clone(),
            X[k] = L),
            S = L
        }
        if (S.visible = A.visible,
        S.wireframe = A.wireframe,
        P === Gn ? S.side = A.shadowSide !== null ? A.shadowSide : A.side : S.side = A.shadowSide !== null ? A.shadowSide : h[A.side],
        S.alphaMap = A.alphaMap,
        S.alphaTest = A.alphaTest,
        S.map = A.map,
        S.clipShadows = A.clipShadows,
        S.clippingPlanes = A.clippingPlanes,
        S.clipIntersection = A.clipIntersection,
        S.displacementMap = A.displacementMap,
        S.displacementScale = A.displacementScale,
        S.displacementBias = A.displacementBias,
        S.wireframeLinewidth = A.wireframeLinewidth,
        S.linewidth = A.linewidth,
        C.isPointLight === !0 && S.isMeshDistanceMaterial === !0) {
            const F = n.properties.get(S);
            F.light = C
        }
        return S
    }
    function M(b, A, C, P, S) {
        if (b.visible === !1)
            return;
        if (b.layers.test(A.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && S === Gn) && (!b.frustumCulled || i.intersectsObject(b))) {
            b.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, b.matrixWorld);
            const k = e.update(b)
              , X = b.material;
            if (Array.isArray(X)) {
                const L = k.groups;
                for (let G = 0, V = L.length; G < V; G++) {
                    const $ = L[G]
                      , re = X[$.materialIndex];
                    if (re && re.visible) {
                        const ee = _(b, re, P, S);
                        n.renderBufferDirect(C, null, k, ee, b, $)
                    }
                }
            } else if (X.visible) {
                const L = _(b, X, P, S);
                n.renderBufferDirect(C, null, k, L, b, null)
            }
        }
        const F = b.children;
        for (let k = 0, X = F.length; k < X; k++)
            M(F[k], A, C, P, S)
    }
}
function A1(n, e, t) {
    const i = t.isWebGL2;
    function r() {
        let U = !1;
        const ye = new bt;
        let ve = null;
        const Re = new bt(0,0,0,0);
        return {
            setMask: function(we) {
                ve !== we && !U && (n.colorMask(we, we, we, we),
                ve = we)
            },
            setLocked: function(we) {
                U = we
            },
            setClear: function(we, de, Pe, Ge, It) {
                It === !0 && (we *= Ge,
                de *= Ge,
                Pe *= Ge),
                ye.set(we, de, Pe, Ge),
                Re.equals(ye) === !1 && (n.clearColor(we, de, Pe, Ge),
                Re.copy(ye))
            },
            reset: function() {
                U = !1,
                ve = null,
                Re.set(-1, 0, 0, 0)
            }
        }
    }
    function s() {
        let U = !1
          , ye = null
          , ve = null
          , Re = null;
        return {
            setTest: function(we) {
                we ? W(n.DEPTH_TEST) : se(n.DEPTH_TEST)
            },
            setMask: function(we) {
                ye !== we && !U && (n.depthMask(we),
                ye = we)
            },
            setFunc: function(we) {
                if (ve !== we) {
                    switch (we) {
                    case qM:
                        n.depthFunc(n.NEVER);
                        break;
                    case YM:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case JM:
                        n.depthFunc(n.LESS);
                        break;
                    case yc:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case ZM:
                        n.depthFunc(n.EQUAL);
                        break;
                    case QM:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case eS:
                        n.depthFunc(n.GREATER);
                        break;
                    case tS:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    ve = we
                }
            },
            setLocked: function(we) {
                U = we
            },
            setClear: function(we) {
                Re !== we && (n.clearDepth(we),
                Re = we)
            },
            reset: function() {
                U = !1,
                ye = null,
                ve = null,
                Re = null
            }
        }
    }
    function o() {
        let U = !1
          , ye = null
          , ve = null
          , Re = null
          , we = null
          , de = null
          , Pe = null
          , Ge = null
          , It = null;
        return {
            setTest: function(nt) {
                U || (nt ? W(n.STENCIL_TEST) : se(n.STENCIL_TEST))
            },
            setMask: function(nt) {
                ye !== nt && !U && (n.stencilMask(nt),
                ye = nt)
            },
            setFunc: function(nt, Sn, Ut) {
                (ve !== nt || Re !== Sn || we !== Ut) && (n.stencilFunc(nt, Sn, Ut),
                ve = nt,
                Re = Sn,
                we = Ut)
            },
            setOp: function(nt, Sn, Ut) {
                (de !== nt || Pe !== Sn || Ge !== Ut) && (n.stencilOp(nt, Sn, Ut),
                de = nt,
                Pe = Sn,
                Ge = Ut)
            },
            setLocked: function(nt) {
                U = nt
            },
            setClear: function(nt) {
                It !== nt && (n.clearStencil(nt),
                It = nt)
            },
            reset: function() {
                U = !1,
                ye = null,
                ve = null,
                Re = null,
                we = null,
                de = null,
                Pe = null,
                Ge = null,
                It = null
            }
        }
    }
    const a = new r
      , l = new s
      , c = new o
      , u = new WeakMap
      , h = new WeakMap;
    let f = {}
      , p = {}
      , g = new WeakMap
      , x = []
      , m = null
      , d = !1
      , v = null
      , _ = null
      , M = null
      , b = null
      , A = null
      , C = null
      , P = null
      , S = !1
      , T = null
      , F = null
      , k = null
      , X = null
      , L = null;
    const G = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let V = !1
      , $ = 0;
    const re = n.getParameter(n.VERSION);
    re.indexOf("WebGL") !== -1 ? ($ = parseFloat(/^WebGL (\d)/.exec(re)[1]),
    V = $ >= 1) : re.indexOf("OpenGL ES") !== -1 && ($ = parseFloat(/^OpenGL ES (\d)/.exec(re)[1]),
    V = $ >= 2);
    let ee = null
      , le = {};
    const B = n.getParameter(n.SCISSOR_BOX)
      , J = n.getParameter(n.VIEWPORT)
      , fe = new bt().fromArray(B)
      , _e = new bt().fromArray(J);
    function Te(U, ye, ve, Re) {
        const we = new Uint8Array(4)
          , de = n.createTexture();
        n.bindTexture(U, de),
        n.texParameteri(U, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri(U, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let Pe = 0; Pe < ve; Pe++)
            i && (U === n.TEXTURE_3D || U === n.TEXTURE_2D_ARRAY) ? n.texImage3D(ye, 0, n.RGBA, 1, 1, Re, 0, n.RGBA, n.UNSIGNED_BYTE, we) : n.texImage2D(ye + Pe, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, we);
        return de
    }
    const Ae = {};
    Ae[n.TEXTURE_2D] = Te(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    Ae[n.TEXTURE_CUBE_MAP] = Te(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    i && (Ae[n.TEXTURE_2D_ARRAY] = Te(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    Ae[n.TEXTURE_3D] = Te(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    W(n.DEPTH_TEST),
    l.setFunc(yc),
    N(!1),
    j(Qh),
    W(n.CULL_FACE),
    D(gi);
    function W(U) {
        f[U] !== !0 && (n.enable(U),
        f[U] = !0)
    }
    function se(U) {
        f[U] !== !1 && (n.disable(U),
        f[U] = !1)
    }
    function ce(U, ye) {
        return p[U] !== ye ? (n.bindFramebuffer(U, ye),
        p[U] = ye,
        i && (U === n.DRAW_FRAMEBUFFER && (p[n.FRAMEBUFFER] = ye),
        U === n.FRAMEBUFFER && (p[n.DRAW_FRAMEBUFFER] = ye)),
        !0) : !1
    }
    function ge(U, ye) {
        let ve = x
          , Re = !1;
        if (U)
            if (ve = g.get(ye),
            ve === void 0 && (ve = [],
            g.set(ye, ve)),
            U.isWebGLMultipleRenderTargets) {
                const we = U.texture;
                if (ve.length !== we.length || ve[0] !== n.COLOR_ATTACHMENT0) {
                    for (let de = 0, Pe = we.length; de < Pe; de++)
                        ve[de] = n.COLOR_ATTACHMENT0 + de;
                    ve.length = we.length,
                    Re = !0
                }
            } else
                ve[0] !== n.COLOR_ATTACHMENT0 && (ve[0] = n.COLOR_ATTACHMENT0,
                Re = !0);
        else
            ve[0] !== n.BACK && (ve[0] = n.BACK,
            Re = !0);
        Re && (t.isWebGL2 ? n.drawBuffers(ve) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ve))
    }
    function he(U) {
        return m !== U ? (n.useProgram(U),
        m = U,
        !0) : !1
    }
    const y = {
        [gr]: n.FUNC_ADD,
        [zM]: n.FUNC_SUBTRACT,
        [BM]: n.FUNC_REVERSE_SUBTRACT
    };
    if (i)
        y[rf] = n.MIN,
        y[sf] = n.MAX;
    else {
        const U = e.get("EXT_blend_minmax");
        U !== null && (y[rf] = U.MIN_EXT,
        y[sf] = U.MAX_EXT)
    }
    const R = {
        [HM]: n.ZERO,
        [kM]: n.ONE,
        [GM]: n.SRC_COLOR,
        [Am]: n.SRC_ALPHA,
        [KM]: n.SRC_ALPHA_SATURATE,
        [$M]: n.DST_COLOR,
        [WM]: n.DST_ALPHA,
        [VM]: n.ONE_MINUS_SRC_COLOR,
        [Rm]: n.ONE_MINUS_SRC_ALPHA,
        [jM]: n.ONE_MINUS_DST_COLOR,
        [XM]: n.ONE_MINUS_DST_ALPHA
    };
    function D(U, ye, ve, Re, we, de, Pe, Ge) {
        if (U === gi) {
            d === !0 && (se(n.BLEND),
            d = !1);
            return
        }
        if (d === !1 && (W(n.BLEND),
        d = !0),
        U !== OM) {
            if (U !== v || Ge !== S) {
                if ((_ !== gr || A !== gr) && (n.blendEquation(n.FUNC_ADD),
                _ = gr,
                A = gr),
                Ge)
                    switch (U) {
                    case Cr:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case ef:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case tf:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case nf:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", U);
                        break
                    }
                else
                    switch (U) {
                    case Cr:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case ef:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case tf:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case nf:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", U);
                        break
                    }
                M = null,
                b = null,
                C = null,
                P = null,
                v = U,
                S = Ge
            }
            return
        }
        we = we || ye,
        de = de || ve,
        Pe = Pe || Re,
        (ye !== _ || we !== A) && (n.blendEquationSeparate(y[ye], y[we]),
        _ = ye,
        A = we),
        (ve !== M || Re !== b || de !== C || Pe !== P) && (n.blendFuncSeparate(R[ve], R[Re], R[de], R[Pe]),
        M = ve,
        b = Re,
        C = de,
        P = Pe),
        v = U,
        S = !1
    }
    function O(U, ye) {
        U.side === An ? se(n.CULL_FACE) : W(n.CULL_FACE);
        let ve = U.side === Wt;
        ye && (ve = !ve),
        N(ve),
        U.blending === Cr && U.transparent === !1 ? D(gi) : D(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.premultipliedAlpha),
        l.setFunc(U.depthFunc),
        l.setTest(U.depthTest),
        l.setMask(U.depthWrite),
        a.setMask(U.colorWrite);
        const Re = U.stencilWrite;
        c.setTest(Re),
        Re && (c.setMask(U.stencilWriteMask),
        c.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask),
        c.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)),
        Y(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits),
        U.alphaToCoverage === !0 ? W(n.SAMPLE_ALPHA_TO_COVERAGE) : se(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function N(U) {
        T !== U && (U ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        T = U)
    }
    function j(U) {
        U !== UM ? (W(n.CULL_FACE),
        U !== F && (U === Qh ? n.cullFace(n.BACK) : U === NM ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : se(n.CULL_FACE),
        F = U
    }
    function Z(U) {
        U !== k && (V && n.lineWidth(U),
        k = U)
    }
    function Y(U, ye, ve) {
        U ? (W(n.POLYGON_OFFSET_FILL),
        (X !== ye || L !== ve) && (n.polygonOffset(ye, ve),
        X = ye,
        L = ve)) : se(n.POLYGON_OFFSET_FILL)
    }
    function oe(U) {
        U ? W(n.SCISSOR_TEST) : se(n.SCISSOR_TEST)
    }
    function Q(U) {
        U === void 0 && (U = n.TEXTURE0 + G - 1),
        ee !== U && (n.activeTexture(U),
        ee = U)
    }
    function be(U, ye, ve) {
        ve === void 0 && (ee === null ? ve = n.TEXTURE0 + G - 1 : ve = ee);
        let Re = le[ve];
        Re === void 0 && (Re = {
            type: void 0,
            texture: void 0
        },
        le[ve] = Re),
        (Re.type !== U || Re.texture !== ye) && (ee !== ve && (n.activeTexture(ve),
        ee = ve),
        n.bindTexture(U, ye || Ae[U]),
        Re.type = U,
        Re.texture = ye)
    }
    function w() {
        const U = le[ee];
        U !== void 0 && U.type !== void 0 && (n.bindTexture(U.type, null),
        U.type = void 0,
        U.texture = void 0)
    }
    function E() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function z() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function ie() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function ae() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function ue() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function Se() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function pe() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function Ee() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function Ne() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function je() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (U) {
            console.error("THREE.WebGLState:", U)
        }
    }
    function me(U) {
        fe.equals(U) === !1 && (n.scissor(U.x, U.y, U.z, U.w),
        fe.copy(U))
    }
    function ke(U) {
        _e.equals(U) === !1 && (n.viewport(U.x, U.y, U.z, U.w),
        _e.copy(U))
    }
    function Le(U, ye) {
        let ve = h.get(ye);
        ve === void 0 && (ve = new WeakMap,
        h.set(ye, ve));
        let Re = ve.get(U);
        Re === void 0 && (Re = n.getUniformBlockIndex(ye, U.name),
        ve.set(U, Re))
    }
    function Fe(U, ye) {
        const Re = h.get(ye).get(U);
        u.get(ye) !== Re && (n.uniformBlockBinding(ye, Re, U.__bindingPointIndex),
        u.set(ye, Re))
    }
    function Ue() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        f = {},
        ee = null,
        le = {},
        p = {},
        g = new WeakMap,
        x = [],
        m = null,
        d = !1,
        v = null,
        _ = null,
        M = null,
        b = null,
        A = null,
        C = null,
        P = null,
        S = !1,
        T = null,
        F = null,
        k = null,
        X = null,
        L = null,
        fe.set(0, 0, n.canvas.width, n.canvas.height),
        _e.set(0, 0, n.canvas.width, n.canvas.height),
        a.reset(),
        l.reset(),
        c.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: c
        },
        enable: W,
        disable: se,
        bindFramebuffer: ce,
        drawBuffers: ge,
        useProgram: he,
        setBlending: D,
        setMaterial: O,
        setFlipSided: N,
        setCullFace: j,
        setLineWidth: Z,
        setPolygonOffset: Y,
        setScissorTest: oe,
        activeTexture: Q,
        bindTexture: be,
        unbindTexture: w,
        compressedTexImage2D: E,
        compressedTexImage3D: z,
        texImage2D: Ne,
        texImage3D: je,
        updateUBOMapping: Le,
        uniformBlockBinding: Fe,
        texStorage2D: pe,
        texStorage3D: Ee,
        texSubImage2D: ie,
        texSubImage3D: ae,
        compressedTexSubImage2D: ue,
        compressedTexSubImage3D: Se,
        scissor: me,
        viewport: ke,
        reset: Ue
    }
}
function R1(n, e, t, i, r, s, o) {
    const a = r.isWebGL2
      , l = r.maxTextures
      , c = r.maxCubemapSize
      , u = r.maxTextureSize
      , h = r.maxSamples
      , f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , p = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , g = new WeakMap;
    let x;
    const m = new WeakMap;
    let d = !1;
    try {
        d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function v(w, E) {
        return d ? new OffscreenCanvas(w,E) : zs("canvas")
    }
    function _(w, E, z, ie) {
        let ae = 1;
        if ((w.width > ie || w.height > ie) && (ae = ie / Math.max(w.width, w.height)),
        ae < 1 || E === !0)
            if (typeof HTMLImageElement < "u" && w instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && w instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && w instanceof ImageBitmap) {
                const ue = E ? Tc : Math.floor
                  , Se = ue(ae * w.width)
                  , pe = ue(ae * w.height);
                x === void 0 && (x = v(Se, pe));
                const Ee = z ? v(Se, pe) : x;
                return Ee.width = Se,
                Ee.height = pe,
                Ee.getContext("2d").drawImage(w, 0, 0, Se, pe),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + w.width + "x" + w.height + ") to (" + Se + "x" + pe + ")."),
                Ee
            } else
                return "data"in w && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + w.width + "x" + w.height + ")."),
                w;
        return w
    }
    function M(w) {
        return Uf(w.width) && Uf(w.height)
    }
    function b(w) {
        return a ? !1 : w.wrapS !== qt || w.wrapT !== qt || w.minFilter !== St && w.minFilter !== Rt
    }
    function A(w, E) {
        return w.generateMipmaps && E && w.minFilter !== St && w.minFilter !== Rt
    }
    function C(w) {
        n.generateMipmap(w)
    }
    function P(w, E, z, ie, ae=!1) {
        if (a === !1)
            return E;
        if (w !== null) {
            if (n[w] !== void 0)
                return n[w];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + w + "'")
        }
        let ue = E;
        if (E === n.RED && (z === n.FLOAT && (ue = n.R32F),
        z === n.HALF_FLOAT && (ue = n.R16F),
        z === n.UNSIGNED_BYTE && (ue = n.R8)),
        E === n.RED_INTEGER && (z === n.UNSIGNED_BYTE && (ue = n.R8UI),
        z === n.UNSIGNED_SHORT && (ue = n.R16UI),
        z === n.UNSIGNED_INT && (ue = n.R32UI),
        z === n.BYTE && (ue = n.R8I),
        z === n.SHORT && (ue = n.R16I),
        z === n.INT && (ue = n.R32I)),
        E === n.RG && (z === n.FLOAT && (ue = n.RG32F),
        z === n.HALF_FLOAT && (ue = n.RG16F),
        z === n.UNSIGNED_BYTE && (ue = n.RG8)),
        E === n.RGBA) {
            const Se = ae ? aa : et.getTransfer(ie);
            z === n.FLOAT && (ue = n.RGBA32F),
            z === n.HALF_FLOAT && (ue = n.RGBA16F),
            z === n.UNSIGNED_BYTE && (ue = Se === it ? n.SRGB8_ALPHA8 : n.RGBA8),
            z === n.UNSIGNED_SHORT_4_4_4_4 && (ue = n.RGBA4),
            z === n.UNSIGNED_SHORT_5_5_5_1 && (ue = n.RGB5_A1)
        }
        return (ue === n.R16F || ue === n.R32F || ue === n.RG16F || ue === n.RG32F || ue === n.RGBA16F || ue === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        ue
    }
    function S(w, E, z) {
        return A(w, z) === !0 || w.isFramebufferTexture && w.minFilter !== St && w.minFilter !== Rt ? Math.log2(Math.max(E.width, E.height)) + 1 : w.mipmaps !== void 0 && w.mipmaps.length > 0 ? w.mipmaps.length : w.isCompressedTexture && Array.isArray(w.image) ? E.mipmaps.length : 1
    }
    function T(w) {
        return w === St || w === of || w === ol ? n.NEAREST : n.LINEAR
    }
    function F(w) {
        const E = w.target;
        E.removeEventListener("dispose", F),
        X(E),
        E.isVideoTexture && g.delete(E)
    }
    function k(w) {
        const E = w.target;
        E.removeEventListener("dispose", k),
        G(E)
    }
    function X(w) {
        const E = i.get(w);
        if (E.__webglInit === void 0)
            return;
        const z = w.source
          , ie = m.get(z);
        if (ie) {
            const ae = ie[E.__cacheKey];
            ae.usedTimes--,
            ae.usedTimes === 0 && L(w),
            Object.keys(ie).length === 0 && m.delete(z)
        }
        i.remove(w)
    }
    function L(w) {
        const E = i.get(w);
        n.deleteTexture(E.__webglTexture);
        const z = w.source
          , ie = m.get(z);
        delete ie[E.__cacheKey],
        o.memory.textures--
    }
    function G(w) {
        const E = w.texture
          , z = i.get(w)
          , ie = i.get(E);
        if (ie.__webglTexture !== void 0 && (n.deleteTexture(ie.__webglTexture),
        o.memory.textures--),
        w.depthTexture && w.depthTexture.dispose(),
        w.isWebGLCubeRenderTarget)
            for (let ae = 0; ae < 6; ae++) {
                if (Array.isArray(z.__webglFramebuffer[ae]))
                    for (let ue = 0; ue < z.__webglFramebuffer[ae].length; ue++)
                        n.deleteFramebuffer(z.__webglFramebuffer[ae][ue]);
                else
                    n.deleteFramebuffer(z.__webglFramebuffer[ae]);
                z.__webglDepthbuffer && n.deleteRenderbuffer(z.__webglDepthbuffer[ae])
            }
        else {
            if (Array.isArray(z.__webglFramebuffer))
                for (let ae = 0; ae < z.__webglFramebuffer.length; ae++)
                    n.deleteFramebuffer(z.__webglFramebuffer[ae]);
            else
                n.deleteFramebuffer(z.__webglFramebuffer);
            if (z.__webglDepthbuffer && n.deleteRenderbuffer(z.__webglDepthbuffer),
            z.__webglMultisampledFramebuffer && n.deleteFramebuffer(z.__webglMultisampledFramebuffer),
            z.__webglColorRenderbuffer)
                for (let ae = 0; ae < z.__webglColorRenderbuffer.length; ae++)
                    z.__webglColorRenderbuffer[ae] && n.deleteRenderbuffer(z.__webglColorRenderbuffer[ae]);
            z.__webglDepthRenderbuffer && n.deleteRenderbuffer(z.__webglDepthRenderbuffer)
        }
        if (w.isWebGLMultipleRenderTargets)
            for (let ae = 0, ue = E.length; ae < ue; ae++) {
                const Se = i.get(E[ae]);
                Se.__webglTexture && (n.deleteTexture(Se.__webglTexture),
                o.memory.textures--),
                i.remove(E[ae])
            }
        i.remove(E),
        i.remove(w)
    }
    let V = 0;
    function $() {
        V = 0
    }
    function re() {
        const w = V;
        return w >= l && console.warn("THREE.WebGLTextures: Trying to use " + w + " texture units while this GPU supports only " + l),
        V += 1,
        w
    }
    function ee(w) {
        const E = [];
        return E.push(w.wrapS),
        E.push(w.wrapT),
        E.push(w.wrapR || 0),
        E.push(w.magFilter),
        E.push(w.minFilter),
        E.push(w.anisotropy),
        E.push(w.internalFormat),
        E.push(w.format),
        E.push(w.type),
        E.push(w.generateMipmaps),
        E.push(w.premultiplyAlpha),
        E.push(w.flipY),
        E.push(w.unpackAlignment),
        E.push(w.colorSpace),
        E.join()
    }
    function le(w, E) {
        const z = i.get(w);
        if (w.isVideoTexture && Q(w),
        w.isRenderTargetTexture === !1 && w.version > 0 && z.__version !== w.version) {
            const ie = w.image;
            if (ie === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (ie.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ce(z, w, E);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, z.__webglTexture, n.TEXTURE0 + E)
    }
    function B(w, E) {
        const z = i.get(w);
        if (w.version > 0 && z.__version !== w.version) {
            ce(z, w, E);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, z.__webglTexture, n.TEXTURE0 + E)
    }
    function J(w, E) {
        const z = i.get(w);
        if (w.version > 0 && z.__version !== w.version) {
            ce(z, w, E);
            return
        }
        t.bindTexture(n.TEXTURE_3D, z.__webglTexture, n.TEXTURE0 + E)
    }
    function fe(w, E) {
        const z = i.get(w);
        if (w.version > 0 && z.__version !== w.version) {
            ge(z, w, E);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, z.__webglTexture, n.TEXTURE0 + E)
    }
    const _e = {
        [Os]: n.REPEAT,
        [qt]: n.CLAMP_TO_EDGE,
        [Sc]: n.MIRRORED_REPEAT
    }
      , Te = {
        [St]: n.NEAREST,
        [of]: n.NEAREST_MIPMAP_NEAREST,
        [ol]: n.NEAREST_MIPMAP_LINEAR,
        [Rt]: n.LINEAR,
        [cS]: n.LINEAR_MIPMAP_NEAREST,
        [Hr]: n.LINEAR_MIPMAP_LINEAR
    }
      , Ae = {
        [ES]: n.NEVER,
        [PS]: n.ALWAYS,
        [bS]: n.LESS,
        [wS]: n.LEQUAL,
        [TS]: n.EQUAL,
        [CS]: n.GEQUAL,
        [AS]: n.GREATER,
        [RS]: n.NOTEQUAL
    };
    function W(w, E, z) {
        if (z ? (n.texParameteri(w, n.TEXTURE_WRAP_S, _e[E.wrapS]),
        n.texParameteri(w, n.TEXTURE_WRAP_T, _e[E.wrapT]),
        (w === n.TEXTURE_3D || w === n.TEXTURE_2D_ARRAY) && n.texParameteri(w, n.TEXTURE_WRAP_R, _e[E.wrapR]),
        n.texParameteri(w, n.TEXTURE_MAG_FILTER, Te[E.magFilter]),
        n.texParameteri(w, n.TEXTURE_MIN_FILTER, Te[E.minFilter])) : (n.texParameteri(w, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
        n.texParameteri(w, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
        (w === n.TEXTURE_3D || w === n.TEXTURE_2D_ARRAY) && n.texParameteri(w, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
        (E.wrapS !== qt || E.wrapT !== qt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        n.texParameteri(w, n.TEXTURE_MAG_FILTER, T(E.magFilter)),
        n.texParameteri(w, n.TEXTURE_MIN_FILTER, T(E.minFilter)),
        E.minFilter !== St && E.minFilter !== Rt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        E.compareFunction && (n.texParameteri(w, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(w, n.TEXTURE_COMPARE_FUNC, Ae[E.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const ie = e.get("EXT_texture_filter_anisotropic");
            if (E.magFilter === St || E.minFilter !== ol && E.minFilter !== Hr || E.type === xn && e.has("OES_texture_float_linear") === !1 || a === !1 && E.type === $n && e.has("OES_texture_half_float_linear") === !1)
                return;
            (E.anisotropy > 1 || i.get(E).__currentAnisotropy) && (n.texParameterf(w, ie.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(E.anisotropy, r.getMaxAnisotropy())),
            i.get(E).__currentAnisotropy = E.anisotropy)
        }
    }
    function se(w, E) {
        let z = !1;
        w.__webglInit === void 0 && (w.__webglInit = !0,
        E.addEventListener("dispose", F));
        const ie = E.source;
        let ae = m.get(ie);
        ae === void 0 && (ae = {},
        m.set(ie, ae));
        const ue = ee(E);
        if (ue !== w.__cacheKey) {
            ae[ue] === void 0 && (ae[ue] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            z = !0),
            ae[ue].usedTimes++;
            const Se = ae[w.__cacheKey];
            Se !== void 0 && (ae[w.__cacheKey].usedTimes--,
            Se.usedTimes === 0 && L(E)),
            w.__cacheKey = ue,
            w.__webglTexture = ae[ue].texture
        }
        return z
    }
    function ce(w, E, z) {
        let ie = n.TEXTURE_2D;
        (E.isDataArrayTexture || E.isCompressedArrayTexture) && (ie = n.TEXTURE_2D_ARRAY),
        E.isData3DTexture && (ie = n.TEXTURE_3D);
        const ae = se(w, E)
          , ue = E.source;
        t.bindTexture(ie, w.__webglTexture, n.TEXTURE0 + z);
        const Se = i.get(ue);
        if (ue.version !== Se.__version || ae === !0) {
            t.activeTexture(n.TEXTURE0 + z);
            const pe = et.getPrimaries(et.workingColorSpace)
              , Ee = E.colorSpace === on ? null : et.getPrimaries(E.colorSpace)
              , Ne = E.colorSpace === on || pe === Ee ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, E.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, E.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ne);
            const je = b(E) && M(E.image) === !1;
            let me = _(E.image, je, !1, u);
            me = be(E, me);
            const ke = M(me) || a
              , Le = s.convert(E.format, E.colorSpace);
            let Fe = s.convert(E.type)
              , Ue = P(E.internalFormat, Le, Fe, E.colorSpace, E.isVideoTexture);
            W(ie, E, ke);
            let U;
            const ye = E.mipmaps
              , ve = a && E.isVideoTexture !== !0
              , Re = Se.__version === void 0 || ae === !0
              , we = S(E, me, ke);
            if (E.isDepthTexture)
                Ue = n.DEPTH_COMPONENT,
                a ? E.type === xn ? Ue = n.DEPTH_COMPONENT32F : E.type === di ? Ue = n.DEPTH_COMPONENT24 : E.type === Hi ? Ue = n.DEPTH24_STENCIL8 : Ue = n.DEPTH_COMPONENT16 : E.type === xn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                E.format === ki && Ue === n.DEPTH_COMPONENT && E.type !== mu && E.type !== di && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                E.type = di,
                Fe = s.convert(E.type)),
                E.format === kr && Ue === n.DEPTH_COMPONENT && (Ue = n.DEPTH_STENCIL,
                E.type !== Hi && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                E.type = Hi,
                Fe = s.convert(E.type))),
                Re && (ve ? t.texStorage2D(n.TEXTURE_2D, 1, Ue, me.width, me.height) : t.texImage2D(n.TEXTURE_2D, 0, Ue, me.width, me.height, 0, Le, Fe, null));
            else if (E.isDataTexture)
                if (ye.length > 0 && ke) {
                    ve && Re && t.texStorage2D(n.TEXTURE_2D, we, Ue, ye[0].width, ye[0].height);
                    for (let de = 0, Pe = ye.length; de < Pe; de++)
                        U = ye[de],
                        ve ? t.texSubImage2D(n.TEXTURE_2D, de, 0, 0, U.width, U.height, Le, Fe, U.data) : t.texImage2D(n.TEXTURE_2D, de, Ue, U.width, U.height, 0, Le, Fe, U.data);
                    E.generateMipmaps = !1
                } else
                    ve ? (Re && t.texStorage2D(n.TEXTURE_2D, we, Ue, me.width, me.height),
                    t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, me.width, me.height, Le, Fe, me.data)) : t.texImage2D(n.TEXTURE_2D, 0, Ue, me.width, me.height, 0, Le, Fe, me.data);
            else if (E.isCompressedTexture)
                if (E.isCompressedArrayTexture) {
                    ve && Re && t.texStorage3D(n.TEXTURE_2D_ARRAY, we, Ue, ye[0].width, ye[0].height, me.depth);
                    for (let de = 0, Pe = ye.length; de < Pe; de++)
                        U = ye[de],
                        E.format !== vn ? Le !== null ? ve ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, de, 0, 0, 0, U.width, U.height, me.depth, Le, U.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, de, Ue, U.width, U.height, me.depth, 0, U.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ve ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, de, 0, 0, 0, U.width, U.height, me.depth, Le, Fe, U.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, de, Ue, U.width, U.height, me.depth, 0, Le, Fe, U.data)
                } else {
                    ve && Re && t.texStorage2D(n.TEXTURE_2D, we, Ue, ye[0].width, ye[0].height);
                    for (let de = 0, Pe = ye.length; de < Pe; de++)
                        U = ye[de],
                        E.format !== vn ? Le !== null ? ve ? t.compressedTexSubImage2D(n.TEXTURE_2D, de, 0, 0, U.width, U.height, Le, U.data) : t.compressedTexImage2D(n.TEXTURE_2D, de, Ue, U.width, U.height, 0, U.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ve ? t.texSubImage2D(n.TEXTURE_2D, de, 0, 0, U.width, U.height, Le, Fe, U.data) : t.texImage2D(n.TEXTURE_2D, de, Ue, U.width, U.height, 0, Le, Fe, U.data)
                }
            else if (E.isDataArrayTexture)
                ve ? (Re && t.texStorage3D(n.TEXTURE_2D_ARRAY, we, Ue, me.width, me.height, me.depth),
                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, me.width, me.height, me.depth, Le, Fe, me.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Ue, me.width, me.height, me.depth, 0, Le, Fe, me.data);
            else if (E.isData3DTexture)
                ve ? (Re && t.texStorage3D(n.TEXTURE_3D, we, Ue, me.width, me.height, me.depth),
                t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, me.width, me.height, me.depth, Le, Fe, me.data)) : t.texImage3D(n.TEXTURE_3D, 0, Ue, me.width, me.height, me.depth, 0, Le, Fe, me.data);
            else if (E.isFramebufferTexture) {
                if (Re)
                    if (ve)
                        t.texStorage2D(n.TEXTURE_2D, we, Ue, me.width, me.height);
                    else {
                        let de = me.width
                          , Pe = me.height;
                        for (let Ge = 0; Ge < we; Ge++)
                            t.texImage2D(n.TEXTURE_2D, Ge, Ue, de, Pe, 0, Le, Fe, null),
                            de >>= 1,
                            Pe >>= 1
                    }
            } else if (ye.length > 0 && ke) {
                ve && Re && t.texStorage2D(n.TEXTURE_2D, we, Ue, ye[0].width, ye[0].height);
                for (let de = 0, Pe = ye.length; de < Pe; de++)
                    U = ye[de],
                    ve ? t.texSubImage2D(n.TEXTURE_2D, de, 0, 0, Le, Fe, U) : t.texImage2D(n.TEXTURE_2D, de, Ue, Le, Fe, U);
                E.generateMipmaps = !1
            } else
                ve ? (Re && t.texStorage2D(n.TEXTURE_2D, we, Ue, me.width, me.height),
                t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Le, Fe, me)) : t.texImage2D(n.TEXTURE_2D, 0, Ue, Le, Fe, me);
            A(E, ke) && C(ie),
            Se.__version = ue.version,
            E.onUpdate && E.onUpdate(E)
        }
        w.__version = E.version
    }
    function ge(w, E, z) {
        if (E.image.length !== 6)
            return;
        const ie = se(w, E)
          , ae = E.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, w.__webglTexture, n.TEXTURE0 + z);
        const ue = i.get(ae);
        if (ae.version !== ue.__version || ie === !0) {
            t.activeTexture(n.TEXTURE0 + z);
            const Se = et.getPrimaries(et.workingColorSpace)
              , pe = E.colorSpace === on ? null : et.getPrimaries(E.colorSpace)
              , Ee = E.colorSpace === on || Se === pe ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, E.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, E.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ee);
            const Ne = E.isCompressedTexture || E.image[0].isCompressedTexture
              , je = E.image[0] && E.image[0].isDataTexture
              , me = [];
            for (let de = 0; de < 6; de++)
                !Ne && !je ? me[de] = _(E.image[de], !1, !0, c) : me[de] = je ? E.image[de].image : E.image[de],
                me[de] = be(E, me[de]);
            const ke = me[0]
              , Le = M(ke) || a
              , Fe = s.convert(E.format, E.colorSpace)
              , Ue = s.convert(E.type)
              , U = P(E.internalFormat, Fe, Ue, E.colorSpace)
              , ye = a && E.isVideoTexture !== !0
              , ve = ue.__version === void 0 || ie === !0;
            let Re = S(E, ke, Le);
            W(n.TEXTURE_CUBE_MAP, E, Le);
            let we;
            if (Ne) {
                ye && ve && t.texStorage2D(n.TEXTURE_CUBE_MAP, Re, U, ke.width, ke.height);
                for (let de = 0; de < 6; de++) {
                    we = me[de].mipmaps;
                    for (let Pe = 0; Pe < we.length; Pe++) {
                        const Ge = we[Pe];
                        E.format !== vn ? Fe !== null ? ye ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe, 0, 0, Ge.width, Ge.height, Fe, Ge.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe, U, Ge.width, Ge.height, 0, Ge.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ye ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe, 0, 0, Ge.width, Ge.height, Fe, Ue, Ge.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe, U, Ge.width, Ge.height, 0, Fe, Ue, Ge.data)
                    }
                }
            } else {
                we = E.mipmaps,
                ye && ve && (we.length > 0 && Re++,
                t.texStorage2D(n.TEXTURE_CUBE_MAP, Re, U, me[0].width, me[0].height));
                for (let de = 0; de < 6; de++)
                    if (je) {
                        ye ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, 0, 0, 0, me[de].width, me[de].height, Fe, Ue, me[de].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, 0, U, me[de].width, me[de].height, 0, Fe, Ue, me[de].data);
                        for (let Pe = 0; Pe < we.length; Pe++) {
                            const It = we[Pe].image[de].image;
                            ye ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe + 1, 0, 0, It.width, It.height, Fe, Ue, It.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe + 1, U, It.width, It.height, 0, Fe, Ue, It.data)
                        }
                    } else {
                        ye ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, 0, 0, 0, Fe, Ue, me[de]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, 0, U, Fe, Ue, me[de]);
                        for (let Pe = 0; Pe < we.length; Pe++) {
                            const Ge = we[Pe];
                            ye ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe + 1, 0, 0, Fe, Ue, Ge.image[de]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + de, Pe + 1, U, Fe, Ue, Ge.image[de])
                        }
                    }
            }
            A(E, Le) && C(n.TEXTURE_CUBE_MAP),
            ue.__version = ae.version,
            E.onUpdate && E.onUpdate(E)
        }
        w.__version = E.version
    }
    function he(w, E, z, ie, ae, ue) {
        const Se = s.convert(z.format, z.colorSpace)
          , pe = s.convert(z.type)
          , Ee = P(z.internalFormat, Se, pe, z.colorSpace);
        if (!i.get(E).__hasExternalTextures) {
            const je = Math.max(1, E.width >> ue)
              , me = Math.max(1, E.height >> ue);
            ae === n.TEXTURE_3D || ae === n.TEXTURE_2D_ARRAY ? t.texImage3D(ae, ue, Ee, je, me, E.depth, 0, Se, pe, null) : t.texImage2D(ae, ue, Ee, je, me, 0, Se, pe, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, w),
        oe(E) ? f.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, ie, ae, i.get(z).__webglTexture, 0, Y(E)) : (ae === n.TEXTURE_2D || ae >= n.TEXTURE_CUBE_MAP_POSITIVE_X && ae <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, ie, ae, i.get(z).__webglTexture, ue),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function y(w, E, z) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, w),
        E.depthBuffer && !E.stencilBuffer) {
            let ie = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
            if (z || oe(E)) {
                const ae = E.depthTexture;
                ae && ae.isDepthTexture && (ae.type === xn ? ie = n.DEPTH_COMPONENT32F : ae.type === di && (ie = n.DEPTH_COMPONENT24));
                const ue = Y(E);
                oe(E) ? f.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, ue, ie, E.width, E.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, ue, ie, E.width, E.height)
            } else
                n.renderbufferStorage(n.RENDERBUFFER, ie, E.width, E.height);
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, w)
        } else if (E.depthBuffer && E.stencilBuffer) {
            const ie = Y(E);
            z && oe(E) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, ie, n.DEPTH24_STENCIL8, E.width, E.height) : oe(E) ? f.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, ie, n.DEPTH24_STENCIL8, E.width, E.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, E.width, E.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, w)
        } else {
            const ie = E.isWebGLMultipleRenderTargets === !0 ? E.texture : [E.texture];
            for (let ae = 0; ae < ie.length; ae++) {
                const ue = ie[ae]
                  , Se = s.convert(ue.format, ue.colorSpace)
                  , pe = s.convert(ue.type)
                  , Ee = P(ue.internalFormat, Se, pe, ue.colorSpace)
                  , Ne = Y(E);
                z && oe(E) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Ne, Ee, E.width, E.height) : oe(E) ? f.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Ne, Ee, E.width, E.height) : n.renderbufferStorage(n.RENDERBUFFER, Ee, E.width, E.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function R(w, E) {
        if (E && E.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, w),
        !(E.depthTexture && E.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(E.depthTexture).__webglTexture || E.depthTexture.image.width !== E.width || E.depthTexture.image.height !== E.height) && (E.depthTexture.image.width = E.width,
        E.depthTexture.image.height = E.height,
        E.depthTexture.needsUpdate = !0),
        le(E.depthTexture, 0);
        const ie = i.get(E.depthTexture).__webglTexture
          , ae = Y(E);
        if (E.depthTexture.format === ki)
            oe(E) ? f.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, ie, 0, ae) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, ie, 0);
        else if (E.depthTexture.format === kr)
            oe(E) ? f.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, ie, 0, ae) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, ie, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function D(w) {
        const E = i.get(w)
          , z = w.isWebGLCubeRenderTarget === !0;
        if (w.depthTexture && !E.__autoAllocateDepthBuffer) {
            if (z)
                throw new Error("target.depthTexture not supported in Cube render targets");
            R(E.__webglFramebuffer, w)
        } else if (z) {
            E.__webglDepthbuffer = [];
            for (let ie = 0; ie < 6; ie++)
                t.bindFramebuffer(n.FRAMEBUFFER, E.__webglFramebuffer[ie]),
                E.__webglDepthbuffer[ie] = n.createRenderbuffer(),
                y(E.__webglDepthbuffer[ie], w, !1)
        } else
            t.bindFramebuffer(n.FRAMEBUFFER, E.__webglFramebuffer),
            E.__webglDepthbuffer = n.createRenderbuffer(),
            y(E.__webglDepthbuffer, w, !1);
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function O(w, E, z) {
        const ie = i.get(w);
        E !== void 0 && he(ie.__webglFramebuffer, w, w.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
        z !== void 0 && D(w)
    }
    function N(w) {
        const E = w.texture
          , z = i.get(w)
          , ie = i.get(E);
        w.addEventListener("dispose", k),
        w.isWebGLMultipleRenderTargets !== !0 && (ie.__webglTexture === void 0 && (ie.__webglTexture = n.createTexture()),
        ie.__version = E.version,
        o.memory.textures++);
        const ae = w.isWebGLCubeRenderTarget === !0
          , ue = w.isWebGLMultipleRenderTargets === !0
          , Se = M(w) || a;
        if (ae) {
            z.__webglFramebuffer = [];
            for (let pe = 0; pe < 6; pe++)
                if (a && E.mipmaps && E.mipmaps.length > 0) {
                    z.__webglFramebuffer[pe] = [];
                    for (let Ee = 0; Ee < E.mipmaps.length; Ee++)
                        z.__webglFramebuffer[pe][Ee] = n.createFramebuffer()
                } else
                    z.__webglFramebuffer[pe] = n.createFramebuffer()
        } else {
            if (a && E.mipmaps && E.mipmaps.length > 0) {
                z.__webglFramebuffer = [];
                for (let pe = 0; pe < E.mipmaps.length; pe++)
                    z.__webglFramebuffer[pe] = n.createFramebuffer()
            } else
                z.__webglFramebuffer = n.createFramebuffer();
            if (ue)
                if (r.drawBuffers) {
                    const pe = w.texture;
                    for (let Ee = 0, Ne = pe.length; Ee < Ne; Ee++) {
                        const je = i.get(pe[Ee]);
                        je.__webglTexture === void 0 && (je.__webglTexture = n.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && w.samples > 0 && oe(w) === !1) {
                const pe = ue ? E : [E];
                z.__webglMultisampledFramebuffer = n.createFramebuffer(),
                z.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, z.__webglMultisampledFramebuffer);
                for (let Ee = 0; Ee < pe.length; Ee++) {
                    const Ne = pe[Ee];
                    z.__webglColorRenderbuffer[Ee] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, z.__webglColorRenderbuffer[Ee]);
                    const je = s.convert(Ne.format, Ne.colorSpace)
                      , me = s.convert(Ne.type)
                      , ke = P(Ne.internalFormat, je, me, Ne.colorSpace, w.isXRRenderTarget === !0)
                      , Le = Y(w);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, Le, ke, w.width, w.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ee, n.RENDERBUFFER, z.__webglColorRenderbuffer[Ee])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                w.depthBuffer && (z.__webglDepthRenderbuffer = n.createRenderbuffer(),
                y(z.__webglDepthRenderbuffer, w, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (ae) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, ie.__webglTexture),
            W(n.TEXTURE_CUBE_MAP, E, Se);
            for (let pe = 0; pe < 6; pe++)
                if (a && E.mipmaps && E.mipmaps.length > 0)
                    for (let Ee = 0; Ee < E.mipmaps.length; Ee++)
                        he(z.__webglFramebuffer[pe][Ee], w, E, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + pe, Ee);
                else
                    he(z.__webglFramebuffer[pe], w, E, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + pe, 0);
            A(E, Se) && C(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (ue) {
            const pe = w.texture;
            for (let Ee = 0, Ne = pe.length; Ee < Ne; Ee++) {
                const je = pe[Ee]
                  , me = i.get(je);
                t.bindTexture(n.TEXTURE_2D, me.__webglTexture),
                W(n.TEXTURE_2D, je, Se),
                he(z.__webglFramebuffer, w, je, n.COLOR_ATTACHMENT0 + Ee, n.TEXTURE_2D, 0),
                A(je, Se) && C(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let pe = n.TEXTURE_2D;
            if ((w.isWebGL3DRenderTarget || w.isWebGLArrayRenderTarget) && (a ? pe = w.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(pe, ie.__webglTexture),
            W(pe, E, Se),
            a && E.mipmaps && E.mipmaps.length > 0)
                for (let Ee = 0; Ee < E.mipmaps.length; Ee++)
                    he(z.__webglFramebuffer[Ee], w, E, n.COLOR_ATTACHMENT0, pe, Ee);
            else
                he(z.__webglFramebuffer, w, E, n.COLOR_ATTACHMENT0, pe, 0);
            A(E, Se) && C(pe),
            t.unbindTexture()
        }
        w.depthBuffer && D(w)
    }
    function j(w) {
        const E = M(w) || a
          , z = w.isWebGLMultipleRenderTargets === !0 ? w.texture : [w.texture];
        for (let ie = 0, ae = z.length; ie < ae; ie++) {
            const ue = z[ie];
            if (A(ue, E)) {
                const Se = w.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D
                  , pe = i.get(ue).__webglTexture;
                t.bindTexture(Se, pe),
                C(Se),
                t.unbindTexture()
            }
        }
    }
    function Z(w) {
        if (a && w.samples > 0 && oe(w) === !1) {
            const E = w.isWebGLMultipleRenderTargets ? w.texture : [w.texture]
              , z = w.width
              , ie = w.height;
            let ae = n.COLOR_BUFFER_BIT;
            const ue = []
              , Se = w.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , pe = i.get(w)
              , Ee = w.isWebGLMultipleRenderTargets === !0;
            if (Ee)
                for (let Ne = 0; Ne < E.length; Ne++)
                    t.bindFramebuffer(n.FRAMEBUFFER, pe.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ne, n.RENDERBUFFER, null),
                    t.bindFramebuffer(n.FRAMEBUFFER, pe.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ne, n.TEXTURE_2D, null, 0);
            t.bindFramebuffer(n.READ_FRAMEBUFFER, pe.__webglMultisampledFramebuffer),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, pe.__webglFramebuffer);
            for (let Ne = 0; Ne < E.length; Ne++) {
                ue.push(n.COLOR_ATTACHMENT0 + Ne),
                w.depthBuffer && ue.push(Se);
                const je = pe.__ignoreDepthValues !== void 0 ? pe.__ignoreDepthValues : !1;
                if (je === !1 && (w.depthBuffer && (ae |= n.DEPTH_BUFFER_BIT),
                w.stencilBuffer && (ae |= n.STENCIL_BUFFER_BIT)),
                Ee && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, pe.__webglColorRenderbuffer[Ne]),
                je === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Se]),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Se])),
                Ee) {
                    const me = i.get(E[Ne]).__webglTexture;
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, me, 0)
                }
                n.blitFramebuffer(0, 0, z, ie, 0, 0, z, ie, ae, n.NEAREST),
                p && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, ue)
            }
            if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
            Ee)
                for (let Ne = 0; Ne < E.length; Ne++) {
                    t.bindFramebuffer(n.FRAMEBUFFER, pe.__webglMultisampledFramebuffer),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ne, n.RENDERBUFFER, pe.__webglColorRenderbuffer[Ne]);
                    const je = i.get(E[Ne]).__webglTexture;
                    t.bindFramebuffer(n.FRAMEBUFFER, pe.__webglFramebuffer),
                    n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ne, n.TEXTURE_2D, je, 0)
                }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, pe.__webglMultisampledFramebuffer)
        }
    }
    function Y(w) {
        return Math.min(h, w.samples)
    }
    function oe(w) {
        const E = i.get(w);
        return a && w.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && E.__useRenderToTexture !== !1
    }
    function Q(w) {
        const E = o.render.frame;
        g.get(w) !== E && (g.set(w, E),
        w.update())
    }
    function be(w, E) {
        const z = w.colorSpace
          , ie = w.format
          , ae = w.type;
        return w.isCompressedTexture === !0 || w.isVideoTexture === !0 || w.format === Ec || z !== Ln && z !== on && (et.getTransfer(z) === it ? a === !1 ? e.has("EXT_sRGB") === !0 && ie === vn ? (w.format = Ec,
        w.minFilter = Rt,
        w.generateMipmaps = !1) : E = Bm.sRGBToLinear(E) : (ie !== vn || ae !== vi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", z)),
        E
    }
    this.allocateTextureUnit = re,
    this.resetTextureUnits = $,
    this.setTexture2D = le,
    this.setTexture2DArray = B,
    this.setTexture3D = J,
    this.setTextureCube = fe,
    this.rebindTextures = O,
    this.setupRenderTarget = N,
    this.updateRenderTargetMipmap = j,
    this.updateMultisampleRenderTarget = Z,
    this.setupDepthRenderbuffer = D,
    this.setupFrameBufferTexture = he,
    this.useMultisampledRTT = oe
}
function C1(n, e, t) {
    const i = t.isWebGL2;
    function r(s, o=on) {
        let a;
        const l = et.getTransfer(o);
        if (s === vi)
            return n.UNSIGNED_BYTE;
        if (s === Dm)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (s === Im)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (s === uS)
            return n.BYTE;
        if (s === hS)
            return n.SHORT;
        if (s === mu)
            return n.UNSIGNED_SHORT;
        if (s === Lm)
            return n.INT;
        if (s === di)
            return n.UNSIGNED_INT;
        if (s === xn)
            return n.FLOAT;
        if (s === $n)
            return i ? n.HALF_FLOAT : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (s === fS)
            return n.ALPHA;
        if (s === vn)
            return n.RGBA;
        if (s === dS)
            return n.LUMINANCE;
        if (s === pS)
            return n.LUMINANCE_ALPHA;
        if (s === ki)
            return n.DEPTH_COMPONENT;
        if (s === kr)
            return n.DEPTH_STENCIL;
        if (s === Ec)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === mS)
            return n.RED;
        if (s === Um)
            return n.RED_INTEGER;
        if (s === gS)
            return n.RG;
        if (s === Nm)
            return n.RG_INTEGER;
        if (s === Fm)
            return n.RGBA_INTEGER;
        if (s === al || s === ll || s === cl || s === ul)
            if (l === it)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (s === al)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === ll)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === cl)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === ul)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (s === al)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === ll)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === cl)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === ul)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (s === af || s === lf || s === cf || s === uf)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (s === af)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === lf)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === cf)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === uf)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (s === _S)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === hf || s === ff)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (s === hf)
                    return l === it ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === ff)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (s === df || s === pf || s === mf || s === gf || s === _f || s === vf || s === xf || s === yf || s === Mf || s === Sf || s === Ef || s === bf || s === Tf || s === wf)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (s === df)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === pf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === mf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === gf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === _f)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === vf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === xf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === yf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === Mf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === Sf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === Ef)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === bf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === Tf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === wf)
                    return l === it ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (s === hl || s === Af || s === Rf)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (s === hl)
                    return l === it ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (s === Af)
                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (s === Rf)
                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (s === vS || s === Cf || s === Pf || s === Lf)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (s === hl)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === Cf)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === Pf)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === Lf)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return s === Hi ? i ? n.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class P1 extends sn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Gt extends Ct {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const L1 = {
    type: "move"
};
class Nl {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Gt,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Gt,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new H,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new H),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Gt,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new H,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new H),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const x of e.hand.values()) {
                    const m = t.getJointPose(x, i)
                      , d = this._getHandJoint(c, x);
                    m !== null && (d.matrix.fromArray(m.transform.matrix),
                    d.matrix.decompose(d.position, d.rotation, d.scale),
                    d.matrixWorldNeedsUpdate = !0,
                    d.jointRadius = m.radius),
                    d.visible = m !== null
                }
                const u = c.joints["index-finger-tip"]
                  , h = c.joints["thumb-tip"]
                  , f = u.position.distanceTo(h.position)
                  , p = .02
                  , g = .005;
                c.inputState.pinching && f > p + g ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && f <= p - g && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(L1)))
        }
        return a !== null && (a.visible = r !== null),
        l !== null && (l.visible = s !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new Gt;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class D1 extends zt {
    constructor(e, t, i, r, s, o, a, l, c, u) {
        if (u = u !== void 0 ? u : ki,
        u !== ki && u !== kr)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && u === ki && (i = di),
        i === void 0 && u === kr && (i = Hi),
        super(null, r, s, o, a, l, u, i, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : St,
        this.minFilter = l !== void 0 ? l : St,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
class I1 extends Kr {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , u = null
          , h = null
          , f = null
          , p = null
          , g = null;
        const x = t.getContextAttributes();
        let m = null
          , d = null;
        const v = []
          , _ = []
          , M = new sn;
        M.layers.enable(1),
        M.viewport = new bt;
        const b = new sn;
        b.layers.enable(2),
        b.viewport = new bt;
        const A = [M, b]
          , C = new P1;
        C.layers.enable(1),
        C.layers.enable(2);
        let P = null
          , S = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(B) {
            let J = v[B];
            return J === void 0 && (J = new Nl,
            v[B] = J),
            J.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(B) {
            let J = v[B];
            return J === void 0 && (J = new Nl,
            v[B] = J),
            J.getGripSpace()
        }
        ,
        this.getHand = function(B) {
            let J = v[B];
            return J === void 0 && (J = new Nl,
            v[B] = J),
            J.getHandSpace()
        }
        ;
        function T(B) {
            const J = _.indexOf(B.inputSource);
            if (J === -1)
                return;
            const fe = v[J];
            fe !== void 0 && (fe.update(B.inputSource, B.frame, c || o),
            fe.dispatchEvent({
                type: B.type,
                data: B.inputSource
            }))
        }
        function F() {
            r.removeEventListener("select", T),
            r.removeEventListener("selectstart", T),
            r.removeEventListener("selectend", T),
            r.removeEventListener("squeeze", T),
            r.removeEventListener("squeezestart", T),
            r.removeEventListener("squeezeend", T),
            r.removeEventListener("end", F),
            r.removeEventListener("inputsourceschange", k);
            for (let B = 0; B < v.length; B++) {
                const J = _[B];
                J !== null && (_[B] = null,
                v[B].disconnect(J))
            }
            P = null,
            S = null,
            e.setRenderTarget(m),
            p = null,
            f = null,
            h = null,
            r = null,
            d = null,
            le.stop(),
            i.isPresenting = !1,
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(B) {
            s = B,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(B) {
            a = B,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(B) {
            c = B
        }
        ,
        this.getBaseLayer = function() {
            return f !== null ? f : p
        }
        ,
        this.getBinding = function() {
            return h
        }
        ,
        this.getFrame = function() {
            return g
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(B) {
            if (r = B,
            r !== null) {
                if (m = e.getRenderTarget(),
                r.addEventListener("select", T),
                r.addEventListener("selectstart", T),
                r.addEventListener("selectend", T),
                r.addEventListener("squeeze", T),
                r.addEventListener("squeezestart", T),
                r.addEventListener("squeezeend", T),
                r.addEventListener("end", F),
                r.addEventListener("inputsourceschange", k),
                x.xrCompatible !== !0 && await t.makeXRCompatible(),
                r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const J = {
                        antialias: r.renderState.layers === void 0 ? x.antialias : !0,
                        alpha: !0,
                        depth: x.depth,
                        stencil: x.stencil,
                        framebufferScaleFactor: s
                    };
                    p = new XRWebGLLayer(r,t,J),
                    r.updateRenderState({
                        baseLayer: p
                    }),
                    d = new Wi(p.framebufferWidth,p.framebufferHeight,{
                        format: vn,
                        type: vi,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: x.stencil
                    })
                } else {
                    let J = null
                      , fe = null
                      , _e = null;
                    x.depth && (_e = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    J = x.stencil ? kr : ki,
                    fe = x.stencil ? Hi : di);
                    const Te = {
                        colorFormat: t.RGBA8,
                        depthFormat: _e,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r,t),
                    f = h.createProjectionLayer(Te),
                    r.updateRenderState({
                        layers: [f]
                    }),
                    d = new Wi(f.textureWidth,f.textureHeight,{
                        format: vn,
                        type: vi,
                        depthTexture: new D1(f.textureWidth,f.textureHeight,fe,void 0,void 0,void 0,void 0,void 0,void 0,J),
                        stencilBuffer: x.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: x.antialias ? 4 : 0
                    });
                    const Ae = e.properties.get(d);
                    Ae.__ignoreDepthValues = f.ignoreDepthValues
                }
                d.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await r.requestReferenceSpace(a),
                le.setContext(r),
                le.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ;
        function k(B) {
            for (let J = 0; J < B.removed.length; J++) {
                const fe = B.removed[J]
                  , _e = _.indexOf(fe);
                _e >= 0 && (_[_e] = null,
                v[_e].disconnect(fe))
            }
            for (let J = 0; J < B.added.length; J++) {
                const fe = B.added[J];
                let _e = _.indexOf(fe);
                if (_e === -1) {
                    for (let Ae = 0; Ae < v.length; Ae++)
                        if (Ae >= _.length) {
                            _.push(fe),
                            _e = Ae;
                            break
                        } else if (_[Ae] === null) {
                            _[Ae] = fe,
                            _e = Ae;
                            break
                        }
                    if (_e === -1)
                        break
                }
                const Te = v[_e];
                Te && Te.connect(fe)
            }
        }
        const X = new H
          , L = new H;
        function G(B, J, fe) {
            X.setFromMatrixPosition(J.matrixWorld),
            L.setFromMatrixPosition(fe.matrixWorld);
            const _e = X.distanceTo(L)
              , Te = J.projectionMatrix.elements
              , Ae = fe.projectionMatrix.elements
              , W = Te[14] / (Te[10] - 1)
              , se = Te[14] / (Te[10] + 1)
              , ce = (Te[9] + 1) / Te[5]
              , ge = (Te[9] - 1) / Te[5]
              , he = (Te[8] - 1) / Te[0]
              , y = (Ae[8] + 1) / Ae[0]
              , R = W * he
              , D = W * y
              , O = _e / (-he + y)
              , N = O * -he;
            J.matrixWorld.decompose(B.position, B.quaternion, B.scale),
            B.translateX(N),
            B.translateZ(O),
            B.matrixWorld.compose(B.position, B.quaternion, B.scale),
            B.matrixWorldInverse.copy(B.matrixWorld).invert();
            const j = W + O
              , Z = se + O
              , Y = R - N
              , oe = D + (_e - N)
              , Q = ce * se / Z * j
              , be = ge * se / Z * j;
            B.projectionMatrix.makePerspective(Y, oe, Q, be, j, Z),
            B.projectionMatrixInverse.copy(B.projectionMatrix).invert()
        }
        function V(B, J) {
            J === null ? B.matrixWorld.copy(B.matrix) : B.matrixWorld.multiplyMatrices(J.matrixWorld, B.matrix),
            B.matrixWorldInverse.copy(B.matrixWorld).invert()
        }
        this.updateCamera = function(B) {
            if (r === null)
                return;
            C.near = b.near = M.near = B.near,
            C.far = b.far = M.far = B.far,
            (P !== C.near || S !== C.far) && (r.updateRenderState({
                depthNear: C.near,
                depthFar: C.far
            }),
            P = C.near,
            S = C.far);
            const J = B.parent
              , fe = C.cameras;
            V(C, J);
            for (let _e = 0; _e < fe.length; _e++)
                V(fe[_e], J);
            fe.length === 2 ? G(C, M, b) : C.projectionMatrix.copy(M.projectionMatrix),
            $(B, C, J)
        }
        ;
        function $(B, J, fe) {
            fe === null ? B.matrix.copy(J.matrixWorld) : (B.matrix.copy(fe.matrixWorld),
            B.matrix.invert(),
            B.matrix.multiply(J.matrixWorld)),
            B.matrix.decompose(B.position, B.quaternion, B.scale),
            B.updateMatrixWorld(!0),
            B.projectionMatrix.copy(J.projectionMatrix),
            B.projectionMatrixInverse.copy(J.projectionMatrixInverse),
            B.isPerspectiveCamera && (B.fov = bc * 2 * Math.atan(1 / B.projectionMatrix.elements[5]),
            B.zoom = 1)
        }
        this.getCamera = function() {
            return C
        }
        ,
        this.getFoveation = function() {
            if (!(f === null && p === null))
                return l
        }
        ,
        this.setFoveation = function(B) {
            l = B,
            f !== null && (f.fixedFoveation = B),
            p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = B)
        }
        ;
        let re = null;
        function ee(B, J) {
            if (u = J.getViewerPose(c || o),
            g = J,
            u !== null) {
                const fe = u.views;
                p !== null && (e.setRenderTargetFramebuffer(d, p.framebuffer),
                e.setRenderTarget(d));
                let _e = !1;
                fe.length !== C.cameras.length && (C.cameras.length = 0,
                _e = !0);
                for (let Te = 0; Te < fe.length; Te++) {
                    const Ae = fe[Te];
                    let W = null;
                    if (p !== null)
                        W = p.getViewport(Ae);
                    else {
                        const ce = h.getViewSubImage(f, Ae);
                        W = ce.viewport,
                        Te === 0 && (e.setRenderTargetTextures(d, ce.colorTexture, f.ignoreDepthValues ? void 0 : ce.depthStencilTexture),
                        e.setRenderTarget(d))
                    }
                    let se = A[Te];
                    se === void 0 && (se = new sn,
                    se.layers.enable(Te),
                    se.viewport = new bt,
                    A[Te] = se),
                    se.matrix.fromArray(Ae.transform.matrix),
                    se.matrix.decompose(se.position, se.quaternion, se.scale),
                    se.projectionMatrix.fromArray(Ae.projectionMatrix),
                    se.projectionMatrixInverse.copy(se.projectionMatrix).invert(),
                    se.viewport.set(W.x, W.y, W.width, W.height),
                    Te === 0 && (C.matrix.copy(se.matrix),
                    C.matrix.decompose(C.position, C.quaternion, C.scale)),
                    _e === !0 && C.cameras.push(se)
                }
            }
            for (let fe = 0; fe < v.length; fe++) {
                const _e = _[fe]
                  , Te = v[fe];
                _e !== null && Te !== void 0 && Te.update(_e, J, c || o)
            }
            re && re(B, J),
            J.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: J
            }),
            g = null
        }
        const le = new qm;
        le.setAnimationLoop(ee),
        this.setAnimationLoop = function(B) {
            re = B
        }
        ,
        this.dispose = function() {}
    }
}
function U1(n, e) {
    function t(m, d) {
        m.matrixAutoUpdate === !0 && m.updateMatrix(),
        d.value.copy(m.matrix)
    }
    function i(m, d) {
        d.color.getRGB(m.fogColor.value, $m(n)),
        d.isFog ? (m.fogNear.value = d.near,
        m.fogFar.value = d.far) : d.isFogExp2 && (m.fogDensity.value = d.density)
    }
    function r(m, d, v, _, M) {
        d.isMeshBasicMaterial || d.isMeshLambertMaterial ? s(m, d) : d.isMeshToonMaterial ? (s(m, d),
        h(m, d)) : d.isMeshPhongMaterial ? (s(m, d),
        u(m, d)) : d.isMeshStandardMaterial ? (s(m, d),
        f(m, d),
        d.isMeshPhysicalMaterial && p(m, d, M)) : d.isMeshMatcapMaterial ? (s(m, d),
        g(m, d)) : d.isMeshDepthMaterial ? s(m, d) : d.isMeshDistanceMaterial ? (s(m, d),
        x(m, d)) : d.isMeshNormalMaterial ? s(m, d) : d.isLineBasicMaterial ? (o(m, d),
        d.isLineDashedMaterial && a(m, d)) : d.isPointsMaterial ? l(m, d, v, _) : d.isSpriteMaterial ? c(m, d) : d.isShadowMaterial ? (m.color.value.copy(d.color),
        m.opacity.value = d.opacity) : d.isShaderMaterial && (d.uniformsNeedUpdate = !1)
    }
    function s(m, d) {
        m.opacity.value = d.opacity,
        d.color && m.diffuse.value.copy(d.color),
        d.emissive && m.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),
        d.map && (m.map.value = d.map,
        t(d.map, m.mapTransform)),
        d.alphaMap && (m.alphaMap.value = d.alphaMap,
        t(d.alphaMap, m.alphaMapTransform)),
        d.bumpMap && (m.bumpMap.value = d.bumpMap,
        t(d.bumpMap, m.bumpMapTransform),
        m.bumpScale.value = d.bumpScale,
        d.side === Wt && (m.bumpScale.value *= -1)),
        d.normalMap && (m.normalMap.value = d.normalMap,
        t(d.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(d.normalScale),
        d.side === Wt && m.normalScale.value.negate()),
        d.displacementMap && (m.displacementMap.value = d.displacementMap,
        t(d.displacementMap, m.displacementMapTransform),
        m.displacementScale.value = d.displacementScale,
        m.displacementBias.value = d.displacementBias),
        d.emissiveMap && (m.emissiveMap.value = d.emissiveMap,
        t(d.emissiveMap, m.emissiveMapTransform)),
        d.specularMap && (m.specularMap.value = d.specularMap,
        t(d.specularMap, m.specularMapTransform)),
        d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest);
        const v = e.get(d).envMap;
        if (v && (m.envMap.value = v,
        m.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1,
        m.reflectivity.value = d.reflectivity,
        m.ior.value = d.ior,
        m.refractionRatio.value = d.refractionRatio),
        d.lightMap) {
            m.lightMap.value = d.lightMap;
            const _ = n._useLegacyLights === !0 ? Math.PI : 1;
            m.lightMapIntensity.value = d.lightMapIntensity * _,
            t(d.lightMap, m.lightMapTransform)
        }
        d.aoMap && (m.aoMap.value = d.aoMap,
        m.aoMapIntensity.value = d.aoMapIntensity,
        t(d.aoMap, m.aoMapTransform))
    }
    function o(m, d) {
        m.diffuse.value.copy(d.color),
        m.opacity.value = d.opacity,
        d.map && (m.map.value = d.map,
        t(d.map, m.mapTransform))
    }
    function a(m, d) {
        m.dashSize.value = d.dashSize,
        m.totalSize.value = d.dashSize + d.gapSize,
        m.scale.value = d.scale
    }
    function l(m, d, v, _) {
        m.diffuse.value.copy(d.color),
        m.opacity.value = d.opacity,
        m.size.value = d.size * v,
        m.scale.value = _ * .5,
        d.map && (m.map.value = d.map,
        t(d.map, m.uvTransform)),
        d.alphaMap && (m.alphaMap.value = d.alphaMap,
        t(d.alphaMap, m.alphaMapTransform)),
        d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest)
    }
    function c(m, d) {
        m.diffuse.value.copy(d.color),
        m.opacity.value = d.opacity,
        m.rotation.value = d.rotation,
        d.map && (m.map.value = d.map,
        t(d.map, m.mapTransform)),
        d.alphaMap && (m.alphaMap.value = d.alphaMap,
        t(d.alphaMap, m.alphaMapTransform)),
        d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest)
    }
    function u(m, d) {
        m.specular.value.copy(d.specular),
        m.shininess.value = Math.max(d.shininess, 1e-4)
    }
    function h(m, d) {
        d.gradientMap && (m.gradientMap.value = d.gradientMap)
    }
    function f(m, d) {
        m.metalness.value = d.metalness,
        d.metalnessMap && (m.metalnessMap.value = d.metalnessMap,
        t(d.metalnessMap, m.metalnessMapTransform)),
        m.roughness.value = d.roughness,
        d.roughnessMap && (m.roughnessMap.value = d.roughnessMap,
        t(d.roughnessMap, m.roughnessMapTransform)),
        e.get(d).envMap && (m.envMapIntensity.value = d.envMapIntensity)
    }
    function p(m, d, v) {
        m.ior.value = d.ior,
        d.sheen > 0 && (m.sheenColor.value.copy(d.sheenColor).multiplyScalar(d.sheen),
        m.sheenRoughness.value = d.sheenRoughness,
        d.sheenColorMap && (m.sheenColorMap.value = d.sheenColorMap,
        t(d.sheenColorMap, m.sheenColorMapTransform)),
        d.sheenRoughnessMap && (m.sheenRoughnessMap.value = d.sheenRoughnessMap,
        t(d.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
        d.clearcoat > 0 && (m.clearcoat.value = d.clearcoat,
        m.clearcoatRoughness.value = d.clearcoatRoughness,
        d.clearcoatMap && (m.clearcoatMap.value = d.clearcoatMap,
        t(d.clearcoatMap, m.clearcoatMapTransform)),
        d.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = d.clearcoatRoughnessMap,
        t(d.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        d.clearcoatNormalMap && (m.clearcoatNormalMap.value = d.clearcoatNormalMap,
        t(d.clearcoatNormalMap, m.clearcoatNormalMapTransform),
        m.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),
        d.side === Wt && m.clearcoatNormalScale.value.negate())),
        d.iridescence > 0 && (m.iridescence.value = d.iridescence,
        m.iridescenceIOR.value = d.iridescenceIOR,
        m.iridescenceThicknessMinimum.value = d.iridescenceThicknessRange[0],
        m.iridescenceThicknessMaximum.value = d.iridescenceThicknessRange[1],
        d.iridescenceMap && (m.iridescenceMap.value = d.iridescenceMap,
        t(d.iridescenceMap, m.iridescenceMapTransform)),
        d.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = d.iridescenceThicknessMap,
        t(d.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
        d.transmission > 0 && (m.transmission.value = d.transmission,
        m.transmissionSamplerMap.value = v.texture,
        m.transmissionSamplerSize.value.set(v.width, v.height),
        d.transmissionMap && (m.transmissionMap.value = d.transmissionMap,
        t(d.transmissionMap, m.transmissionMapTransform)),
        m.thickness.value = d.thickness,
        d.thicknessMap && (m.thicknessMap.value = d.thicknessMap,
        t(d.thicknessMap, m.thicknessMapTransform)),
        m.attenuationDistance.value = d.attenuationDistance,
        m.attenuationColor.value.copy(d.attenuationColor)),
        d.anisotropy > 0 && (m.anisotropyVector.value.set(d.anisotropy * Math.cos(d.anisotropyRotation), d.anisotropy * Math.sin(d.anisotropyRotation)),
        d.anisotropyMap && (m.anisotropyMap.value = d.anisotropyMap,
        t(d.anisotropyMap, m.anisotropyMapTransform))),
        m.specularIntensity.value = d.specularIntensity,
        m.specularColor.value.copy(d.specularColor),
        d.specularColorMap && (m.specularColorMap.value = d.specularColorMap,
        t(d.specularColorMap, m.specularColorMapTransform)),
        d.specularIntensityMap && (m.specularIntensityMap.value = d.specularIntensityMap,
        t(d.specularIntensityMap, m.specularIntensityMapTransform))
    }
    function g(m, d) {
        d.matcap && (m.matcap.value = d.matcap)
    }
    function x(m, d) {
        const v = e.get(d).light;
        m.referencePosition.value.setFromMatrixPosition(v.matrixWorld),
        m.nearDistance.value = v.shadow.camera.near,
        m.farDistance.value = v.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}
function N1(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function l(v, _) {
        const M = _.program;
        i.uniformBlockBinding(v, M)
    }
    function c(v, _) {
        let M = r[v.id];
        M === void 0 && (g(v),
        M = u(v),
        r[v.id] = M,
        v.addEventListener("dispose", m));
        const b = _.program;
        i.updateUBOMapping(v, b);
        const A = e.render.frame;
        s[v.id] !== A && (f(v),
        s[v.id] = A)
    }
    function u(v) {
        const _ = h();
        v.__bindingPointIndex = _;
        const M = n.createBuffer()
          , b = v.__size
          , A = v.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, M),
        n.bufferData(n.UNIFORM_BUFFER, b, A),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, _, M),
        M
    }
    function h() {
        for (let v = 0; v < a; v++)
            if (o.indexOf(v) === -1)
                return o.push(v),
                v;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function f(v) {
        const _ = r[v.id]
          , M = v.uniforms
          , b = v.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, _);
        for (let A = 0, C = M.length; A < C; A++) {
            const P = M[A];
            if (p(P, A, b) === !0) {
                const S = P.__offset
                  , T = Array.isArray(P.value) ? P.value : [P.value];
                let F = 0;
                for (let k = 0; k < T.length; k++) {
                    const X = T[k]
                      , L = x(X);
                    typeof X == "number" ? (P.__data[0] = X,
                    n.bufferSubData(n.UNIFORM_BUFFER, S + F, P.__data)) : X.isMatrix3 ? (P.__data[0] = X.elements[0],
                    P.__data[1] = X.elements[1],
                    P.__data[2] = X.elements[2],
                    P.__data[3] = X.elements[0],
                    P.__data[4] = X.elements[3],
                    P.__data[5] = X.elements[4],
                    P.__data[6] = X.elements[5],
                    P.__data[7] = X.elements[0],
                    P.__data[8] = X.elements[6],
                    P.__data[9] = X.elements[7],
                    P.__data[10] = X.elements[8],
                    P.__data[11] = X.elements[0]) : (X.toArray(P.__data, F),
                    F += L.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                n.bufferSubData(n.UNIFORM_BUFFER, S, P.__data)
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function p(v, _, M) {
        const b = v.value;
        if (M[_] === void 0) {
            if (typeof b == "number")
                M[_] = b;
            else {
                const A = Array.isArray(b) ? b : [b]
                  , C = [];
                for (let P = 0; P < A.length; P++)
                    C.push(A[P].clone());
                M[_] = C
            }
            return !0
        } else if (typeof b == "number") {
            if (M[_] !== b)
                return M[_] = b,
                !0
        } else {
            const A = Array.isArray(M[_]) ? M[_] : [M[_]]
              , C = Array.isArray(b) ? b : [b];
            for (let P = 0; P < A.length; P++) {
                const S = A[P];
                if (S.equals(C[P]) === !1)
                    return S.copy(C[P]),
                    !0
            }
        }
        return !1
    }
    function g(v) {
        const _ = v.uniforms;
        let M = 0;
        const b = 16;
        let A = 0;
        for (let C = 0, P = _.length; C < P; C++) {
            const S = _[C]
              , T = {
                boundary: 0,
                storage: 0
            }
              , F = Array.isArray(S.value) ? S.value : [S.value];
            for (let k = 0, X = F.length; k < X; k++) {
                const L = F[k]
                  , G = x(L);
                T.boundary += G.boundary,
                T.storage += G.storage
            }
            if (S.__data = new Float32Array(T.storage / Float32Array.BYTES_PER_ELEMENT),
            S.__offset = M,
            C > 0) {
                A = M % b;
                const k = b - A;
                A !== 0 && k - T.boundary < 0 && (M += b - A,
                S.__offset = M)
            }
            M += T.storage
        }
        return A = M % b,
        A > 0 && (M += b - A),
        v.__size = M,
        v.__cache = {},
        this
    }
    function x(v) {
        const _ = {
            boundary: 0,
            storage: 0
        };
        return typeof v == "number" ? (_.boundary = 4,
        _.storage = 4) : v.isVector2 ? (_.boundary = 8,
        _.storage = 8) : v.isVector3 || v.isColor ? (_.boundary = 16,
        _.storage = 12) : v.isVector4 ? (_.boundary = 16,
        _.storage = 16) : v.isMatrix3 ? (_.boundary = 48,
        _.storage = 48) : v.isMatrix4 ? (_.boundary = 64,
        _.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v),
        _
    }
    function m(v) {
        const _ = v.target;
        _.removeEventListener("dispose", m);
        const M = o.indexOf(_.__bindingPointIndex);
        o.splice(M, 1),
        n.deleteBuffer(r[_.id]),
        delete r[_.id],
        delete s[_.id]
    }
    function d() {
        for (const v in r)
            n.deleteBuffer(r[v]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: d
    }
}
class tg {
    constructor(e={}) {
        const {canvas: t=DS(), context: i=null, depth: r=!0, stencil: s=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: h=!1} = e;
        this.isWebGLRenderer = !0;
        let f;
        i !== null ? f = i.getContextAttributes().alpha : f = o;
        const p = new Uint32Array(4)
          , g = new Int32Array(4);
        let x = null
          , m = null;
        const d = []
          , v = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = At,
        this._useLegacyLights = !1,
        this.toneMapping = _i,
        this.toneMappingExposure = 1;
        const _ = this;
        let M = !1
          , b = 0
          , A = 0
          , C = null
          , P = -1
          , S = null;
        const T = new bt
          , F = new bt;
        let k = null;
        const X = new Xe(0);
        let L = 0
          , G = t.width
          , V = t.height
          , $ = 1
          , re = null
          , ee = null;
        const le = new bt(0,0,G,V)
          , B = new bt(0,0,G,V);
        let J = !1;
        const fe = new xu;
        let _e = !1
          , Te = !1
          , Ae = null;
        const W = new ht
          , se = new xe
          , ce = new H
          , ge = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function he() {
            return C === null ? $ : 1
        }
        let y = i;
        function R(I, K) {
            for (let te = 0; te < I.length; te++) {
                const q = I[te]
                  , ne = t.getContext(q, K);
                if (ne !== null)
                    return ne
            }
            return null
        }
        try {
            const I = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${pu}`),
            t.addEventListener("webglcontextlost", ye, !1),
            t.addEventListener("webglcontextrestored", ve, !1),
            t.addEventListener("webglcontextcreationerror", Re, !1),
            y === null) {
                const K = ["webgl2", "webgl", "experimental-webgl"];
                if (_.isWebGL1Renderer === !0 && K.shift(),
                y = R(K, I),
                y === null)
                    throw R(K) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            typeof WebGLRenderingContext < "u" && y instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
            y.getShaderPrecisionFormat === void 0 && (y.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (I) {
            throw console.error("THREE.WebGLRenderer: " + I.message),
            I
        }
        let D, O, N, j, Z, Y, oe, Q, be, w, E, z, ie, ae, ue, Se, pe, Ee, Ne, je, me, ke, Le, Fe;
        function Ue() {
            D = new $T(y),
            O = new HT(y,D,e),
            D.init(O),
            ke = new C1(y,D,O),
            N = new A1(y,D,O),
            j = new qT(y),
            Z = new d1,
            Y = new R1(y,D,N,Z,O,ke,j),
            oe = new GT(_),
            Q = new XT(_),
            be = new sE(y,O),
            Le = new zT(y,D,be,O),
            w = new jT(y,be,j,Le),
            E = new QT(y,w,be,j),
            Ne = new ZT(y,O,Y),
            Se = new kT(Z),
            z = new f1(_,oe,Q,D,O,Le,Se),
            ie = new U1(_,Z),
            ae = new m1,
            ue = new M1(D,O),
            Ee = new OT(_,oe,Q,N,E,f,l),
            pe = new w1(_,E,O),
            Fe = new N1(y,j,O,N),
            je = new BT(y,D,j,O),
            me = new KT(y,D,j,O),
            j.programs = z.programs,
            _.capabilities = O,
            _.extensions = D,
            _.properties = Z,
            _.renderLists = ae,
            _.shadowMap = pe,
            _.state = N,
            _.info = j
        }
        Ue();
        const U = new I1(_,y);
        this.xr = U,
        this.getContext = function() {
            return y
        }
        ,
        this.getContextAttributes = function() {
            return y.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const I = D.get("WEBGL_lose_context");
            I && I.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const I = D.get("WEBGL_lose_context");
            I && I.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return $
        }
        ,
        this.setPixelRatio = function(I) {
            I !== void 0 && ($ = I,
            this.setSize(G, V, !1))
        }
        ,
        this.getSize = function(I) {
            return I.set(G, V)
        }
        ,
        this.setSize = function(I, K, te=!0) {
            if (U.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            G = I,
            V = K,
            t.width = Math.floor(I * $),
            t.height = Math.floor(K * $),
            te === !0 && (t.style.width = I + "px",
            t.style.height = K + "px"),
            this.setViewport(0, 0, I, K)
        }
        ,
        this.getDrawingBufferSize = function(I) {
            return I.set(G * $, V * $).floor()
        }
        ,
        this.setDrawingBufferSize = function(I, K, te) {
            G = I,
            V = K,
            $ = te,
            t.width = Math.floor(I * te),
            t.height = Math.floor(K * te),
            this.setViewport(0, 0, I, K)
        }
        ,
        this.getCurrentViewport = function(I) {
            return I.copy(T)
        }
        ,
        this.getViewport = function(I) {
            return I.copy(le)
        }
        ,
        this.setViewport = function(I, K, te, q) {
            I.isVector4 ? le.set(I.x, I.y, I.z, I.w) : le.set(I, K, te, q),
            N.viewport(T.copy(le).multiplyScalar($).floor())
        }
        ,
        this.getScissor = function(I) {
            return I.copy(B)
        }
        ,
        this.setScissor = function(I, K, te, q) {
            I.isVector4 ? B.set(I.x, I.y, I.z, I.w) : B.set(I, K, te, q),
            N.scissor(F.copy(B).multiplyScalar($).floor())
        }
        ,
        this.getScissorTest = function() {
            return J
        }
        ,
        this.setScissorTest = function(I) {
            N.setScissorTest(J = I)
        }
        ,
        this.setOpaqueSort = function(I) {
            re = I
        }
        ,
        this.setTransparentSort = function(I) {
            ee = I
        }
        ,
        this.getClearColor = function(I) {
            return I.copy(Ee.getClearColor())
        }
        ,
        this.setClearColor = function() {
            Ee.setClearColor.apply(Ee, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Ee.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Ee.setClearAlpha.apply(Ee, arguments)
        }
        ,
        this.clear = function(I=!0, K=!0, te=!0) {
            let q = 0;
            if (I) {
                let ne = !1;
                if (C !== null) {
                    const Ce = C.texture.format;
                    ne = Ce === Fm || Ce === Nm || Ce === Um
                }
                if (ne) {
                    const Ce = C.texture.type
                      , De = Ce === vi || Ce === di || Ce === mu || Ce === Hi || Ce === Dm || Ce === Im
                      , ze = Ee.getClearColor()
                      , Be = Ee.getClearAlpha()
                      , Ke = ze.r
                      , Oe = ze.g
                      , Ve = ze.b;
                    De ? (p[0] = Ke,
                    p[1] = Oe,
                    p[2] = Ve,
                    p[3] = Be,
                    y.clearBufferuiv(y.COLOR, 0, p)) : (g[0] = Ke,
                    g[1] = Oe,
                    g[2] = Ve,
                    g[3] = Be,
                    y.clearBufferiv(y.COLOR, 0, g))
                } else
                    q |= y.COLOR_BUFFER_BIT
            }
            K && (q |= y.DEPTH_BUFFER_BIT),
            te && (q |= y.STENCIL_BUFFER_BIT),
            y.clear(q)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", ye, !1),
            t.removeEventListener("webglcontextrestored", ve, !1),
            t.removeEventListener("webglcontextcreationerror", Re, !1),
            ae.dispose(),
            ue.dispose(),
            Z.dispose(),
            oe.dispose(),
            Q.dispose(),
            E.dispose(),
            Le.dispose(),
            Fe.dispose(),
            z.dispose(),
            U.dispose(),
            U.removeEventListener("sessionstart", nt),
            U.removeEventListener("sessionend", Sn),
            Ae && (Ae.dispose(),
            Ae = null),
            Ut.stop()
        }
        ;
        function ye(I) {
            I.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            M = !0
        }
        function ve() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            M = !1;
            const I = j.autoReset
              , K = pe.enabled
              , te = pe.autoUpdate
              , q = pe.needsUpdate
              , ne = pe.type;
            Ue(),
            j.autoReset = I,
            pe.enabled = K,
            pe.autoUpdate = te,
            pe.needsUpdate = q,
            pe.type = ne
        }
        function Re(I) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", I.statusMessage)
        }
        function we(I) {
            const K = I.target;
            K.removeEventListener("dispose", we),
            de(K)
        }
        function de(I) {
            Pe(I),
            Z.remove(I)
        }
        function Pe(I) {
            const K = Z.get(I).programs;
            K !== void 0 && (K.forEach(function(te) {
                z.releaseProgram(te)
            }),
            I.isShaderMaterial && z.releaseShaderCache(I))
        }
        this.renderBufferDirect = function(I, K, te, q, ne, Ce) {
            K === null && (K = ge);
            const De = ne.isMesh && ne.matrixWorld.determinant() < 0
              , ze = _g(I, K, te, q, ne);
            N.setMaterial(q, De);
            let Be = te.index
              , Ke = 1;
            if (q.wireframe === !0) {
                if (Be = w.getWireframeAttribute(te),
                Be === void 0)
                    return;
                Ke = 2
            }
            const Oe = te.drawRange
              , Ve = te.attributes.position;
            let ct = Oe.start * Ke
              , ut = (Oe.start + Oe.count) * Ke;
            Ce !== null && (ct = Math.max(ct, Ce.start * Ke),
            ut = Math.min(ut, (Ce.start + Ce.count) * Ke)),
            Be !== null ? (ct = Math.max(ct, 0),
            ut = Math.min(ut, Be.count)) : Ve != null && (ct = Math.max(ct, 0),
            ut = Math.min(ut, Ve.count));
            const Qt = ut - ct;
            if (Qt < 0 || Qt === 1 / 0)
                return;
            Le.setup(ne, q, ze, te, Be);
            let In, dt = je;
            if (Be !== null && (In = be.get(Be),
            dt = me,
            dt.setIndex(In)),
            ne.isMesh)
                q.wireframe === !0 ? (N.setLineWidth(q.wireframeLinewidth * he()),
                dt.setMode(y.LINES)) : dt.setMode(y.TRIANGLES);
            else if (ne.isLine) {
                let qe = q.linewidth;
                qe === void 0 && (qe = 1),
                N.setLineWidth(qe * he()),
                ne.isLineSegments ? dt.setMode(y.LINES) : ne.isLineLoop ? dt.setMode(y.LINE_LOOP) : dt.setMode(y.LINE_STRIP)
            } else
                ne.isPoints ? dt.setMode(y.POINTS) : ne.isSprite && dt.setMode(y.TRIANGLES);
            if (ne.isInstancedMesh)
                dt.renderInstances(ct, Qt, ne.count);
            else if (te.isInstancedBufferGeometry) {
                const qe = te._maxInstanceCount !== void 0 ? te._maxInstanceCount : 1 / 0
                  , Ha = Math.min(te.instanceCount, qe);
                dt.renderInstances(ct, Qt, Ha)
            } else
                dt.render(ct, Qt)
        }
        ,
        this.compile = function(I, K) {
            function te(q, ne, Ce) {
                q.transparent === !0 && q.side === An && q.forceSinglePass === !1 ? (q.side = Wt,
                q.needsUpdate = !0,
                Qs(q, ne, Ce),
                q.side = Jn,
                q.needsUpdate = !0,
                Qs(q, ne, Ce),
                q.side = An) : Qs(q, ne, Ce)
            }
            m = ue.get(I),
            m.init(),
            v.push(m),
            I.traverseVisible(function(q) {
                q.isLight && q.layers.test(K.layers) && (m.pushLight(q),
                q.castShadow && m.pushShadow(q))
            }),
            m.setupLights(_._useLegacyLights),
            I.traverse(function(q) {
                const ne = q.material;
                if (ne)
                    if (Array.isArray(ne))
                        for (let Ce = 0; Ce < ne.length; Ce++) {
                            const De = ne[Ce];
                            te(De, I, q)
                        }
                    else
                        te(ne, I, q)
            }),
            v.pop(),
            m = null
        }
        ;
        let Ge = null;
        function It(I) {
            Ge && Ge(I)
        }
        function nt() {
            Ut.stop()
        }
        function Sn() {
            Ut.start()
        }
        const Ut = new qm;
        Ut.setAnimationLoop(It),
        typeof self < "u" && Ut.setContext(self),
        this.setAnimationLoop = function(I) {
            Ge = I,
            U.setAnimationLoop(I),
            I === null ? Ut.stop() : Ut.start()
        }
        ,
        U.addEventListener("sessionstart", nt),
        U.addEventListener("sessionend", Sn),
        this.render = function(I, K) {
            if (K !== void 0 && K.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (M === !0)
                return;
            I.matrixWorldAutoUpdate === !0 && I.updateMatrixWorld(),
            K.parent === null && K.matrixWorldAutoUpdate === !0 && K.updateMatrixWorld(),
            U.enabled === !0 && U.isPresenting === !0 && (U.cameraAutoUpdate === !0 && U.updateCamera(K),
            K = U.getCamera()),
            I.isScene === !0 && I.onBeforeRender(_, I, K, C),
            m = ue.get(I, v.length),
            m.init(),
            v.push(m),
            W.multiplyMatrices(K.projectionMatrix, K.matrixWorldInverse),
            fe.setFromProjectionMatrix(W),
            Te = this.localClippingEnabled,
            _e = Se.init(this.clippingPlanes, Te),
            x = ae.get(I, d.length),
            x.init(),
            d.push(x),
            Ru(I, K, 0, _.sortObjects),
            x.finish(),
            _.sortObjects === !0 && x.sort(re, ee),
            this.info.render.frame++,
            _e === !0 && Se.beginShadows();
            const te = m.state.shadowsArray;
            if (pe.render(te, I, K),
            _e === !0 && Se.endShadows(),
            this.info.autoReset === !0 && this.info.reset(),
            Ee.render(x, I),
            m.setupLights(_._useLegacyLights),
            K.isArrayCamera) {
                const q = K.cameras;
                for (let ne = 0, Ce = q.length; ne < Ce; ne++) {
                    const De = q[ne];
                    Cu(x, I, De, De.viewport)
                }
            } else
                Cu(x, I, K);
            C !== null && (Y.updateMultisampleRenderTarget(C),
            Y.updateRenderTargetMipmap(C)),
            I.isScene === !0 && I.onAfterRender(_, I, K),
            Le.resetDefaultState(),
            P = -1,
            S = null,
            v.pop(),
            v.length > 0 ? m = v[v.length - 1] : m = null,
            d.pop(),
            d.length > 0 ? x = d[d.length - 1] : x = null
        }
        ;
        function Ru(I, K, te, q) {
            if (I.visible === !1)
                return;
            if (I.layers.test(K.layers)) {
                if (I.isGroup)
                    te = I.renderOrder;
                else if (I.isLOD)
                    I.autoUpdate === !0 && I.update(K);
                else if (I.isLight)
                    m.pushLight(I),
                    I.castShadow && m.pushShadow(I);
                else if (I.isSprite) {
                    if (!I.frustumCulled || fe.intersectsSprite(I)) {
                        q && ce.setFromMatrixPosition(I.matrixWorld).applyMatrix4(W);
                        const De = E.update(I)
                          , ze = I.material;
                        ze.visible && x.push(I, De, ze, te, ce.z, null)
                    }
                } else if ((I.isMesh || I.isLine || I.isPoints) && (!I.frustumCulled || fe.intersectsObject(I))) {
                    const De = E.update(I)
                      , ze = I.material;
                    if (q && (I.boundingSphere !== void 0 ? (I.boundingSphere === null && I.computeBoundingSphere(),
                    ce.copy(I.boundingSphere.center)) : (De.boundingSphere === null && De.computeBoundingSphere(),
                    ce.copy(De.boundingSphere.center)),
                    ce.applyMatrix4(I.matrixWorld).applyMatrix4(W)),
                    Array.isArray(ze)) {
                        const Be = De.groups;
                        for (let Ke = 0, Oe = Be.length; Ke < Oe; Ke++) {
                            const Ve = Be[Ke]
                              , ct = ze[Ve.materialIndex];
                            ct && ct.visible && x.push(I, De, ct, te, ce.z, Ve)
                        }
                    } else
                        ze.visible && x.push(I, De, ze, te, ce.z, null)
                }
            }
            const Ce = I.children;
            for (let De = 0, ze = Ce.length; De < ze; De++)
                Ru(Ce[De], K, te, q)
        }
        function Cu(I, K, te, q) {
            const ne = I.opaque
              , Ce = I.transmissive
              , De = I.transparent;
            m.setupLightsView(te),
            _e === !0 && Se.setGlobalState(_.clippingPlanes, te),
            Ce.length > 0 && gg(ne, Ce, K, te),
            q && N.viewport(T.copy(q)),
            ne.length > 0 && Zs(ne, K, te),
            Ce.length > 0 && Zs(Ce, K, te),
            De.length > 0 && Zs(De, K, te),
            N.buffers.depth.setTest(!0),
            N.buffers.depth.setMask(!0),
            N.buffers.color.setMask(!0),
            N.setPolygonOffset(!1)
        }
        function gg(I, K, te, q) {
            const ne = O.isWebGL2;
            Ae === null && (Ae = new Wi(1,1,{
                generateMipmaps: !0,
                type: D.has("EXT_color_buffer_half_float") ? $n : vi,
                minFilter: Hr,
                samples: ne ? 4 : 0
            })),
            _.getDrawingBufferSize(se),
            ne ? Ae.setSize(se.x, se.y) : Ae.setSize(Tc(se.x), Tc(se.y));
            const Ce = _.getRenderTarget();
            _.setRenderTarget(Ae),
            _.getClearColor(X),
            L = _.getClearAlpha(),
            L < 1 && _.setClearColor(16777215, .5),
            _.clear();
            const De = _.toneMapping;
            _.toneMapping = _i,
            Zs(I, te, q),
            Y.updateMultisampleRenderTarget(Ae),
            Y.updateRenderTargetMipmap(Ae);
            let ze = !1;
            for (let Be = 0, Ke = K.length; Be < Ke; Be++) {
                const Oe = K[Be]
                  , Ve = Oe.object
                  , ct = Oe.geometry
                  , ut = Oe.material
                  , Qt = Oe.group;
                if (ut.side === An && Ve.layers.test(q.layers)) {
                    const In = ut.side;
                    ut.side = Wt,
                    ut.needsUpdate = !0,
                    Pu(Ve, te, q, ct, ut, Qt),
                    ut.side = In,
                    ut.needsUpdate = !0,
                    ze = !0
                }
            }
            ze === !0 && (Y.updateMultisampleRenderTarget(Ae),
            Y.updateRenderTargetMipmap(Ae)),
            _.setRenderTarget(Ce),
            _.setClearColor(X, L),
            _.toneMapping = De
        }
        function Zs(I, K, te) {
            const q = K.isScene === !0 ? K.overrideMaterial : null;
            for (let ne = 0, Ce = I.length; ne < Ce; ne++) {
                const De = I[ne]
                  , ze = De.object
                  , Be = De.geometry
                  , Ke = q === null ? De.material : q
                  , Oe = De.group;
                ze.layers.test(te.layers) && Pu(ze, K, te, Be, Ke, Oe)
            }
        }
        function Pu(I, K, te, q, ne, Ce) {
            I.onBeforeRender(_, K, te, q, ne, Ce),
            I.modelViewMatrix.multiplyMatrices(te.matrixWorldInverse, I.matrixWorld),
            I.normalMatrix.getNormalMatrix(I.modelViewMatrix),
            ne.onBeforeRender(_, K, te, q, I, Ce),
            ne.transparent === !0 && ne.side === An && ne.forceSinglePass === !1 ? (ne.side = Wt,
            ne.needsUpdate = !0,
            _.renderBufferDirect(te, K, q, ne, I, Ce),
            ne.side = Jn,
            ne.needsUpdate = !0,
            _.renderBufferDirect(te, K, q, ne, I, Ce),
            ne.side = An) : _.renderBufferDirect(te, K, q, ne, I, Ce),
            I.onAfterRender(_, K, te, q, ne, Ce)
        }
        function Qs(I, K, te) {
            K.isScene !== !0 && (K = ge);
            const q = Z.get(I)
              , ne = m.state.lights
              , Ce = m.state.shadowsArray
              , De = ne.state.version
              , ze = z.getParameters(I, ne.state, Ce, K, te)
              , Be = z.getProgramCacheKey(ze);
            let Ke = q.programs;
            q.environment = I.isMeshStandardMaterial ? K.environment : null,
            q.fog = K.fog,
            q.envMap = (I.isMeshStandardMaterial ? Q : oe).get(I.envMap || q.environment),
            Ke === void 0 && (I.addEventListener("dispose", we),
            Ke = new Map,
            q.programs = Ke);
            let Oe = Ke.get(Be);
            if (Oe !== void 0) {
                if (q.currentProgram === Oe && q.lightsStateVersion === De)
                    return Lu(I, ze),
                    Oe
            } else
                ze.uniforms = z.getUniforms(I),
                I.onBuild(te, ze, _),
                I.onBeforeCompile(ze, _),
                Oe = z.acquireProgram(ze, Be),
                Ke.set(Be, Oe),
                q.uniforms = ze.uniforms;
            const Ve = q.uniforms;
            (!I.isShaderMaterial && !I.isRawShaderMaterial || I.clipping === !0) && (Ve.clippingPlanes = Se.uniform),
            Lu(I, ze),
            q.needsLights = xg(I),
            q.lightsStateVersion = De,
            q.needsLights && (Ve.ambientLightColor.value = ne.state.ambient,
            Ve.lightProbe.value = ne.state.probe,
            Ve.directionalLights.value = ne.state.directional,
            Ve.directionalLightShadows.value = ne.state.directionalShadow,
            Ve.spotLights.value = ne.state.spot,
            Ve.spotLightShadows.value = ne.state.spotShadow,
            Ve.rectAreaLights.value = ne.state.rectArea,
            Ve.ltc_1.value = ne.state.rectAreaLTC1,
            Ve.ltc_2.value = ne.state.rectAreaLTC2,
            Ve.pointLights.value = ne.state.point,
            Ve.pointLightShadows.value = ne.state.pointShadow,
            Ve.hemisphereLights.value = ne.state.hemi,
            Ve.directionalShadowMap.value = ne.state.directionalShadowMap,
            Ve.directionalShadowMatrix.value = ne.state.directionalShadowMatrix,
            Ve.spotShadowMap.value = ne.state.spotShadowMap,
            Ve.spotLightMatrix.value = ne.state.spotLightMatrix,
            Ve.spotLightMap.value = ne.state.spotLightMap,
            Ve.pointShadowMap.value = ne.state.pointShadowMap,
            Ve.pointShadowMatrix.value = ne.state.pointShadowMatrix);
            const ct = Oe.getUniforms()
              , ut = Go.seqWithValue(ct.seq, Ve);
            return q.currentProgram = Oe,
            q.uniformsList = ut,
            Oe
        }
        function Lu(I, K) {
            const te = Z.get(I);
            te.outputColorSpace = K.outputColorSpace,
            te.instancing = K.instancing,
            te.instancingColor = K.instancingColor,
            te.skinning = K.skinning,
            te.morphTargets = K.morphTargets,
            te.morphNormals = K.morphNormals,
            te.morphColors = K.morphColors,
            te.morphTargetsCount = K.morphTargetsCount,
            te.numClippingPlanes = K.numClippingPlanes,
            te.numIntersection = K.numClipIntersection,
            te.vertexAlphas = K.vertexAlphas,
            te.vertexTangents = K.vertexTangents,
            te.toneMapping = K.toneMapping
        }
        function _g(I, K, te, q, ne) {
            K.isScene !== !0 && (K = ge),
            Y.resetTextureUnits();
            const Ce = K.fog
              , De = q.isMeshStandardMaterial ? K.environment : null
              , ze = C === null ? _.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : Ln
              , Be = (q.isMeshStandardMaterial ? Q : oe).get(q.envMap || De)
              , Ke = q.vertexColors === !0 && !!te.attributes.color && te.attributes.color.itemSize === 4
              , Oe = !!te.attributes.tangent && (!!q.normalMap || q.anisotropy > 0)
              , Ve = !!te.morphAttributes.position
              , ct = !!te.morphAttributes.normal
              , ut = !!te.morphAttributes.color;
            let Qt = _i;
            q.toneMapped && (C === null || C.isXRRenderTarget === !0) && (Qt = _.toneMapping);
            const In = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color
              , dt = In !== void 0 ? In.length : 0
              , qe = Z.get(q)
              , Ha = m.state.lights;
            if (_e === !0 && (Te === !0 || I !== S)) {
                const $t = I === S && q.id === P;
                Se.setState(q, I, $t)
            }
            let pt = !1;
            q.version === qe.__version ? (qe.needsLights && qe.lightsStateVersion !== Ha.state.version || qe.outputColorSpace !== ze || ne.isInstancedMesh && qe.instancing === !1 || !ne.isInstancedMesh && qe.instancing === !0 || ne.isSkinnedMesh && qe.skinning === !1 || !ne.isSkinnedMesh && qe.skinning === !0 || ne.isInstancedMesh && qe.instancingColor === !0 && ne.instanceColor === null || ne.isInstancedMesh && qe.instancingColor === !1 && ne.instanceColor !== null || qe.envMap !== Be || q.fog === !0 && qe.fog !== Ce || qe.numClippingPlanes !== void 0 && (qe.numClippingPlanes !== Se.numPlanes || qe.numIntersection !== Se.numIntersection) || qe.vertexAlphas !== Ke || qe.vertexTangents !== Oe || qe.morphTargets !== Ve || qe.morphNormals !== ct || qe.morphColors !== ut || qe.toneMapping !== Qt || O.isWebGL2 === !0 && qe.morphTargetsCount !== dt) && (pt = !0) : (pt = !0,
            qe.__version = q.version);
            let Si = qe.currentProgram;
            pt === !0 && (Si = Qs(q, K, ne));
            let Du = !1
              , Qr = !1
              , ka = !1;
            const Nt = Si.getUniforms()
              , Ei = qe.uniforms;
            if (N.useProgram(Si.program) && (Du = !0,
            Qr = !0,
            ka = !0),
            q.id !== P && (P = q.id,
            Qr = !0),
            Du || S !== I) {
                Nt.setValue(y, "projectionMatrix", I.projectionMatrix),
                Nt.setValue(y, "viewMatrix", I.matrixWorldInverse);
                const $t = Nt.map.cameraPosition;
                $t !== void 0 && $t.setValue(y, ce.setFromMatrixPosition(I.matrixWorld)),
                O.logarithmicDepthBuffer && Nt.setValue(y, "logDepthBufFC", 2 / (Math.log(I.far + 1) / Math.LN2)),
                (q.isMeshPhongMaterial || q.isMeshToonMaterial || q.isMeshLambertMaterial || q.isMeshBasicMaterial || q.isMeshStandardMaterial || q.isShaderMaterial) && Nt.setValue(y, "isOrthographic", I.isOrthographicCamera === !0),
                S !== I && (S = I,
                Qr = !0,
                ka = !0)
            }
            if (ne.isSkinnedMesh) {
                Nt.setOptional(y, ne, "bindMatrix"),
                Nt.setOptional(y, ne, "bindMatrixInverse");
                const $t = ne.skeleton;
                $t && (O.floatVertexTextures ? ($t.boneTexture === null && $t.computeBoneTexture(),
                Nt.setValue(y, "boneTexture", $t.boneTexture, Y),
                Nt.setValue(y, "boneTextureSize", $t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            const Ga = te.morphAttributes;
            if ((Ga.position !== void 0 || Ga.normal !== void 0 || Ga.color !== void 0 && O.isWebGL2 === !0) && Ne.update(ne, te, Si),
            (Qr || qe.receiveShadow !== ne.receiveShadow) && (qe.receiveShadow = ne.receiveShadow,
            Nt.setValue(y, "receiveShadow", ne.receiveShadow)),
            q.isMeshGouraudMaterial && q.envMap !== null && (Ei.envMap.value = Be,
            Ei.flipEnvMap.value = Be.isCubeTexture && Be.isRenderTargetTexture === !1 ? -1 : 1),
            Qr && (Nt.setValue(y, "toneMappingExposure", _.toneMappingExposure),
            qe.needsLights && vg(Ei, ka),
            Ce && q.fog === !0 && ie.refreshFogUniforms(Ei, Ce),
            ie.refreshMaterialUniforms(Ei, q, $, V, Ae),
            Go.upload(y, qe.uniformsList, Ei, Y)),
            q.isShaderMaterial && q.uniformsNeedUpdate === !0 && (Go.upload(y, qe.uniformsList, Ei, Y),
            q.uniformsNeedUpdate = !1),
            q.isSpriteMaterial && Nt.setValue(y, "center", ne.center),
            Nt.setValue(y, "modelViewMatrix", ne.modelViewMatrix),
            Nt.setValue(y, "normalMatrix", ne.normalMatrix),
            Nt.setValue(y, "modelMatrix", ne.matrixWorld),
            q.isShaderMaterial || q.isRawShaderMaterial) {
                const $t = q.uniformsGroups;
                for (let Va = 0, yg = $t.length; Va < yg; Va++)
                    if (O.isWebGL2) {
                        const Iu = $t[Va];
                        Fe.update(Iu, Si),
                        Fe.bind(Iu, Si)
                    } else
                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return Si
        }
        function vg(I, K) {
            I.ambientLightColor.needsUpdate = K,
            I.lightProbe.needsUpdate = K,
            I.directionalLights.needsUpdate = K,
            I.directionalLightShadows.needsUpdate = K,
            I.pointLights.needsUpdate = K,
            I.pointLightShadows.needsUpdate = K,
            I.spotLights.needsUpdate = K,
            I.spotLightShadows.needsUpdate = K,
            I.rectAreaLights.needsUpdate = K,
            I.hemisphereLights.needsUpdate = K
        }
        function xg(I) {
            return I.isMeshLambertMaterial || I.isMeshToonMaterial || I.isMeshPhongMaterial || I.isMeshStandardMaterial || I.isShadowMaterial || I.isShaderMaterial && I.lights === !0
        }
        this.getActiveCubeFace = function() {
            return b
        }
        ,
        this.getActiveMipmapLevel = function() {
            return A
        }
        ,
        this.getRenderTarget = function() {
            return C
        }
        ,
        this.setRenderTargetTextures = function(I, K, te) {
            Z.get(I.texture).__webglTexture = K,
            Z.get(I.depthTexture).__webglTexture = te;
            const q = Z.get(I);
            q.__hasExternalTextures = !0,
            q.__hasExternalTextures && (q.__autoAllocateDepthBuffer = te === void 0,
            q.__autoAllocateDepthBuffer || D.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            q.__useRenderToTexture = !1))
        }
        ,
        this.setRenderTargetFramebuffer = function(I, K) {
            const te = Z.get(I);
            te.__webglFramebuffer = K,
            te.__useDefaultFramebuffer = K === void 0
        }
        ,
        this.setRenderTarget = function(I, K=0, te=0) {
            C = I,
            b = K,
            A = te;
            let q = !0
              , ne = null
              , Ce = !1
              , De = !1;
            if (I) {
                const Be = Z.get(I);
                Be.__useDefaultFramebuffer !== void 0 ? (N.bindFramebuffer(y.FRAMEBUFFER, null),
                q = !1) : Be.__webglFramebuffer === void 0 ? Y.setupRenderTarget(I) : Be.__hasExternalTextures && Y.rebindTextures(I, Z.get(I.texture).__webglTexture, Z.get(I.depthTexture).__webglTexture);
                const Ke = I.texture;
                (Ke.isData3DTexture || Ke.isDataArrayTexture || Ke.isCompressedArrayTexture) && (De = !0);
                const Oe = Z.get(I).__webglFramebuffer;
                I.isWebGLCubeRenderTarget ? (Array.isArray(Oe[K]) ? ne = Oe[K][te] : ne = Oe[K],
                Ce = !0) : O.isWebGL2 && I.samples > 0 && Y.useMultisampledRTT(I) === !1 ? ne = Z.get(I).__webglMultisampledFramebuffer : Array.isArray(Oe) ? ne = Oe[te] : ne = Oe,
                T.copy(I.viewport),
                F.copy(I.scissor),
                k = I.scissorTest
            } else
                T.copy(le).multiplyScalar($).floor(),
                F.copy(B).multiplyScalar($).floor(),
                k = J;
            if (N.bindFramebuffer(y.FRAMEBUFFER, ne) && O.drawBuffers && q && N.drawBuffers(I, ne),
            N.viewport(T),
            N.scissor(F),
            N.setScissorTest(k),
            Ce) {
                const Be = Z.get(I.texture);
                y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, y.TEXTURE_CUBE_MAP_POSITIVE_X + K, Be.__webglTexture, te)
            } else if (De) {
                const Be = Z.get(I.texture)
                  , Ke = K || 0;
                y.framebufferTextureLayer(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, Be.__webglTexture, te || 0, Ke)
            }
            P = -1
        }
        ,
        this.readRenderTargetPixels = function(I, K, te, q, ne, Ce, De) {
            if (!(I && I.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let ze = Z.get(I).__webglFramebuffer;
            if (I.isWebGLCubeRenderTarget && De !== void 0 && (ze = ze[De]),
            ze) {
                N.bindFramebuffer(y.FRAMEBUFFER, ze);
                try {
                    const Be = I.texture
                      , Ke = Be.format
                      , Oe = Be.type;
                    if (Ke !== vn && ke.convert(Ke) !== y.getParameter(y.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const Ve = Oe === $n && (D.has("EXT_color_buffer_half_float") || O.isWebGL2 && D.has("EXT_color_buffer_float"));
                    if (Oe !== vi && ke.convert(Oe) !== y.getParameter(y.IMPLEMENTATION_COLOR_READ_TYPE) && !(Oe === xn && (O.isWebGL2 || D.has("OES_texture_float") || D.has("WEBGL_color_buffer_float"))) && !Ve) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    K >= 0 && K <= I.width - q && te >= 0 && te <= I.height - ne && y.readPixels(K, te, q, ne, ke.convert(Ke), ke.convert(Oe), Ce)
                } finally {
                    const Be = C !== null ? Z.get(C).__webglFramebuffer : null;
                    N.bindFramebuffer(y.FRAMEBUFFER, Be)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(I, K, te=0) {
            const q = Math.pow(2, -te)
              , ne = Math.floor(K.image.width * q)
              , Ce = Math.floor(K.image.height * q);
            Y.setTexture2D(K, 0),
            y.copyTexSubImage2D(y.TEXTURE_2D, te, 0, 0, I.x, I.y, ne, Ce),
            N.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(I, K, te, q=0) {
            const ne = K.image.width
              , Ce = K.image.height
              , De = ke.convert(te.format)
              , ze = ke.convert(te.type);
            Y.setTexture2D(te, 0),
            y.pixelStorei(y.UNPACK_FLIP_Y_WEBGL, te.flipY),
            y.pixelStorei(y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, te.premultiplyAlpha),
            y.pixelStorei(y.UNPACK_ALIGNMENT, te.unpackAlignment),
            K.isDataTexture ? y.texSubImage2D(y.TEXTURE_2D, q, I.x, I.y, ne, Ce, De, ze, K.image.data) : K.isCompressedTexture ? y.compressedTexSubImage2D(y.TEXTURE_2D, q, I.x, I.y, K.mipmaps[0].width, K.mipmaps[0].height, De, K.mipmaps[0].data) : y.texSubImage2D(y.TEXTURE_2D, q, I.x, I.y, De, ze, K.image),
            q === 0 && te.generateMipmaps && y.generateMipmap(y.TEXTURE_2D),
            N.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(I, K, te, q, ne=0) {
            if (_.isWebGL1Renderer) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                return
            }
            const Ce = I.max.x - I.min.x + 1
              , De = I.max.y - I.min.y + 1
              , ze = I.max.z - I.min.z + 1
              , Be = ke.convert(q.format)
              , Ke = ke.convert(q.type);
            let Oe;
            if (q.isData3DTexture)
                Y.setTexture3D(q, 0),
                Oe = y.TEXTURE_3D;
            else if (q.isDataArrayTexture)
                Y.setTexture2DArray(q, 0),
                Oe = y.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            y.pixelStorei(y.UNPACK_FLIP_Y_WEBGL, q.flipY),
            y.pixelStorei(y.UNPACK_PREMULTIPLY_ALPHA_WEBGL, q.premultiplyAlpha),
            y.pixelStorei(y.UNPACK_ALIGNMENT, q.unpackAlignment);
            const Ve = y.getParameter(y.UNPACK_ROW_LENGTH)
              , ct = y.getParameter(y.UNPACK_IMAGE_HEIGHT)
              , ut = y.getParameter(y.UNPACK_SKIP_PIXELS)
              , Qt = y.getParameter(y.UNPACK_SKIP_ROWS)
              , In = y.getParameter(y.UNPACK_SKIP_IMAGES)
              , dt = te.isCompressedTexture ? te.mipmaps[0] : te.image;
            y.pixelStorei(y.UNPACK_ROW_LENGTH, dt.width),
            y.pixelStorei(y.UNPACK_IMAGE_HEIGHT, dt.height),
            y.pixelStorei(y.UNPACK_SKIP_PIXELS, I.min.x),
            y.pixelStorei(y.UNPACK_SKIP_ROWS, I.min.y),
            y.pixelStorei(y.UNPACK_SKIP_IMAGES, I.min.z),
            te.isDataTexture || te.isData3DTexture ? y.texSubImage3D(Oe, ne, K.x, K.y, K.z, Ce, De, ze, Be, Ke, dt.data) : te.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            y.compressedTexSubImage3D(Oe, ne, K.x, K.y, K.z, Ce, De, ze, Be, dt.data)) : y.texSubImage3D(Oe, ne, K.x, K.y, K.z, Ce, De, ze, Be, Ke, dt),
            y.pixelStorei(y.UNPACK_ROW_LENGTH, Ve),
            y.pixelStorei(y.UNPACK_IMAGE_HEIGHT, ct),
            y.pixelStorei(y.UNPACK_SKIP_PIXELS, ut),
            y.pixelStorei(y.UNPACK_SKIP_ROWS, Qt),
            y.pixelStorei(y.UNPACK_SKIP_IMAGES, In),
            ne === 0 && q.generateMipmaps && y.generateMipmap(Oe),
            N.unbindTexture()
        }
        ,
        this.initTexture = function(I) {
            I.isCubeTexture ? Y.setTextureCube(I, 0) : I.isData3DTexture ? Y.setTexture3D(I, 0) : I.isDataArrayTexture || I.isCompressedArrayTexture ? Y.setTexture2DArray(I, 0) : Y.setTexture2D(I, 0),
            N.unbindTexture()
        }
        ,
        this.resetState = function() {
            b = 0,
            A = 0,
            C = null,
            N.reset(),
            Le.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return jn
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === gu ? "display-p3" : "srgb",
        t.unpackColorSpace = et.workingColorSpace === Ia ? "display-p3" : "srgb"
    }
    get physicallyCorrectLights() {
        return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        !this.useLegacyLights
    }
    set physicallyCorrectLights(e) {
        console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
        this.useLegacyLights = !e
    }
    get outputEncoding() {
        return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace === At ? Gi : Om
    }
    set outputEncoding(e) {
        console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace = e === Gi ? At : Ln
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights
    }
    set useLegacyLights(e) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights = e
    }
}
class F1 extends tg {
}
F1.prototype.isWebGL1Renderer = !0;
class Mu {
    constructor(e, t=1, i=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Xe(e),
        this.near = t,
        this.far = i
    }
    clone() {
        return new Mu(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class O1 extends Ct {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
}
class z1 extends zt {
    constructor(e=null, t=1, i=1, r, s, o, a, l, c=St, u=St, h, f) {
        super(null, o, a, l, c, u, r, s, h, f),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class B1 extends Mi {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Xe(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const xd = new ht
  , Rc = new _u
  , Uo = new Ua
  , No = new H;
class H1 extends Ct {
    constructor(e=new Zt, t=new B1) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        Uo.copy(i.boundingSphere),
        Uo.applyMatrix4(r),
        Uo.radius += s,
        e.ray.intersectsSphere(Uo) === !1)
            return;
        xd.copy(r).invert(),
        Rc.copy(e.ray).applyMatrix4(xd);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = i.index
          , h = i.attributes.position;
        if (c !== null) {
            const f = Math.max(0, o.start)
              , p = Math.min(c.count, o.start + o.count);
            for (let g = f, x = p; g < x; g++) {
                const m = c.getX(g);
                No.fromBufferAttribute(h, m),
                yd(No, m, l, r, e, t, this)
            }
        } else {
            const f = Math.max(0, o.start)
              , p = Math.min(h.count, o.start + o.count);
            for (let g = f, x = p; g < x; g++)
                No.fromBufferAttribute(h, g),
                yd(No, g, l, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function yd(n, e, t, i, r, s, o) {
    const a = Rc.distanceSqToPoint(n);
    if (a < t) {
        const l = new H;
        Rc.closestPointToPoint(n, l),
        l.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(l);
        if (c < r.near || c > r.far)
            return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class Dn {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            i = this.getPoint(o / e),
            s += i.distanceTo(r),
            t.push(s),
            r = i;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0, l = s - 1, c;
        for (; a <= l; )
            if (r = Math.floor(a + (l - a) / 2),
            c = i[r] - o,
            c < 0)
                a = r + 1;
            else if (c > 0)
                l = r - 1;
            else {
                l = r;
                break
            }
        if (r = l,
        i[r] === o)
            return r / (s - 1);
        const u = i[r]
          , f = i[r + 1] - u
          , p = (o - u) / f;
        return (r + p) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4
          , s = e + 1e-4;
        r < 0 && (r = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(r)
          , a = this.getPoint(s)
          , l = t || (o.isVector2 ? new xe : new H);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new H
          , r = []
          , s = []
          , o = []
          , a = new H
          , l = new ht;
        for (let p = 0; p <= e; p++) {
            const g = p / e;
            r[p] = this.getTangentAt(g, new H)
        }
        s[0] = new H,
        o[0] = new H;
        let c = Number.MAX_VALUE;
        const u = Math.abs(r[0].x)
          , h = Math.abs(r[0].y)
          , f = Math.abs(r[0].z);
        u <= c && (c = u,
        i.set(1, 0, 0)),
        h <= c && (c = h,
        i.set(0, 1, 0)),
        f <= c && i.set(0, 0, 1),
        a.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], a),
        o[0].crossVectors(r[0], s[0]);
        for (let p = 1; p <= e; p++) {
            if (s[p] = s[p - 1].clone(),
            o[p] = o[p - 1].clone(),
            a.crossVectors(r[p - 1], r[p]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const g = Math.acos(vt(r[p - 1].dot(r[p]), -1, 1));
                s[p].applyMatrix4(l.makeRotationAxis(a, g))
            }
            o[p].crossVectors(r[p], s[p])
        }
        if (t === !0) {
            let p = Math.acos(vt(s[0].dot(s[e]), -1, 1));
            p /= e,
            r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (p = -p);
            for (let g = 1; g <= e; g++)
                s[g].applyMatrix4(l.makeRotationAxis(r[g], p * g)),
                o[g].crossVectors(r[g], s[g])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class Su extends Dn {
    constructor(e=0, t=0, i=1, r=1, s=0, o=Math.PI * 2, a=!1, l=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = i,
        this.yRadius = r,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = l
    }
    getPoint(e, t) {
        const i = t || new xe
          , r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += r;
        for (; s > r; )
            s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r),
        this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , f = l - this.aX
              , p = c - this.aY;
            l = f * u - p * h + this.aX,
            c = f * h + p * u + this.aY
        }
        return i.set(l, c)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class k1 extends Su {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function Eu() {
    let n = 0
      , e = 0
      , t = 0
      , i = 0;
    function r(s, o, a, l) {
        n = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - l,
        i = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, c) {
            r(o, a, c * (a - s), c * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, c, u, h) {
            let f = (o - s) / c - (a - s) / (c + u) + (a - o) / u
              , p = (a - o) / u - (l - o) / (u + h) + (l - a) / h;
            f *= u,
            p *= u,
            r(o, a, f, p)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const Fo = new H
  , Fl = new Eu
  , Ol = new Eu
  , zl = new Eu;
class G1 extends Dn {
    constructor(e=[], t=!1, i="centripetal", r=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = i,
        this.tension = r
    }
    getPoint(e, t=new H) {
        const i = t
          , r = this.points
          , s = r.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2,
        l = 1);
        let c, u;
        this.closed || a > 0 ? c = r[(a - 1) % s] : (Fo.subVectors(r[0], r[1]).add(r[0]),
        c = Fo);
        const h = r[a % s]
          , f = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? u = r[(a + 2) % s] : (Fo.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]),
        u = Fo),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const p = this.curveType === "chordal" ? .5 : .25;
            let g = Math.pow(c.distanceToSquared(h), p)
              , x = Math.pow(h.distanceToSquared(f), p)
              , m = Math.pow(f.distanceToSquared(u), p);
            x < 1e-4 && (x = 1),
            g < 1e-4 && (g = x),
            m < 1e-4 && (m = x),
            Fl.initNonuniformCatmullRom(c.x, h.x, f.x, u.x, g, x, m),
            Ol.initNonuniformCatmullRom(c.y, h.y, f.y, u.y, g, x, m),
            zl.initNonuniformCatmullRom(c.z, h.z, f.z, u.z, g, x, m)
        } else
            this.curveType === "catmullrom" && (Fl.initCatmullRom(c.x, h.x, f.x, u.x, this.tension),
            Ol.initCatmullRom(c.y, h.y, f.y, u.y, this.tension),
            zl.initCatmullRom(c.z, h.z, f.z, u.z, this.tension));
        return i.set(Fl.calc(l), Ol.calc(l), zl.calc(l)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new H().fromArray(r))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function Md(n, e, t, i, r) {
    const s = (i - e) * .5
      , o = (r - t) * .5
      , a = n * n
      , l = n * a;
    return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}
function V1(n, e) {
    const t = 1 - n;
    return t * t * e
}
function W1(n, e) {
    return 2 * (1 - n) * n * e
}
function X1(n, e) {
    return n * n * e
}
function bs(n, e, t, i) {
    return V1(n, e) + W1(n, t) + X1(n, i)
}
function $1(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function j1(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function K1(n, e) {
    return 3 * (1 - n) * n * n * e
}
function q1(n, e) {
    return n * n * n * e
}
function Ts(n, e, t, i, r) {
    return $1(n, e) + j1(n, t) + K1(n, i) + q1(n, r)
}
class ng extends Dn {
    constructor(e=new xe, t=new xe, i=new xe, r=new xe) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new xe) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Ts(e, r.x, s.x, o.x, a.x), Ts(e, r.y, s.y, o.y, a.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class Y1 extends Dn {
    constructor(e=new H, t=new H, i=new H, r=new H) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new H) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Ts(e, r.x, s.x, o.x, a.x), Ts(e, r.y, s.y, o.y, a.y), Ts(e, r.z, s.z, o.z, a.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class ig extends Dn {
    constructor(e=new xe, t=new xe) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new xe) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new xe) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class rg extends Dn {
    constructor(e=new H, t=new H) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new H) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new H) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class sg extends Dn {
    constructor(e=new xe, t=new xe, i=new xe) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new xe) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(bs(e, r.x, s.x, o.x), bs(e, r.y, s.y, o.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class og extends Dn {
    constructor(e=new H, t=new H, i=new H) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new H) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(bs(e, r.x, s.x, o.x), bs(e, r.y, s.y, o.y), bs(e, r.z, s.z, o.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class ag extends Dn {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new xe) {
        const i = t
          , r = this.points
          , s = (r.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , l = r[o === 0 ? o : o - 1]
          , c = r[o]
          , u = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(Md(a, l.x, c.x, u.x, h.x), Md(a, l.y, c.y, u.y, h.y)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new xe().fromArray(r))
        }
        return this
    }
}
var ha = Object.freeze({
    __proto__: null,
    ArcCurve: k1,
    CatmullRomCurve3: G1,
    CubicBezierCurve: ng,
    CubicBezierCurve3: Y1,
    EllipseCurve: Su,
    LineCurve: ig,
    LineCurve3: rg,
    QuadraticBezierCurve: sg,
    QuadraticBezierCurve3: og,
    SplineCurve: ag
});
class J1 extends Dn {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new ha[i](t,e))
        }
        return this
    }
    getPoint(e, t) {
        const i = e * this.getLength()
          , r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i
                  , a = this.curves[s]
                  , l = a.getLength()
                  , c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            t += this.curves[i].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const u = l[c];
                i && i.equals(u) || (t.push(u),
                i = u)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new ha[r.type]().fromJSON(r))
        }
        return this
    }
}
class Cc extends J1 {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new xe,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const i = new ig(this.currentPoint.clone(),new xe(e,t));
        return this.curves.push(i),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new sg(this.currentPoint.clone(),new xe(e,t),new xe(i,r));
        return this.curves.push(s),
        this.currentPoint.set(i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new ng(this.currentPoint.clone(),new xe(e,t),new xe(i,r),new xe(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , i = new ag(t);
        return this.curves.push(i),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x
          , l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, r, s, o),
        this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o),
        this
    }
    ellipse(e, t, i, r, s, o, a, l) {
        const c = this.currentPoint.x
          , u = this.currentPoint.y;
        return this.absellipse(e + c, t + u, i, r, s, o, a, l),
        this
    }
    absellipse(e, t, i, r, s, o, a, l) {
        const c = new Su(e,t,i,r,s,o,a,l);
        if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(c);
        const u = c.getPoint(1);
        return this.currentPoint.copy(u),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class bu extends Zt {
    constructor(e=[new xe(0,-.5), new xe(.5,0), new xe(0,.5)], t=12, i=0, r=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        },
        t = Math.floor(t),
        r = vt(r, 0, Math.PI * 2);
        const s = []
          , o = []
          , a = []
          , l = []
          , c = []
          , u = 1 / t
          , h = new H
          , f = new xe
          , p = new H
          , g = new H
          , x = new H;
        let m = 0
          , d = 0;
        for (let v = 0; v <= e.length - 1; v++)
            switch (v) {
            case 0:
                m = e[v + 1].x - e[v].x,
                d = e[v + 1].y - e[v].y,
                p.x = d * 1,
                p.y = -m,
                p.z = d * 0,
                x.copy(p),
                p.normalize(),
                l.push(p.x, p.y, p.z);
                break;
            case e.length - 1:
                l.push(x.x, x.y, x.z);
                break;
            default:
                m = e[v + 1].x - e[v].x,
                d = e[v + 1].y - e[v].y,
                p.x = d * 1,
                p.y = -m,
                p.z = d * 0,
                g.copy(p),
                p.x += x.x,
                p.y += x.y,
                p.z += x.z,
                p.normalize(),
                l.push(p.x, p.y, p.z),
                x.copy(g)
            }
        for (let v = 0; v <= t; v++) {
            const _ = i + v * u * r
              , M = Math.sin(_)
              , b = Math.cos(_);
            for (let A = 0; A <= e.length - 1; A++) {
                h.x = e[A].x * M,
                h.y = e[A].y,
                h.z = e[A].x * b,
                o.push(h.x, h.y, h.z),
                f.x = v / t,
                f.y = A / (e.length - 1),
                a.push(f.x, f.y);
                const C = l[3 * A + 0] * M
                  , P = l[3 * A + 1]
                  , S = l[3 * A + 0] * b;
                c.push(C, P, S)
            }
        }
        for (let v = 0; v < t; v++)
            for (let _ = 0; _ < e.length - 1; _++) {
                const M = _ + v * e.length
                  , b = M
                  , A = M + e.length
                  , C = M + e.length + 1
                  , P = M + 1;
                s.push(b, A, P),
                s.push(C, P, A)
            }
        this.setIndex(s),
        this.setAttribute("position", new Tt(o,3)),
        this.setAttribute("uv", new Tt(a,2)),
        this.setAttribute("normal", new Tt(c,3))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new bu(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class ws extends Cc {
    constructor(e) {
        super(e),
        this.uuid = qr(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++)
            t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new Cc().fromJSON(r))
        }
        return this
    }
}
const Z1 = {
    triangulate: function(n, e, t=2) {
        const i = e && e.length
          , r = i ? e[0] * t : n.length;
        let s = lg(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, l, c, u, h, f, p;
        if (i && (s = iA(n, e, s, t)),
        n.length > 80 * t) {
            a = c = n[0],
            l = u = n[1];
            for (let g = t; g < r; g += t)
                h = n[g],
                f = n[g + 1],
                h < a && (a = h),
                f < l && (l = f),
                h > c && (c = h),
                f > u && (u = f);
            p = Math.max(c - a, u - l),
            p = p !== 0 ? 32767 / p : 0
        }
        return Bs(s, o, t, a, l, p, 0),
        o
    }
};
function lg(n, e, t, i, r) {
    let s, o;
    if (r === pA(n, e, t, i) > 0)
        for (s = e; s < t; s += i)
            o = Sd(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i)
            o = Sd(s, n[s], n[s + 1], o);
    return o && za(o, o.next) && (ks(o),
    o = o.next),
    o
}
function Xi(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, i;
    do
        if (i = !1,
        !t.steiner && (za(t, t.next) || ot(t.prev, t, t.next) === 0)) {
            if (ks(t),
            t = e = t.prev,
            t === t.next)
                break;
            i = !0
        } else
            t = t.next;
    while (i || t !== e);
    return e
}
function Bs(n, e, t, i, r, s, o) {
    if (!n)
        return;
    !o && s && lA(n, i, r, s);
    let a = n, l, c;
    for (; n.prev !== n.next; ) {
        if (l = n.prev,
        c = n.next,
        s ? eA(n, i, r, s) : Q1(n)) {
            e.push(l.i / t | 0),
            e.push(n.i / t | 0),
            e.push(c.i / t | 0),
            ks(n),
            n = c.next,
            a = c.next;
            continue
        }
        if (n = c,
        n === a) {
            o ? o === 1 ? (n = tA(Xi(n), e, t),
            Bs(n, e, t, i, r, s, 2)) : o === 2 && nA(n, e, t, i, r, s) : Bs(Xi(n), e, t, i, r, s, 1);
            break
        }
    }
}
function Q1(n) {
    const e = n.prev
      , t = n
      , i = n.next;
    if (ot(e, t, i) >= 0)
        return !1;
    const r = e.x
      , s = t.x
      , o = i.x
      , a = e.y
      , l = t.y
      , c = i.y
      , u = r < s ? r < o ? r : o : s < o ? s : o
      , h = a < l ? a < c ? a : c : l < c ? l : c
      , f = r > s ? r > o ? r : o : s > o ? s : o
      , p = a > l ? a > c ? a : c : l > c ? l : c;
    let g = i.next;
    for (; g !== e; ) {
        if (g.x >= u && g.x <= f && g.y >= h && g.y <= p && Mr(r, a, s, l, o, c, g.x, g.y) && ot(g.prev, g, g.next) >= 0)
            return !1;
        g = g.next
    }
    return !0
}
function eA(n, e, t, i) {
    const r = n.prev
      , s = n
      , o = n.next;
    if (ot(r, s, o) >= 0)
        return !1;
    const a = r.x
      , l = s.x
      , c = o.x
      , u = r.y
      , h = s.y
      , f = o.y
      , p = a < l ? a < c ? a : c : l < c ? l : c
      , g = u < h ? u < f ? u : f : h < f ? h : f
      , x = a > l ? a > c ? a : c : l > c ? l : c
      , m = u > h ? u > f ? u : f : h > f ? h : f
      , d = Pc(p, g, e, t, i)
      , v = Pc(x, m, e, t, i);
    let _ = n.prevZ
      , M = n.nextZ;
    for (; _ && _.z >= d && M && M.z <= v; ) {
        if (_.x >= p && _.x <= x && _.y >= g && _.y <= m && _ !== r && _ !== o && Mr(a, u, l, h, c, f, _.x, _.y) && ot(_.prev, _, _.next) >= 0 || (_ = _.prevZ,
        M.x >= p && M.x <= x && M.y >= g && M.y <= m && M !== r && M !== o && Mr(a, u, l, h, c, f, M.x, M.y) && ot(M.prev, M, M.next) >= 0))
            return !1;
        M = M.nextZ
    }
    for (; _ && _.z >= d; ) {
        if (_.x >= p && _.x <= x && _.y >= g && _.y <= m && _ !== r && _ !== o && Mr(a, u, l, h, c, f, _.x, _.y) && ot(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.prevZ
    }
    for (; M && M.z <= v; ) {
        if (M.x >= p && M.x <= x && M.y >= g && M.y <= m && M !== r && M !== o && Mr(a, u, l, h, c, f, M.x, M.y) && ot(M.prev, M, M.next) >= 0)
            return !1;
        M = M.nextZ
    }
    return !0
}
function tA(n, e, t) {
    let i = n;
    do {
        const r = i.prev
          , s = i.next.next;
        !za(r, s) && cg(r, i, i.next, s) && Hs(r, s) && Hs(s, r) && (e.push(r.i / t | 0),
        e.push(i.i / t | 0),
        e.push(s.i / t | 0),
        ks(i),
        ks(i.next),
        i = n = s),
        i = i.next
    } while (i !== n);
    return Xi(i)
}
function nA(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && hA(o, a)) {
                let l = ug(o, a);
                o = Xi(o, o.next),
                l = Xi(l, l.next),
                Bs(o, e, t, i, r, s, 0),
                Bs(l, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function iA(n, e, t, i) {
    const r = [];
    let s, o, a, l, c;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * i,
        l = s < o - 1 ? e[s + 1] * i : n.length,
        c = lg(n, a, l, i, !1),
        c === c.next && (c.steiner = !0),
        r.push(uA(c));
    for (r.sort(rA),
    s = 0; s < r.length; s++)
        t = sA(r[s], t);
    return t
}
function rA(n, e) {
    return n.x - e.x
}
function sA(n, e) {
    const t = oA(n, e);
    if (!t)
        return e;
    const i = ug(t, n);
    return Xi(i, i.next),
    Xi(t, t.next)
}
function oA(n, e) {
    let t = e, i = -1 / 0, r;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const f = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (f <= s && f > i && (i = f,
            r = t.x < t.next.x ? t : t.next,
            f === s))
                return r
        }
        t = t.next
    } while (t !== e);
    if (!r)
        return null;
    const a = r
      , l = r.x
      , c = r.y;
    let u = 1 / 0, h;
    t = r;
    do
        s >= t.x && t.x >= l && s !== t.x && Mr(o < c ? s : i, o, l, c, o < c ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x),
        Hs(t, n) && (h < u || h === u && (t.x > r.x || t.x === r.x && aA(r, t))) && (r = t,
        u = h)),
        t = t.next;
    while (t !== a);
    return r
}
function aA(n, e) {
    return ot(n.prev, n, e.prev) < 0 && ot(e.next, n, n.next) < 0
}
function lA(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = Pc(r.x, r.y, e, t, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== n);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    cA(r)
}
function cA(n) {
    let e, t, i, r, s, o, a, l, c = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            i = t,
            a = 0,
            e = 0; e < c && (a++,
            i = i.nextZ,
            !!i); e++)
                ;
            for (l = c; a > 0 || l > 0 && i; )
                a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t,
                t = t.nextZ,
                a--) : (r = i,
                i = i.nextZ,
                l--),
                s ? s.nextZ = r : n = r,
                r.prevZ = s,
                s = r;
            t = i
        }
        s.nextZ = null,
        c *= 2
    } while (o > 1);
    return n
}
function Pc(n, e, t, i, r) {
    return n = (n - t) * r | 0,
    e = (e - i) * r | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function uA(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function Mr(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}
function hA(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !fA(n, e) && (Hs(n, e) && Hs(e, n) && dA(n, e) && (ot(n.prev, n, e.prev) || ot(n, e.prev, e)) || za(n, e) && ot(n.prev, n, n.next) > 0 && ot(e.prev, e, e.next) > 0)
}
function ot(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function za(n, e) {
    return n.x === e.x && n.y === e.y
}
function cg(n, e, t, i) {
    const r = zo(ot(n, e, t))
      , s = zo(ot(n, e, i))
      , o = zo(ot(t, i, n))
      , a = zo(ot(t, i, e));
    return !!(r !== s && o !== a || r === 0 && Oo(n, t, e) || s === 0 && Oo(n, i, e) || o === 0 && Oo(t, n, i) || a === 0 && Oo(t, e, i))
}
function Oo(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function zo(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function fA(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && cg(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function Hs(n, e) {
    return ot(n.prev, n, n.next) < 0 ? ot(n, e, n.next) >= 0 && ot(n, n.prev, e) >= 0 : ot(n, e, n.prev) < 0 || ot(n, n.next, e) < 0
}
function dA(n, e) {
    let t = n
      , i = !1;
    const r = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i),
        t = t.next;
    while (t !== n);
    return i
}
function ug(n, e) {
    const t = new Lc(n.i,n.x,n.y)
      , i = new Lc(e.i,e.x,e.y)
      , r = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = r,
    r.prev = t,
    i.next = t,
    t.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function Sd(n, e, t, i) {
    const r = new Lc(n,e,t);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function ks(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function Lc(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function pA(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i)
        r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return r
}
class Lr {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return Lr.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = []
          , r = []
          , s = [];
        Ed(e),
        bd(i, e);
        let o = e.length;
        t.forEach(Ed);
        for (let l = 0; l < t.length; l++)
            r.push(o),
            o += t[l].length,
            bd(i, t[l]);
        const a = Z1.triangulate(i, r);
        for (let l = 0; l < a.length; l += 3)
            s.push(a.slice(l, l + 3));
        return s
    }
}
function Ed(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function bd(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class Ba extends Zt {
    constructor(e=new ws([new xe(.5,.5), new xe(-.5,.5), new xe(-.5,-.5), new xe(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const i = this
          , r = []
          , s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new Tt(r,3)),
        this.setAttribute("uv", new Tt(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const l = []
              , c = t.curveSegments !== void 0 ? t.curveSegments : 12
              , u = t.steps !== void 0 ? t.steps : 1
              , h = t.depth !== void 0 ? t.depth : 1;
            let f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , p = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , g = t.bevelSize !== void 0 ? t.bevelSize : p - .1
              , x = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , m = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const d = t.extrudePath
              , v = t.UVGenerator !== void 0 ? t.UVGenerator : mA;
            let _, M = !1, b, A, C, P;
            d && (_ = d.getSpacedPoints(u),
            M = !0,
            f = !1,
            b = d.computeFrenetFrames(u, !1),
            A = new H,
            C = new H,
            P = new H),
            f || (m = 0,
            p = 0,
            g = 0,
            x = 0);
            const S = a.extractPoints(c);
            let T = S.shape;
            const F = S.holes;
            if (!Lr.isClockWise(T)) {
                T = T.reverse();
                for (let y = 0, R = F.length; y < R; y++) {
                    const D = F[y];
                    Lr.isClockWise(D) && (F[y] = D.reverse())
                }
            }
            const X = Lr.triangulateShape(T, F)
              , L = T;
            for (let y = 0, R = F.length; y < R; y++) {
                const D = F[y];
                T = T.concat(D)
            }
            function G(y, R, D) {
                return R || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                y.clone().addScaledVector(R, D)
            }
            const V = T.length
              , $ = X.length;
            function re(y, R, D) {
                let O, N, j;
                const Z = y.x - R.x
                  , Y = y.y - R.y
                  , oe = D.x - y.x
                  , Q = D.y - y.y
                  , be = Z * Z + Y * Y
                  , w = Z * Q - Y * oe;
                if (Math.abs(w) > Number.EPSILON) {
                    const E = Math.sqrt(be)
                      , z = Math.sqrt(oe * oe + Q * Q)
                      , ie = R.x - Y / E
                      , ae = R.y + Z / E
                      , ue = D.x - Q / z
                      , Se = D.y + oe / z
                      , pe = ((ue - ie) * Q - (Se - ae) * oe) / (Z * Q - Y * oe);
                    O = ie + Z * pe - y.x,
                    N = ae + Y * pe - y.y;
                    const Ee = O * O + N * N;
                    if (Ee <= 2)
                        return new xe(O,N);
                    j = Math.sqrt(Ee / 2)
                } else {
                    let E = !1;
                    Z > Number.EPSILON ? oe > Number.EPSILON && (E = !0) : Z < -Number.EPSILON ? oe < -Number.EPSILON && (E = !0) : Math.sign(Y) === Math.sign(Q) && (E = !0),
                    E ? (O = -Y,
                    N = Z,
                    j = Math.sqrt(be)) : (O = Z,
                    N = Y,
                    j = Math.sqrt(be / 2))
                }
                return new xe(O / j,N / j)
            }
            const ee = [];
            for (let y = 0, R = L.length, D = R - 1, O = y + 1; y < R; y++,
            D++,
            O++)
                D === R && (D = 0),
                O === R && (O = 0),
                ee[y] = re(L[y], L[D], L[O]);
            const le = [];
            let B, J = ee.concat();
            for (let y = 0, R = F.length; y < R; y++) {
                const D = F[y];
                B = [];
                for (let O = 0, N = D.length, j = N - 1, Z = O + 1; O < N; O++,
                j++,
                Z++)
                    j === N && (j = 0),
                    Z === N && (Z = 0),
                    B[O] = re(D[O], D[j], D[Z]);
                le.push(B),
                J = J.concat(B)
            }
            for (let y = 0; y < m; y++) {
                const R = y / m
                  , D = p * Math.cos(R * Math.PI / 2)
                  , O = g * Math.sin(R * Math.PI / 2) + x;
                for (let N = 0, j = L.length; N < j; N++) {
                    const Z = G(L[N], ee[N], O);
                    W(Z.x, Z.y, -D)
                }
                for (let N = 0, j = F.length; N < j; N++) {
                    const Z = F[N];
                    B = le[N];
                    for (let Y = 0, oe = Z.length; Y < oe; Y++) {
                        const Q = G(Z[Y], B[Y], O);
                        W(Q.x, Q.y, -D)
                    }
                }
            }
            const fe = g + x;
            for (let y = 0; y < V; y++) {
                const R = f ? G(T[y], J[y], fe) : T[y];
                M ? (C.copy(b.normals[0]).multiplyScalar(R.x),
                A.copy(b.binormals[0]).multiplyScalar(R.y),
                P.copy(_[0]).add(C).add(A),
                W(P.x, P.y, P.z)) : W(R.x, R.y, 0)
            }
            for (let y = 1; y <= u; y++)
                for (let R = 0; R < V; R++) {
                    const D = f ? G(T[R], J[R], fe) : T[R];
                    M ? (C.copy(b.normals[y]).multiplyScalar(D.x),
                    A.copy(b.binormals[y]).multiplyScalar(D.y),
                    P.copy(_[y]).add(C).add(A),
                    W(P.x, P.y, P.z)) : W(D.x, D.y, h / u * y)
                }
            for (let y = m - 1; y >= 0; y--) {
                const R = y / m
                  , D = p * Math.cos(R * Math.PI / 2)
                  , O = g * Math.sin(R * Math.PI / 2) + x;
                for (let N = 0, j = L.length; N < j; N++) {
                    const Z = G(L[N], ee[N], O);
                    W(Z.x, Z.y, h + D)
                }
                for (let N = 0, j = F.length; N < j; N++) {
                    const Z = F[N];
                    B = le[N];
                    for (let Y = 0, oe = Z.length; Y < oe; Y++) {
                        const Q = G(Z[Y], B[Y], O);
                        M ? W(Q.x, Q.y + _[u - 1].y, _[u - 1].x + D) : W(Q.x, Q.y, h + D)
                    }
                }
            }
            _e(),
            Te();
            function _e() {
                const y = r.length / 3;
                if (f) {
                    let R = 0
                      , D = V * R;
                    for (let O = 0; O < $; O++) {
                        const N = X[O];
                        se(N[2] + D, N[1] + D, N[0] + D)
                    }
                    R = u + m * 2,
                    D = V * R;
                    for (let O = 0; O < $; O++) {
                        const N = X[O];
                        se(N[0] + D, N[1] + D, N[2] + D)
                    }
                } else {
                    for (let R = 0; R < $; R++) {
                        const D = X[R];
                        se(D[2], D[1], D[0])
                    }
                    for (let R = 0; R < $; R++) {
                        const D = X[R];
                        se(D[0] + V * u, D[1] + V * u, D[2] + V * u)
                    }
                }
                i.addGroup(y, r.length / 3 - y, 0)
            }
            function Te() {
                const y = r.length / 3;
                let R = 0;
                Ae(L, R),
                R += L.length;
                for (let D = 0, O = F.length; D < O; D++) {
                    const N = F[D];
                    Ae(N, R),
                    R += N.length
                }
                i.addGroup(y, r.length / 3 - y, 1)
            }
            function Ae(y, R) {
                let D = y.length;
                for (; --D >= 0; ) {
                    const O = D;
                    let N = D - 1;
                    N < 0 && (N = y.length - 1);
                    for (let j = 0, Z = u + m * 2; j < Z; j++) {
                        const Y = V * j
                          , oe = V * (j + 1)
                          , Q = R + O + Y
                          , be = R + N + Y
                          , w = R + N + oe
                          , E = R + O + oe;
                        ce(Q, be, w, E)
                    }
                }
            }
            function W(y, R, D) {
                l.push(y),
                l.push(R),
                l.push(D)
            }
            function se(y, R, D) {
                ge(y),
                ge(R),
                ge(D);
                const O = r.length / 3
                  , N = v.generateTopUV(i, r, O - 3, O - 2, O - 1);
                he(N[0]),
                he(N[1]),
                he(N[2])
            }
            function ce(y, R, D, O) {
                ge(y),
                ge(R),
                ge(O),
                ge(R),
                ge(D),
                ge(O);
                const N = r.length / 3
                  , j = v.generateSideWallUV(i, r, N - 6, N - 3, N - 2, N - 1);
                he(j[0]),
                he(j[1]),
                he(j[3]),
                he(j[1]),
                he(j[2]),
                he(j[3])
            }
            function ge(y) {
                r.push(l[y * 3 + 0]),
                r.push(l[y * 3 + 1]),
                r.push(l[y * 3 + 2])
            }
            function he(y) {
                s.push(y.x),
                s.push(y.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , i = this.parameters.options;
        return gA(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new ha[r.type]().fromJSON(r)),
        new Ba(i,e.options)
    }
}
const mA = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[i * 3]
          , l = e[i * 3 + 1]
          , c = e[r * 3]
          , u = e[r * 3 + 1];
        return [new xe(s,o), new xe(a,l), new xe(c,u)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , l = e[t * 3 + 2]
          , c = e[i * 3]
          , u = e[i * 3 + 1]
          , h = e[i * 3 + 2]
          , f = e[r * 3]
          , p = e[r * 3 + 1]
          , g = e[r * 3 + 2]
          , x = e[s * 3]
          , m = e[s * 3 + 1]
          , d = e[s * 3 + 2];
        return Math.abs(a - u) < Math.abs(o - c) ? [new xe(o,1 - l), new xe(c,1 - h), new xe(f,1 - g), new xe(x,1 - d)] : [new xe(a,1 - l), new xe(u,1 - h), new xe(p,1 - g), new xe(m,1 - d)]
    }
};
function gA(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class Tu extends Zt {
    constructor(e=1, t=32, i=16, r=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        i = Math.max(2, Math.floor(i));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const u = []
          , h = new H
          , f = new H
          , p = []
          , g = []
          , x = []
          , m = [];
        for (let d = 0; d <= i; d++) {
            const v = []
              , _ = d / i;
            let M = 0;
            d === 0 && o === 0 ? M = .5 / t : d === i && l === Math.PI && (M = -.5 / t);
            for (let b = 0; b <= t; b++) {
                const A = b / t;
                h.x = -e * Math.cos(r + A * s) * Math.sin(o + _ * a),
                h.y = e * Math.cos(o + _ * a),
                h.z = e * Math.sin(r + A * s) * Math.sin(o + _ * a),
                g.push(h.x, h.y, h.z),
                f.copy(h).normalize(),
                x.push(f.x, f.y, f.z),
                m.push(A + M, 1 - _),
                v.push(c++)
            }
            u.push(v)
        }
        for (let d = 0; d < i; d++)
            for (let v = 0; v < t; v++) {
                const _ = u[d][v + 1]
                  , M = u[d][v]
                  , b = u[d + 1][v]
                  , A = u[d + 1][v + 1];
                (d !== 0 || o > 0) && p.push(_, M, A),
                (d !== i - 1 || l < Math.PI) && p.push(M, b, A)
            }
        this.setIndex(p),
        this.setAttribute("position", new Tt(g,3)),
        this.setAttribute("normal", new Tt(x,3)),
        this.setAttribute("uv", new Tt(m,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Tu(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class wu extends Zt {
    constructor(e=new og(new H(-1,-1,0),new H(-1,1,0),new H(1,1,0)), t=64, i=1, r=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const a = new H
          , l = new H
          , c = new xe;
        let u = new H;
        const h = []
          , f = []
          , p = []
          , g = [];
        x(),
        this.setIndex(g),
        this.setAttribute("position", new Tt(h,3)),
        this.setAttribute("normal", new Tt(f,3)),
        this.setAttribute("uv", new Tt(p,2));
        function x() {
            for (let _ = 0; _ < t; _++)
                m(_);
            m(s === !1 ? t : 0),
            v(),
            d()
        }
        function m(_) {
            u = e.getPointAt(_ / t, u);
            const M = o.normals[_]
              , b = o.binormals[_];
            for (let A = 0; A <= r; A++) {
                const C = A / r * Math.PI * 2
                  , P = Math.sin(C)
                  , S = -Math.cos(C);
                l.x = S * M.x + P * b.x,
                l.y = S * M.y + P * b.y,
                l.z = S * M.z + P * b.z,
                l.normalize(),
                f.push(l.x, l.y, l.z),
                a.x = u.x + i * l.x,
                a.y = u.y + i * l.y,
                a.z = u.z + i * l.z,
                h.push(a.x, a.y, a.z)
            }
        }
        function d() {
            for (let _ = 1; _ <= t; _++)
                for (let M = 1; M <= r; M++) {
                    const b = (r + 1) * (_ - 1) + (M - 1)
                      , A = (r + 1) * _ + (M - 1)
                      , C = (r + 1) * _ + M
                      , P = (r + 1) * (_ - 1) + M;
                    g.push(b, A, P),
                    g.push(A, C, P)
                }
        }
        function v() {
            for (let _ = 0; _ <= t; _++)
                for (let M = 0; M <= r; M++)
                    c.x = _ / t,
                    c.y = M / r,
                    p.push(c.x, c.y)
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new wu(new ha[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class _A extends Mi {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Xe(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Xe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Da,
        this.normalScale = new xe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class vA extends _A {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new xe(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return vt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Xe(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Xe(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Xe(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class Td extends Mi {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Xe(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Xe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Da,
        this.normalScale = new xe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class xA extends Mi {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Xe(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Da,
        this.normalScale = new xe(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
const fa = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class yA {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(u) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(u, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(u) {
            o++,
            r.onProgress !== void 0 && r.onProgress(u, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(u) {
            r.onError !== void 0 && r.onError(u)
        }
        ,
        this.resolveURL = function(u) {
            return l ? l(u) : u
        }
        ,
        this.setURLModifier = function(u) {
            return l = u,
            this
        }
        ,
        this.addHandler = function(u, h) {
            return c.push(u, h),
            this
        }
        ,
        this.removeHandler = function(u) {
            const h = c.indexOf(u);
            return h !== -1 && c.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(u) {
            for (let h = 0, f = c.length; h < f; h += 2) {
                const p = c[h]
                  , g = c[h + 1];
                if (p.global && (p.lastIndex = 0),
                p.test(u))
                    return g
            }
            return null
        }
    }
}
const MA = new yA;
class Zr {
    constructor(e) {
        this.manager = e !== void 0 ? e : MA,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
Zr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const kn = {};
class SA extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class hg extends Zr {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = fa.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (kn[e] !== void 0) {
            kn[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        kn[e] = [],
        kn[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const u = kn[e]
                  , h = c.body.getReader()
                  , f = c.headers.get("Content-Length") || c.headers.get("X-File-Size")
                  , p = f ? parseInt(f) : 0
                  , g = p !== 0;
                let x = 0;
                const m = new ReadableStream({
                    start(d) {
                        v();
                        function v() {
                            h.read().then( ({done: _, value: M}) => {
                                if (_)
                                    d.close();
                                else {
                                    x += M.byteLength;
                                    const b = new ProgressEvent("progress",{
                                        lengthComputable: g,
                                        loaded: x,
                                        total: p
                                    });
                                    for (let A = 0, C = u.length; A < C; A++) {
                                        const P = u[A];
                                        P.onProgress && P.onProgress(b)
                                    }
                                    d.enqueue(M),
                                    v()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(m)
            } else
                throw new SA(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
        }
        ).then(c => {
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(u => new DOMParser().parseFromString(u, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a)
                      , f = h && h[1] ? h[1].toLowerCase() : void 0
                      , p = new TextDecoder(f);
                    return c.arrayBuffer().then(g => p.decode(g))
                }
            }
        }
        ).then(c => {
            fa.add(e, c);
            const u = kn[e];
            delete kn[e];
            for (let h = 0, f = u.length; h < f; h++) {
                const p = u[h];
                p.onLoad && p.onLoad(c)
            }
        }
        ).catch(c => {
            const u = kn[e];
            if (u === void 0)
                throw this.manager.itemError(e),
                c;
            delete kn[e];
            for (let h = 0, f = u.length; h < f; h++) {
                const p = u[h];
                p.onError && p.onError(c)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class EA extends Zr {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = fa.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = zs("img");
        function l() {
            u(),
            fa.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function c(h) {
            u(),
            r && r(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function u() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class bA extends Zr {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new z1
          , a = new hg(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            let c;
            try {
                c = s.parse(l)
            } catch (u) {
                if (r !== void 0)
                    r(u);
                else {
                    console.error(u);
                    return
                }
            }
            c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
            o.image.height = c.height,
            o.image.data = c.data),
            o.wrapS = c.wrapS !== void 0 ? c.wrapS : qt,
            o.wrapT = c.wrapT !== void 0 ? c.wrapT : qt,
            o.magFilter = c.magFilter !== void 0 ? c.magFilter : Rt,
            o.minFilter = c.minFilter !== void 0 ? c.minFilter : Rt,
            o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
            c.colorSpace !== void 0 ? o.colorSpace = c.colorSpace : c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
            o.minFilter = Hr),
            c.mipmapCount === 1 && (o.minFilter = Rt),
            c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, c)
        }, i, r),
        o
    }
}
class Bl extends Zr {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new zt
          , o = new EA(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
class fg extends Ct {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Xe(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
const Hl = new ht
  , wd = new H
  , Ad = new H;
class TA {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new xe(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new ht,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new xu,
        this._frameExtents = new xe(1,1),
        this._viewportCount = 1,
        this._viewports = [new bt(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        wd.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(wd),
        Ad.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(Ad),
        t.updateMatrixWorld(),
        Hl.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Hl),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(Hl)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class wA extends TA {
    constructor() {
        super(new Ym(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class AA extends fg {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Ct.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Ct,
        this.shadow = new wA
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class RA extends fg {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class CA {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = Rd(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = Rd();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function Rd() {
    return (typeof performance > "u" ? Date : performance).now()
}
class PA {
    constructor(e, t, i=0, r=1 / 0) {
        this.ray = new _u(e,t),
        this.near = i,
        this.far = r,
        this.camera = null,
        this.layers = new vu,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t=!0, i=[]) {
        return Dc(e, this, i, t),
        i.sort(Cd),
        i
    }
    intersectObjects(e, t=!0, i=[]) {
        for (let r = 0, s = e.length; r < s; r++)
            Dc(e[r], this, i, t);
        return i.sort(Cd),
        i
    }
}
function Cd(n, e) {
    return n.distance - e.distance
}
function Dc(n, e, t, i) {
    if (n.layers.test(e.layers) && n.raycast(e, t),
    i === !0) {
        const r = n.children;
        for (let s = 0, o = r.length; s < o; s++)
            Dc(r[s], e, t, !0)
    }
}
class LA {
    constructor() {
        this.type = "ShapePath",
        this.color = new Xe,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Cc,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(d) {
            const v = [];
            for (let _ = 0, M = d.length; _ < M; _++) {
                const b = d[_]
                  , A = new ws;
                A.curves = b.curves,
                v.push(A)
            }
            return v
        }
        function i(d, v) {
            const _ = v.length;
            let M = !1;
            for (let b = _ - 1, A = 0; A < _; b = A++) {
                let C = v[b]
                  , P = v[A]
                  , S = P.x - C.x
                  , T = P.y - C.y;
                if (Math.abs(T) > Number.EPSILON) {
                    if (T < 0 && (C = v[A],
                    S = -S,
                    P = v[b],
                    T = -T),
                    d.y < C.y || d.y > P.y)
                        continue;
                    if (d.y === C.y) {
                        if (d.x === C.x)
                            return !0
                    } else {
                        const F = T * (d.x - C.x) - S * (d.y - C.y);
                        if (F === 0)
                            return !0;
                        if (F < 0)
                            continue;
                        M = !M
                    }
                } else {
                    if (d.y !== C.y)
                        continue;
                    if (P.x <= d.x && d.x <= C.x || C.x <= d.x && d.x <= P.x)
                        return !0
                }
            }
            return M
        }
        const r = Lr.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, l;
        const c = [];
        if (s.length === 1)
            return a = s[0],
            l = new ws,
            l.curves = a.curves,
            c.push(l),
            c;
        let u = !r(s[0].getPoints());
        u = e ? !u : u;
        const h = []
          , f = [];
        let p = [], g = 0, x;
        f[g] = void 0,
        p[g] = [];
        for (let d = 0, v = s.length; d < v; d++)
            a = s[d],
            x = a.getPoints(),
            o = r(x),
            o = e ? !o : o,
            o ? (!u && f[g] && g++,
            f[g] = {
                s: new ws,
                p: x
            },
            f[g].s.curves = a.curves,
            u && g++,
            p[g] = []) : p[g].push({
                h: a,
                p: x[0]
            });
        if (!f[0])
            return t(s);
        if (f.length > 1) {
            let d = !1
              , v = 0;
            for (let _ = 0, M = f.length; _ < M; _++)
                h[_] = [];
            for (let _ = 0, M = f.length; _ < M; _++) {
                const b = p[_];
                for (let A = 0; A < b.length; A++) {
                    const C = b[A];
                    let P = !0;
                    for (let S = 0; S < f.length; S++)
                        i(C.p, f[S].p) && (_ !== S && v++,
                        P ? (P = !1,
                        h[S].push(C)) : d = !0);
                    P && h[_].push(C)
                }
            }
            v > 0 && d === !1 && (p = h)
        }
        let m;
        for (let d = 0, v = f.length; d < v; d++) {
            l = f[d].s,
            c.push(l),
            m = p[d];
            for (let _ = 0, M = m.length; _ < M; _++)
                l.holes.push(m[_].h)
        }
        return c
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: pu
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = pu);
class DA extends Zr {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new hg(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            const l = s.parse(JSON.parse(a));
            t && t(l)
        }, i, r)
    }
    parse(e) {
        return new IA(e)
    }
}
class IA {
    constructor(e) {
        this.isFont = !0,
        this.type = "Font",
        this.data = e
    }
    generateShapes(e, t=100) {
        const i = []
          , r = UA(e, t, this.data);
        for (let s = 0, o = r.length; s < o; s++)
            i.push(...r[s].toShapes());
        return i
    }
}
function UA(n, e, t) {
    const i = Array.from(n)
      , r = e / t.resolution
      , s = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * r
      , o = [];
    let a = 0
      , l = 0;
    for (let c = 0; c < i.length; c++) {
        const u = i[c];
        if (u === `
`)
            a = 0,
            l -= s;
        else {
            const h = NA(u, r, a, l, t);
            a += h.offsetX,
            o.push(h.path)
        }
    }
    return o
}
function NA(n, e, t, i, r) {
    const s = r.glyphs[n] || r.glyphs["?"];
    if (!s) {
        console.error('THREE.Font: character "' + n + '" does not exists in font family ' + r.familyName + ".");
        return
    }
    const o = new LA;
    let a, l, c, u, h, f, p, g;
    if (s.o) {
        const x = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
        for (let m = 0, d = x.length; m < d; )
            switch (x[m++]) {
            case "m":
                a = x[m++] * e + t,
                l = x[m++] * e + i,
                o.moveTo(a, l);
                break;
            case "l":
                a = x[m++] * e + t,
                l = x[m++] * e + i,
                o.lineTo(a, l);
                break;
            case "q":
                c = x[m++] * e + t,
                u = x[m++] * e + i,
                h = x[m++] * e + t,
                f = x[m++] * e + i,
                o.quadraticCurveTo(h, f, c, u);
                break;
            case "b":
                c = x[m++] * e + t,
                u = x[m++] * e + i,
                h = x[m++] * e + t,
                f = x[m++] * e + i,
                p = x[m++] * e + t,
                g = x[m++] * e + i,
                o.bezierCurveTo(h, f, p, g, c, u);
                break
            }
    }
    return {
        offsetX: s.ha * e,
        path: o
    }
}
class FA extends Ba {
    constructor(e, t={}) {
        const i = t.font;
        if (i === void 0)
            super();
        else {
            const r = i.generateShapes(e, t.size);
            t.depth = t.height !== void 0 ? t.height : 50,
            t.bevelThickness === void 0 && (t.bevelThickness = 10),
            t.bevelSize === void 0 && (t.bevelSize = 8),
            t.bevelEnabled === void 0 && (t.bevelEnabled = !1),
            super(r, t)
        }
        this.type = "TextGeometry"
    }
}
class OA extends bA {
    constructor(e) {
        super(e),
        this.type = $n
    }
    parse(e) {
        const o = function(P, S) {
            switch (P) {
            case 1:
                throw new Error("THREE.RGBELoader: Read Error: " + (S || ""));
            case 2:
                throw new Error("THREE.RGBELoader: Write Error: " + (S || ""));
            case 3:
                throw new Error("THREE.RGBELoader: Bad File Format: " + (S || ""));
            default:
            case 4:
                throw new Error("THREE.RGBELoader: Memory Error: " + (S || ""))
            }
        }
          , u = `
`
          , h = function(P, S, T) {
            S = S || 1024;
            let k = P.pos
              , X = -1
              , L = 0
              , G = ""
              , V = String.fromCharCode.apply(null, new Uint16Array(P.subarray(k, k + 128)));
            for (; 0 > (X = V.indexOf(u)) && L < S && k < P.byteLength; )
                G += V,
                L += V.length,
                k += 128,
                V += String.fromCharCode.apply(null, new Uint16Array(P.subarray(k, k + 128)));
            return -1 < X ? (T !== !1 && (P.pos += L + X + 1),
            G + V.slice(0, X)) : !1
        }
          , f = function(P) {
            const S = /^#\?(\S+)/
              , T = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , F = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , k = /^\s*FORMAT=(\S+)\s*$/
              , X = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , L = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let G, V;
            for ((P.pos >= P.byteLength || !(G = h(P))) && o(1, "no header found"),
            (V = G.match(S)) || o(3, "bad initial token"),
            L.valid |= 1,
            L.programtype = V[1],
            L.string += G + `
`; G = h(P),
            G !== !1; ) {
                if (L.string += G + `
`,
                G.charAt(0) === "#") {
                    L.comments += G + `
`;
                    continue
                }
                if ((V = G.match(T)) && (L.gamma = parseFloat(V[1])),
                (V = G.match(F)) && (L.exposure = parseFloat(V[1])),
                (V = G.match(k)) && (L.valid |= 2,
                L.format = V[1]),
                (V = G.match(X)) && (L.valid |= 4,
                L.height = parseInt(V[1], 10),
                L.width = parseInt(V[2], 10)),
                L.valid & 2 && L.valid & 4)
                    break
            }
            return L.valid & 2 || o(3, "missing format specifier"),
            L.valid & 4 || o(3, "missing image size specifier"),
            L
        }
          , p = function(P, S, T) {
            const F = S;
            if (F < 8 || F > 32767 || P[0] !== 2 || P[1] !== 2 || P[2] & 128)
                return new Uint8Array(P);
            F !== (P[2] << 8 | P[3]) && o(3, "wrong scanline width");
            const k = new Uint8Array(4 * S * T);
            k.length || o(4, "unable to allocate buffer space");
            let X = 0
              , L = 0;
            const G = 4 * F
              , V = new Uint8Array(4)
              , $ = new Uint8Array(G);
            let re = T;
            for (; re > 0 && L < P.byteLength; ) {
                L + 4 > P.byteLength && o(1),
                V[0] = P[L++],
                V[1] = P[L++],
                V[2] = P[L++],
                V[3] = P[L++],
                (V[0] != 2 || V[1] != 2 || (V[2] << 8 | V[3]) != F) && o(3, "bad rgbe scanline format");
                let ee = 0, le;
                for (; ee < G && L < P.byteLength; ) {
                    le = P[L++];
                    const J = le > 128;
                    if (J && (le -= 128),
                    (le === 0 || ee + le > G) && o(3, "bad scanline data"),
                    J) {
                        const fe = P[L++];
                        for (let _e = 0; _e < le; _e++)
                            $[ee++] = fe
                    } else
                        $.set(P.subarray(L, L + le), ee),
                        ee += le,
                        L += le
                }
                const B = F;
                for (let J = 0; J < B; J++) {
                    let fe = 0;
                    k[X] = $[J + fe],
                    fe += F,
                    k[X + 1] = $[J + fe],
                    fe += F,
                    k[X + 2] = $[J + fe],
                    fe += F,
                    k[X + 3] = $[J + fe],
                    X += 4
                }
                re--
            }
            return k
        }
          , g = function(P, S, T, F) {
            const k = P[S + 3]
              , X = Math.pow(2, k - 128) / 255;
            T[F + 0] = P[S + 0] * X,
            T[F + 1] = P[S + 1] * X,
            T[F + 2] = P[S + 2] * X,
            T[F + 3] = 1
        }
          , x = function(P, S, T, F) {
            const k = P[S + 3]
              , X = Math.pow(2, k - 128) / 255;
            T[F + 0] = Mo.toHalfFloat(Math.min(P[S + 0] * X, 65504)),
            T[F + 1] = Mo.toHalfFloat(Math.min(P[S + 1] * X, 65504)),
            T[F + 2] = Mo.toHalfFloat(Math.min(P[S + 2] * X, 65504)),
            T[F + 3] = Mo.toHalfFloat(1)
        }
          , m = new Uint8Array(e);
        m.pos = 0;
        const d = f(m)
          , v = d.width
          , _ = d.height
          , M = p(m.subarray(m.pos), v, _);
        let b, A, C;
        switch (this.type) {
        case xn:
            C = M.length / 4;
            const P = new Float32Array(C * 4);
            for (let T = 0; T < C; T++)
                g(M, T * 4, P, T * 4);
            b = P,
            A = xn;
            break;
        case $n:
            C = M.length / 4;
            const S = new Uint16Array(C * 4);
            for (let T = 0; T < C; T++)
                x(M, T * 4, S, T * 4);
            b = S,
            A = $n;
            break;
        default:
            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: v,
            height: _,
            data: b,
            header: d.string,
            gamma: d.gamma,
            exposure: d.exposure,
            type: A
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, i, r) {
        function s(o, a) {
            switch (o.type) {
            case xn:
            case $n:
                o.colorSpace = Ln,
                o.minFilter = Rt,
                o.magFilter = Rt,
                o.generateMipmaps = !1,
                o.flipY = !0;
                break
            }
            t && t(o, a)
        }
        return super.load(e, s, i, r)
    }
}
var zA = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function BA(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var dg = {
    exports: {}
};
(function(n, e) {
    (function(t, i) {
        n.exports = i()
    }
    )(zA, function() {
        var t = function() {
            function i(p) {
                return o.appendChild(p.dom),
                p
            }
            function r(p) {
                for (var g = 0; g < o.children.length; g++)
                    o.children[g].style.display = g === p ? "block" : "none";
                s = p
            }
            var s = 0
              , o = document.createElement("div");
            o.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
            o.addEventListener("click", function(p) {
                p.preventDefault(),
                r(++s % o.children.length)
            }, !1);
            var a = (performance || Date).now()
              , l = a
              , c = 0
              , u = i(new t.Panel("FPS","#0ff","#002"))
              , h = i(new t.Panel("MS","#0f0","#020"));
            if (self.performance && self.performance.memory)
                var f = i(new t.Panel("MB","#f08","#201"));
            return r(0),
            {
                REVISION: 16,
                dom: o,
                addPanel: i,
                showPanel: r,
                begin: function() {
                    a = (performance || Date).now()
                },
                end: function() {
                    c++;
                    var p = (performance || Date).now();
                    if (h.update(p - a, 200),
                    p > l + 1e3 && (u.update(1e3 * c / (p - l), 100),
                    l = p,
                    c = 0,
                    f)) {
                        var g = performance.memory;
                        f.update(g.usedJSHeapSize / 1048576, g.jsHeapSizeLimit / 1048576)
                    }
                    return p
                },
                update: function() {
                    a = this.end()
                },
                domElement: o,
                setMode: r
            }
        };
        return t.Panel = function(i, r, s) {
            var o = 1 / 0
              , a = 0
              , l = Math.round
              , c = l(window.devicePixelRatio || 1)
              , u = 80 * c
              , h = 48 * c
              , f = 3 * c
              , p = 2 * c
              , g = 3 * c
              , x = 15 * c
              , m = 74 * c
              , d = 30 * c
              , v = document.createElement("canvas");
            v.width = u,
            v.height = h,
            v.style.cssText = "width:80px;height:48px";
            var _ = v.getContext("2d");
            return _.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif",
            _.textBaseline = "top",
            _.fillStyle = s,
            _.fillRect(0, 0, u, h),
            _.fillStyle = r,
            _.fillText(i, f, p),
            _.fillRect(g, x, m, d),
            _.fillStyle = s,
            _.globalAlpha = .9,
            _.fillRect(g, x, m, d),
            {
                dom: v,
                update: function(M, b) {
                    o = Math.min(o, M),
                    a = Math.max(a, M),
                    _.fillStyle = s,
                    _.globalAlpha = 1,
                    _.fillRect(0, 0, u, x),
                    _.fillStyle = r,
                    _.fillText(l(M) + " " + i + " (" + l(o) + "-" + l(a) + ")", f, p),
                    _.drawImage(v, g + c, x, m - c, d, g, x, m - c, d),
                    _.fillRect(g + m - c, x, c, d),
                    _.fillStyle = s,
                    _.globalAlpha = .9,
                    _.fillRect(g + m - c, x, c, l((1 - M / b) * d))
                }
            }
        }
        ,
        t
    })
}
)(dg);
var HA = dg.exports;
const kA = BA(HA);
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.18.2
 * @author George Michael Brower
 * @license MIT
 */
class Cn {
    constructor(e, t, i, r, s="div") {
        this.parent = e,
        this.object = t,
        this.property = i,
        this._disabled = !1,
        this._hidden = !1,
        this.initialValue = this.getValue(),
        this.domElement = document.createElement("div"),
        this.domElement.classList.add("controller"),
        this.domElement.classList.add(r),
        this.$name = document.createElement("div"),
        this.$name.classList.add("name"),
        Cn.nextNameID = Cn.nextNameID || 0,
        this.$name.id = `lil-gui-name-${++Cn.nextNameID}`,
        this.$widget = document.createElement(s),
        this.$widget.classList.add("widget"),
        this.$disable = this.$widget,
        this.domElement.appendChild(this.$name),
        this.domElement.appendChild(this.$widget),
        this.domElement.addEventListener("keydown", o => o.stopPropagation()),
        this.domElement.addEventListener("keyup", o => o.stopPropagation()),
        this.parent.children.push(this),
        this.parent.controllers.push(this),
        this.parent.$children.appendChild(this.domElement),
        this._listenCallback = this._listenCallback.bind(this),
        this.name(i)
    }
    name(e) {
        return this._name = e,
        this.$name.innerHTML = e,
        this
    }
    onChange(e) {
        return this._onChange = e,
        this
    }
    _callOnChange() {
        this.parent._callOnChange(this),
        this._onChange !== void 0 && this._onChange.call(this, this.getValue()),
        this._changed = !0
    }
    onFinishChange(e) {
        return this._onFinishChange = e,
        this
    }
    _callOnFinishChange() {
        this._changed && (this.parent._callOnFinishChange(this),
        this._onFinishChange !== void 0 && this._onFinishChange.call(this, this.getValue())),
        this._changed = !1
    }
    reset() {
        return this.setValue(this.initialValue),
        this._callOnFinishChange(),
        this
    }
    enable(e=!0) {
        return this.disable(!e)
    }
    disable(e=!0) {
        return e === this._disabled ? this : (this._disabled = e,
        this.domElement.classList.toggle("disabled", e),
        this.$disable.toggleAttribute("disabled", e),
        this)
    }
    show(e=!0) {
        return this._hidden = !e,
        this.domElement.style.display = this._hidden ? "none" : "",
        this
    }
    hide() {
        return this.show(!1)
    }
    options(e) {
        const t = this.parent.add(this.object, this.property, e);
        return t.name(this._name),
        this.destroy(),
        t
    }
    min(e) {
        return this
    }
    max(e) {
        return this
    }
    step(e) {
        return this
    }
    decimals(e) {
        return this
    }
    listen(e=!0) {
        return this._listening = e,
        this._listenCallbackID !== void 0 && (cancelAnimationFrame(this._listenCallbackID),
        this._listenCallbackID = void 0),
        this._listening && this._listenCallback(),
        this
    }
    _listenCallback() {
        this._listenCallbackID = requestAnimationFrame(this._listenCallback);
        const e = this.save();
        e !== this._listenPrevValue && this.updateDisplay(),
        this._listenPrevValue = e
    }
    getValue() {
        return this.object[this.property]
    }
    setValue(e) {
        return this.object[this.property] = e,
        this._callOnChange(),
        this.updateDisplay(),
        this
    }
    updateDisplay() {
        return this
    }
    load(e) {
        return this.setValue(e),
        this._callOnFinishChange(),
        this
    }
    save() {
        return this.getValue()
    }
    destroy() {
        this.listen(!1),
        this.parent.children.splice(this.parent.children.indexOf(this), 1),
        this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1),
        this.parent.$children.removeChild(this.domElement)
    }
}
class GA extends Cn {
    constructor(e, t, i) {
        super(e, t, i, "boolean", "label"),
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "checkbox"),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        this.$widget.appendChild(this.$input),
        this.$input.addEventListener("change", () => {
            this.setValue(this.$input.checked),
            this._callOnFinishChange()
        }
        ),
        this.$disable = this.$input,
        this.updateDisplay()
    }
    updateDisplay() {
        return this.$input.checked = this.getValue(),
        this
    }
}
function Ic(n) {
    let e, t;
    return (e = n.match(/(#|0x)?([a-f0-9]{6})/i)) ? t = e[2] : (e = n.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? t = parseInt(e[1]).toString(16).padStart(2, 0) + parseInt(e[2]).toString(16).padStart(2, 0) + parseInt(e[3]).toString(16).padStart(2, 0) : (e = n.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (t = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
    t ? "#" + t : !1
}
const VA = {
    isPrimitive: !0,
    match: n => typeof n == "string",
    fromHexString: Ic,
    toHexString: Ic
}
  , Gs = {
    isPrimitive: !0,
    match: n => typeof n == "number",
    fromHexString: n => parseInt(n.substring(1), 16),
    toHexString: n => "#" + n.toString(16).padStart(6, 0)
}
  , WA = {
    isPrimitive: !1,
    match: n => Array.isArray(n),
    fromHexString(n, e, t=1) {
        const i = Gs.fromHexString(n);
        e[0] = (i >> 16 & 255) / 255 * t,
        e[1] = (i >> 8 & 255) / 255 * t,
        e[2] = (i & 255) / 255 * t
    },
    toHexString([n,e,t], i=1) {
        i = 255 / i;
        const r = n * i << 16 ^ e * i << 8 ^ t * i << 0;
        return Gs.toHexString(r)
    }
}
  , XA = {
    isPrimitive: !1,
    match: n => Object(n) === n,
    fromHexString(n, e, t=1) {
        const i = Gs.fromHexString(n);
        e.r = (i >> 16 & 255) / 255 * t,
        e.g = (i >> 8 & 255) / 255 * t,
        e.b = (i & 255) / 255 * t
    },
    toHexString({r: n, g: e, b: t}, i=1) {
        i = 255 / i;
        const r = n * i << 16 ^ e * i << 8 ^ t * i << 0;
        return Gs.toHexString(r)
    }
}
  , $A = [VA, Gs, WA, XA];
function jA(n) {
    return $A.find(e => e.match(n))
}
class KA extends Cn {
    constructor(e, t, i, r) {
        super(e, t, i, "color"),
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "color"),
        this.$input.setAttribute("tabindex", -1),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        this.$text = document.createElement("input"),
        this.$text.setAttribute("type", "text"),
        this.$text.setAttribute("spellcheck", "false"),
        this.$text.setAttribute("aria-labelledby", this.$name.id),
        this.$display = document.createElement("div"),
        this.$display.classList.add("display"),
        this.$display.appendChild(this.$input),
        this.$widget.appendChild(this.$display),
        this.$widget.appendChild(this.$text),
        this._format = jA(this.initialValue),
        this._rgbScale = r,
        this._initialValueHexString = this.save(),
        this._textFocused = !1,
        this.$input.addEventListener("input", () => {
            this._setValueFromHexString(this.$input.value)
        }
        ),
        this.$input.addEventListener("blur", () => {
            this._callOnFinishChange()
        }
        ),
        this.$text.addEventListener("input", () => {
            const s = Ic(this.$text.value);
            s && this._setValueFromHexString(s)
        }
        ),
        this.$text.addEventListener("focus", () => {
            this._textFocused = !0,
            this.$text.select()
        }
        ),
        this.$text.addEventListener("blur", () => {
            this._textFocused = !1,
            this.updateDisplay(),
            this._callOnFinishChange()
        }
        ),
        this.$disable = this.$text,
        this.updateDisplay()
    }
    reset() {
        return this._setValueFromHexString(this._initialValueHexString),
        this
    }
    _setValueFromHexString(e) {
        if (this._format.isPrimitive) {
            const t = this._format.fromHexString(e);
            this.setValue(t)
        } else
            this._format.fromHexString(e, this.getValue(), this._rgbScale),
            this._callOnChange(),
            this.updateDisplay()
    }
    save() {
        return this._format.toHexString(this.getValue(), this._rgbScale)
    }
    load(e) {
        return this._setValueFromHexString(e),
        this._callOnFinishChange(),
        this
    }
    updateDisplay() {
        return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale),
        this._textFocused || (this.$text.value = this.$input.value.substring(1)),
        this.$display.style.backgroundColor = this.$input.value,
        this
    }
}
class kl extends Cn {
    constructor(e, t, i) {
        super(e, t, i, "function"),
        this.$button = document.createElement("button"),
        this.$button.appendChild(this.$name),
        this.$widget.appendChild(this.$button),
        this.$button.addEventListener("click", r => {
            r.preventDefault(),
            this.getValue().call(this.object),
            this._callOnChange()
        }
        ),
        this.$button.addEventListener("touchstart", () => {}
        , {
            passive: !0
        }),
        this.$disable = this.$button
    }
}
class qA extends Cn {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, "number"),
        this._initInput(),
        this.min(r),
        this.max(s);
        const a = o !== void 0;
        this.step(a ? o : this._getImplicitStep(), a),
        this.updateDisplay()
    }
    decimals(e) {
        return this._decimals = e,
        this.updateDisplay(),
        this
    }
    min(e) {
        return this._min = e,
        this._onUpdateMinMax(),
        this
    }
    max(e) {
        return this._max = e,
        this._onUpdateMinMax(),
        this
    }
    step(e, t=!0) {
        return this._step = e,
        this._stepExplicit = t,
        this
    }
    updateDisplay() {
        const e = this.getValue();
        if (this._hasSlider) {
            let t = (e - this._min) / (this._max - this._min);
            t = Math.max(0, Math.min(t, 1)),
            this.$fill.style.width = t * 100 + "%"
        }
        return this._inputFocused || (this.$input.value = this._decimals === void 0 ? e : e.toFixed(this._decimals)),
        this
    }
    _initInput() {
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "text"),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        window.matchMedia("(pointer: coarse)").matches && (this.$input.setAttribute("type", "number"),
        this.$input.setAttribute("step", "any")),
        this.$widget.appendChild(this.$input),
        this.$disable = this.$input;
        const t = () => {
            let v = parseFloat(this.$input.value);
            isNaN(v) || (this._stepExplicit && (v = this._snap(v)),
            this.setValue(this._clamp(v)))
        }
          , i = v => {
            const _ = parseFloat(this.$input.value);
            isNaN(_) || (this._snapClampSetValue(_ + v),
            this.$input.value = this.getValue())
        }
          , r = v => {
            v.key === "Enter" && this.$input.blur(),
            v.code === "ArrowUp" && (v.preventDefault(),
            i(this._step * this._arrowKeyMultiplier(v))),
            v.code === "ArrowDown" && (v.preventDefault(),
            i(this._step * this._arrowKeyMultiplier(v) * -1))
        }
          , s = v => {
            this._inputFocused && (v.preventDefault(),
            i(this._step * this._normalizeMouseWheel(v)))
        }
        ;
        let o = !1, a, l, c, u, h;
        const f = 5
          , p = v => {
            a = v.clientX,
            l = c = v.clientY,
            o = !0,
            u = this.getValue(),
            h = 0,
            window.addEventListener("mousemove", g),
            window.addEventListener("mouseup", x)
        }
          , g = v => {
            if (o) {
                const _ = v.clientX - a
                  , M = v.clientY - l;
                Math.abs(M) > f ? (v.preventDefault(),
                this.$input.blur(),
                o = !1,
                this._setDraggingStyle(!0, "vertical")) : Math.abs(_) > f && x()
            }
            if (!o) {
                const _ = v.clientY - c;
                h -= _ * this._step * this._arrowKeyMultiplier(v),
                u + h > this._max ? h = this._max - u : u + h < this._min && (h = this._min - u),
                this._snapClampSetValue(u + h)
            }
            c = v.clientY
        }
          , x = () => {
            this._setDraggingStyle(!1, "vertical"),
            this._callOnFinishChange(),
            window.removeEventListener("mousemove", g),
            window.removeEventListener("mouseup", x)
        }
          , m = () => {
            this._inputFocused = !0
        }
          , d = () => {
            this._inputFocused = !1,
            this.updateDisplay(),
            this._callOnFinishChange()
        }
        ;
        this.$input.addEventListener("input", t),
        this.$input.addEventListener("keydown", r),
        this.$input.addEventListener("wheel", s, {
            passive: !1
        }),
        this.$input.addEventListener("mousedown", p),
        this.$input.addEventListener("focus", m),
        this.$input.addEventListener("blur", d)
    }
    _initSlider() {
        this._hasSlider = !0,
        this.$slider = document.createElement("div"),
        this.$slider.classList.add("slider"),
        this.$fill = document.createElement("div"),
        this.$fill.classList.add("fill"),
        this.$slider.appendChild(this.$fill),
        this.$widget.insertBefore(this.$slider, this.$input),
        this.domElement.classList.add("hasSlider");
        const e = (d, v, _, M, b) => (d - v) / (_ - v) * (b - M) + M
          , t = d => {
            const v = this.$slider.getBoundingClientRect();
            let _ = e(d, v.left, v.right, this._min, this._max);
            this._snapClampSetValue(_)
        }
          , i = d => {
            this._setDraggingStyle(!0),
            t(d.clientX),
            window.addEventListener("mousemove", r),
            window.addEventListener("mouseup", s)
        }
          , r = d => {
            t(d.clientX)
        }
          , s = () => {
            this._callOnFinishChange(),
            this._setDraggingStyle(!1),
            window.removeEventListener("mousemove", r),
            window.removeEventListener("mouseup", s)
        }
        ;
        let o = !1, a, l;
        const c = d => {
            d.preventDefault(),
            this._setDraggingStyle(!0),
            t(d.touches[0].clientX),
            o = !1
        }
          , u = d => {
            d.touches.length > 1 || (this._hasScrollBar ? (a = d.touches[0].clientX,
            l = d.touches[0].clientY,
            o = !0) : c(d),
            window.addEventListener("touchmove", h, {
                passive: !1
            }),
            window.addEventListener("touchend", f))
        }
          , h = d => {
            if (o) {
                const v = d.touches[0].clientX - a
                  , _ = d.touches[0].clientY - l;
                Math.abs(v) > Math.abs(_) ? c(d) : (window.removeEventListener("touchmove", h),
                window.removeEventListener("touchend", f))
            } else
                d.preventDefault(),
                t(d.touches[0].clientX)
        }
          , f = () => {
            this._callOnFinishChange(),
            this._setDraggingStyle(!1),
            window.removeEventListener("touchmove", h),
            window.removeEventListener("touchend", f)
        }
          , p = this._callOnFinishChange.bind(this)
          , g = 400;
        let x;
        const m = d => {
            if (Math.abs(d.deltaX) < Math.abs(d.deltaY) && this._hasScrollBar)
                return;
            d.preventDefault();
            const _ = this._normalizeMouseWheel(d) * this._step;
            this._snapClampSetValue(this.getValue() + _),
            this.$input.value = this.getValue(),
            clearTimeout(x),
            x = setTimeout(p, g)
        }
        ;
        this.$slider.addEventListener("mousedown", i),
        this.$slider.addEventListener("touchstart", u, {
            passive: !1
        }),
        this.$slider.addEventListener("wheel", m, {
            passive: !1
        })
    }
    _setDraggingStyle(e, t="horizontal") {
        this.$slider && this.$slider.classList.toggle("active", e),
        document.body.classList.toggle("lil-gui-dragging", e),
        document.body.classList.toggle(`lil-gui-${t}`, e)
    }
    _getImplicitStep() {
        return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : .1
    }
    _onUpdateMinMax() {
        !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), !1),
        this._initSlider(),
        this.updateDisplay())
    }
    _normalizeMouseWheel(e) {
        let {deltaX: t, deltaY: i} = e;
        return Math.floor(e.deltaY) !== e.deltaY && e.wheelDelta && (t = 0,
        i = -e.wheelDelta / 120,
        i *= this._stepExplicit ? 1 : 10),
        t + -i
    }
    _arrowKeyMultiplier(e) {
        let t = this._stepExplicit ? 1 : 10;
        return e.shiftKey ? t *= 10 : e.altKey && (t /= 10),
        t
    }
    _snap(e) {
        const t = Math.round(e / this._step) * this._step;
        return parseFloat(t.toPrecision(15))
    }
    _clamp(e) {
        return e < this._min && (e = this._min),
        e > this._max && (e = this._max),
        e
    }
    _snapClampSetValue(e) {
        this.setValue(this._clamp(this._snap(e)))
    }
    get _hasScrollBar() {
        const e = this.parent.root.$children;
        return e.scrollHeight > e.clientHeight
    }
    get _hasMin() {
        return this._min !== void 0
    }
    get _hasMax() {
        return this._max !== void 0
    }
}
class YA extends Cn {
    constructor(e, t, i, r) {
        super(e, t, i, "option"),
        this.$select = document.createElement("select"),
        this.$select.setAttribute("aria-labelledby", this.$name.id),
        this.$display = document.createElement("div"),
        this.$display.classList.add("display"),
        this._values = Array.isArray(r) ? r : Object.values(r),
        this._names = Array.isArray(r) ? r : Object.keys(r),
        this._names.forEach(s => {
            const o = document.createElement("option");
            o.innerHTML = s,
            this.$select.appendChild(o)
        }
        ),
        this.$select.addEventListener("change", () => {
            this.setValue(this._values[this.$select.selectedIndex]),
            this._callOnFinishChange()
        }
        ),
        this.$select.addEventListener("focus", () => {
            this.$display.classList.add("focus")
        }
        ),
        this.$select.addEventListener("blur", () => {
            this.$display.classList.remove("focus")
        }
        ),
        this.$widget.appendChild(this.$select),
        this.$widget.appendChild(this.$display),
        this.$disable = this.$select,
        this.updateDisplay()
    }
    updateDisplay() {
        const e = this.getValue()
          , t = this._values.indexOf(e);
        return this.$select.selectedIndex = t,
        this.$display.innerHTML = t === -1 ? e : this._names[t],
        this
    }
}
class JA extends Cn {
    constructor(e, t, i) {
        super(e, t, i, "string"),
        this.$input = document.createElement("input"),
        this.$input.setAttribute("type", "text"),
        this.$input.setAttribute("aria-labelledby", this.$name.id),
        this.$input.addEventListener("input", () => {
            this.setValue(this.$input.value)
        }
        ),
        this.$input.addEventListener("keydown", r => {
            r.code === "Enter" && this.$input.blur()
        }
        ),
        this.$input.addEventListener("blur", () => {
            this._callOnFinishChange()
        }
        ),
        this.$widget.appendChild(this.$input),
        this.$disable = this.$input,
        this.updateDisplay()
    }
    updateDisplay() {
        return this.$input.value = this.getValue(),
        this
    }
}
const ZA = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  background-color: var(--background-color);
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean .widget {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background-color: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background-color: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background-color: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui input {
  -webkit-tap-highlight-color: transparent;
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input::-webkit-outer-spin-button,
.lil-gui input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.lil-gui input[type=number] {
  -moz-appearance: textfield;
}
.lil-gui input[type=checkbox] {
  appearance: none;
  -webkit-appearance: none;
  height: var(--checkbox-size);
  width: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  -webkit-tap-highlight-color: transparent;
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: 1px solid var(--widget-color);
  text-align: center;
  line-height: calc(var(--widget-height) - 4px);
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
    border-color: var(--hover-color);
  }
  .lil-gui button:focus {
    border-color: var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;
function QA(n) {
    const e = document.createElement("style");
    e.innerHTML = n;
    const t = document.querySelector("head link[rel=stylesheet], head style");
    t ? document.head.insertBefore(e, t) : document.head.appendChild(e)
}
let Pd = !1;
class Au {
    constructor({parent: e, autoPlace: t=e === void 0, container: i, width: r, title: s="Controls", closeFolders: o=!1, injectStyles: a=!0, touchStyles: l=!0}={}) {
        if (this.parent = e,
        this.root = e ? e.root : this,
        this.children = [],
        this.controllers = [],
        this.folders = [],
        this._closed = !1,
        this._hidden = !1,
        this.domElement = document.createElement("div"),
        this.domElement.classList.add("lil-gui"),
        this.$title = document.createElement("div"),
        this.$title.classList.add("title"),
        this.$title.setAttribute("role", "button"),
        this.$title.setAttribute("aria-expanded", !0),
        this.$title.setAttribute("tabindex", 0),
        this.$title.addEventListener("click", () => this.openAnimated(this._closed)),
        this.$title.addEventListener("keydown", c => {
            (c.code === "Enter" || c.code === "Space") && (c.preventDefault(),
            this.$title.click())
        }
        ),
        this.$title.addEventListener("touchstart", () => {}
        , {
            passive: !0
        }),
        this.$children = document.createElement("div"),
        this.$children.classList.add("children"),
        this.domElement.appendChild(this.$title),
        this.domElement.appendChild(this.$children),
        this.title(s),
        this.parent) {
            this.parent.children.push(this),
            this.parent.folders.push(this),
            this.parent.$children.appendChild(this.domElement);
            return
        }
        this.domElement.classList.add("root"),
        l && this.domElement.classList.add("allow-touch-styles"),
        !Pd && a && (QA(ZA),
        Pd = !0),
        i ? i.appendChild(this.domElement) : t && (this.domElement.classList.add("autoPlace"),
        document.body.appendChild(this.domElement)),
        r && this.domElement.style.setProperty("--width", r + "px"),
        this._closeFolders = o
    }
    add(e, t, i, r, s) {
        if (Object(i) === i)
            return new YA(this,e,t,i);
        const o = e[t];
        switch (typeof o) {
        case "number":
            return new qA(this,e,t,i,r,s);
        case "boolean":
            return new GA(this,e,t);
        case "string":
            return new JA(this,e,t);
        case "function":
            return new kl(this,e,t)
        }
        console.error(`gui.add failed
	property:`, t, `
	object:`, e, `
	value:`, o)
    }
    addColor(e, t, i=1) {
        return new KA(this,e,t,i)
    }
    addFolder(e) {
        const t = new Au({
            parent: this,
            title: e
        });
        return this.root._closeFolders && t.close(),
        t
    }
    load(e, t=!0) {
        return e.controllers && this.controllers.forEach(i => {
            i instanceof kl || i._name in e.controllers && i.load(e.controllers[i._name])
        }
        ),
        t && e.folders && this.folders.forEach(i => {
            i._title in e.folders && i.load(e.folders[i._title])
        }
        ),
        this
    }
    save(e=!0) {
        const t = {
            controllers: {},
            folders: {}
        };
        return this.controllers.forEach(i => {
            if (!(i instanceof kl)) {
                if (i._name in t.controllers)
                    throw new Error(`Cannot save GUI with duplicate property "${i._name}"`);
                t.controllers[i._name] = i.save()
            }
        }
        ),
        e && this.folders.forEach(i => {
            if (i._title in t.folders)
                throw new Error(`Cannot save GUI with duplicate folder "${i._title}"`);
            t.folders[i._title] = i.save()
        }
        ),
        t
    }
    open(e=!0) {
        return this._setClosed(!e),
        this.$title.setAttribute("aria-expanded", !this._closed),
        this.domElement.classList.toggle("closed", this._closed),
        this
    }
    close() {
        return this.open(!1)
    }
    _setClosed(e) {
        this._closed !== e && (this._closed = e,
        this._callOnOpenClose(this))
    }
    show(e=!0) {
        return this._hidden = !e,
        this.domElement.style.display = this._hidden ? "none" : "",
        this
    }
    hide() {
        return this.show(!1)
    }
    openAnimated(e=!0) {
        return this._setClosed(!e),
        this.$title.setAttribute("aria-expanded", !this._closed),
        requestAnimationFrame( () => {
            const t = this.$children.clientHeight;
            this.$children.style.height = t + "px",
            this.domElement.classList.add("transition");
            const i = s => {
                s.target === this.$children && (this.$children.style.height = "",
                this.domElement.classList.remove("transition"),
                this.$children.removeEventListener("transitionend", i))
            }
            ;
            this.$children.addEventListener("transitionend", i);
            const r = e ? this.$children.scrollHeight : 0;
            this.domElement.classList.toggle("closed", !e),
            requestAnimationFrame( () => {
                this.$children.style.height = r + "px"
            }
            )
        }
        ),
        this
    }
    title(e) {
        return this._title = e,
        this.$title.innerHTML = e,
        this
    }
    reset(e=!0) {
        return (e ? this.controllersRecursive() : this.controllers).forEach(i => i.reset()),
        this
    }
    onChange(e) {
        return this._onChange = e,
        this
    }
    _callOnChange(e) {
        this.parent && this.parent._callOnChange(e),
        this._onChange !== void 0 && this._onChange.call(this, {
            object: e.object,
            property: e.property,
            value: e.getValue(),
            controller: e
        })
    }
    onFinishChange(e) {
        return this._onFinishChange = e,
        this
    }
    _callOnFinishChange(e) {
        this.parent && this.parent._callOnFinishChange(e),
        this._onFinishChange !== void 0 && this._onFinishChange.call(this, {
            object: e.object,
            property: e.property,
            value: e.getValue(),
            controller: e
        })
    }
    onOpenClose(e) {
        return this._onOpenClose = e,
        this
    }
    _callOnOpenClose(e) {
        this.parent && this.parent._callOnOpenClose(e),
        this._onOpenClose !== void 0 && this._onOpenClose.call(this, e)
    }
    destroy() {
        this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1),
        this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
        this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement),
        Array.from(this.children).forEach(e => e.destroy())
    }
    controllersRecursive() {
        let e = Array.from(this.controllers);
        return this.folders.forEach(t => {
            e = e.concat(t.controllersRecursive())
        }
        ),
        e
    }
    foldersRecursive() {
        let e = Array.from(this.folders);
        return this.folders.forEach(t => {
            e = e.concat(t.foldersRecursive())
        }
        ),
        e
    }
}
const eR = Au
  , da = "0.17"
  , pa = "0.0"
  , tR = `
#include <fog_pars_vertex>
uniform float scale;
uniform float uShift;

out vec3 projPosition;
vec3 hash( vec3 p ){
return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), 
dot(p,vec3(57.0,113.0,1.0)),
dot(p,vec3(113.0,1.0,57.0))))*43758.5453);

}
vec3 voronoi( const in vec3 x, float randomness) {
//vec3 voronoi( const in vec3 x, float randomness, float smoothness ) {
vec3 p = floor( x );
vec3 f = fract( x );
//float w = smoothness;

float id = 0.0;
vec2 res = vec2( 100.0 );
for( int k=-1; k<=1; k++ ) {
for( int j=-1; j<=1; j++ ) {
for( int i=-1; i<=1; i++ ) {
vec3 b = vec3( float(i), float(j), float(k) );
vec3 r = vec3( b ) - f + randomness * hash( p + b );
float d = dot( r, r );
//float h = smoothstep( -1.0, 1.0, (res.x-d)/w );
//float newD = mix( res.x, d, h ) - h*(1.0-h)*w/(1.0+3.0*w);

//if( newD < res.x ) {
if( d < res.x ) {
id = dot( p+b, vec3(1.0,57.0,113.0 ) );
//res = vec2( newD, res.x );         
res = vec2( d, res.x );         
}
//else if( newD < res.y ) {
else if( d < res.y ) {
res.y = d;
}
}
}
}

return vec3( sqrt( res ), abs(id) );
}

// Cellular noise ("Worley noise") in 3D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 mod289(vec3 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
}
vec3 mod7(vec3 x) {
return x - floor(x * (1.0 / 7.0)) * 7.0;
}
vec3 permute(vec3 x, float randomness) {
//return mod289((34.0 * x + 10.0) * x);
return mod289(randomness * (34.0 * x + 10.0) * x + (1.0 - randomness) * x);
}
// Cellular noise, returning F1 and F2 in a vec2.
// 3x3x3 search region for good F2 everywhere, but a lot
// slower than the 2x2x2 version.
// The code below is a bit scary even to its author,
// but it has at least half decent performance on a
// modern GPU. In any case, it beats any software
// implementation of Worley noise hands down.
//
// Adapted for randomness

vec2 cellular(vec3 P, float randomness) {
#define K 0.142857142857 // 1/7
#define Ko 0.428571428571 // 1/2-K/2
#define K2 0.020408163265306 // 1/(7*7)
#define Kz 0.166666666667 // 1/6
#define Kzo 0.416666666667 // 1/2-1/6*2
#define jitter 1.0 // smaller jitter gives more regular pattern

vec3 Pi = mod289(floor(P));
vec3 Pf = fract(P) - 0.5;

vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);

vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0), randomness);
vec3 p1 = permute(p + Pi.y - 1.0, randomness);
vec3 p2 = permute(p + Pi.y, randomness);
vec3 p3 = permute(p + Pi.y + 1.0, randomness);

vec3 p11 = permute(p1 + Pi.z - 1.0, randomness);
vec3 p12 = permute(p1 + Pi.z, randomness);
vec3 p13 = permute(p1 + Pi.z + 1.0, randomness);

vec3 p21 = permute(p2 + Pi.z - 1.0, randomness);
vec3 p22 = permute(p2 + Pi.z, randomness);
vec3 p23 = permute(p2 + Pi.z + 1.0, randomness);

vec3 p31 = permute(p3 + Pi.z - 1.0, randomness);
vec3 p32 = permute(p3 + Pi.z, randomness);
vec3 p33 = permute(p3 + Pi.z + 1.0, randomness);

vec3 ox11 = fract(p11*K) - Ko;
vec3 oy11 = mod7(floor(p11*K))*K - Ko;
vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed

vec3 ox12 = fract(p12*K) - Ko;
vec3 oy12 = mod7(floor(p12*K))*K - Ko;
vec3 oz12 = floor(p12*K2)*Kz - Kzo;

vec3 ox13 = fract(p13*K) - Ko;
vec3 oy13 = mod7(floor(p13*K))*K - Ko;
vec3 oz13 = floor(p13*K2)*Kz - Kzo;

vec3 ox21 = fract(p21*K) - Ko;
vec3 oy21 = mod7(floor(p21*K))*K - Ko;
vec3 oz21 = floor(p21*K2)*Kz - Kzo;

vec3 ox22 = fract(p22*K) - Ko;
vec3 oy22 = mod7(floor(p22*K))*K - Ko;
vec3 oz22 = floor(p22*K2)*Kz - Kzo;

vec3 ox23 = fract(p23*K) - Ko;
vec3 oy23 = mod7(floor(p23*K))*K - Ko;
vec3 oz23 = floor(p23*K2)*Kz - Kzo;

vec3 ox31 = fract(p31*K) - Ko;
vec3 oy31 = mod7(floor(p31*K))*K - Ko;
vec3 oz31 = floor(p31*K2)*Kz - Kzo;

vec3 ox32 = fract(p32*K) - Ko;
vec3 oy32 = mod7(floor(p32*K))*K - Ko;
vec3 oz32 = floor(p32*K2)*Kz - Kzo;

vec3 ox33 = fract(p33*K) - Ko;
vec3 oy33 = mod7(floor(p33*K))*K - Ko;
vec3 oz33 = floor(p33*K2)*Kz - Kzo;

vec3 dx11 = Pfx + jitter*ox11;
vec3 dy11 = Pfy.x + jitter*oy11;
vec3 dz11 = Pfz.x + jitter*oz11;

vec3 dx12 = Pfx + jitter*ox12;
vec3 dy12 = Pfy.x + jitter*oy12;
vec3 dz12 = Pfz.y + jitter*oz12;

vec3 dx13 = Pfx + jitter*ox13;
vec3 dy13 = Pfy.x + jitter*oy13;
vec3 dz13 = Pfz.z + jitter*oz13;

vec3 dx21 = Pfx + jitter*ox21;
vec3 dy21 = Pfy.y + jitter*oy21;
vec3 dz21 = Pfz.x + jitter*oz21;

vec3 dx22 = Pfx + jitter*ox22;
vec3 dy22 = Pfy.y + jitter*oy22;
vec3 dz22 = Pfz.y + jitter*oz22;

vec3 dx23 = Pfx + jitter*ox23;
vec3 dy23 = Pfy.y + jitter*oy23;
vec3 dz23 = Pfz.z + jitter*oz23;

vec3 dx31 = Pfx + jitter*ox31;
vec3 dy31 = Pfy.z + jitter*oy31;
vec3 dz31 = Pfz.x + jitter*oz31;

vec3 dx32 = Pfx + jitter*ox32;
vec3 dy32 = Pfy.z + jitter*oy32;
vec3 dz32 = Pfz.y + jitter*oz32;

vec3 dx33 = Pfx + jitter*ox33;
vec3 dy33 = Pfy.z + jitter*oy33;
vec3 dz33 = Pfz.z + jitter*oz33;

vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;
vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;
vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;
vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;
vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;
vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;
vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;
vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;
vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;

// Sort out the two smallest distances (F1, F2)
#if 0
// Cheat and sort out only F1
vec3 d1 = min(min(d11,d12), d13);
vec3 d2 = min(min(d21,d22), d23);
vec3 d3 = min(min(d31,d32), d33);
vec3 d = min(min(d1,d2), d3);
d.x = min(min(d.x,d.y),d.z);
return vec2(sqrt(d.x)); // F1 duplicated, no F2 computed
#else
// Do it right and sort out both F1 and F2
vec3 d1a = min(d11, d12);
d12 = max(d11, d12);
d11 = min(d1a, d13); // Smallest now not in d12 or d13
d13 = max(d1a, d13);
d12 = min(d12, d13); // 2nd smallest now not in d13
vec3 d2a = min(d21, d22);
d22 = max(d21, d22);
d21 = min(d2a, d23); // Smallest now not in d22 or d23
d23 = max(d2a, d23);
d22 = min(d22, d23); // 2nd smallest now not in d23
vec3 d3a = min(d31, d32);
d32 = max(d31, d32);
d31 = min(d3a, d33); // Smallest now not in d32 or d33
d33 = max(d3a, d33);
d32 = min(d32, d33); // 2nd smallest now not in d33
vec3 da = min(d11, d21);
d21 = max(d11, d21);
d11 = min(da, d31); // Smallest now in d11
d31 = max(da, d31); // 2nd smallest now not in d31
d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
d12 = min(d12, d21); // 2nd smallest now not in d21
d12 = min(d12, d22); // nor in d22
d12 = min(d12, d31); // nor in d31
d12 = min(d12, d32); // nor in d32
d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
d11.y = min(d11.y,d12.z); // Only two more to go
d11.y = min(d11.y,d11.z); // Done! (Phew!)
return sqrt(d11.xy); // F1, F2
#endif
}

void main() {
projPosition = position;
projPosition.y += uShift;
const float nt_rand_0 = 0.8;
float nt_scale_0 = scale;
vec3 vt_noise_0 = voronoi(projPosition * nt_scale_0, nt_rand_0);
float isRight = smoothstep(${pa}, ${da}, projPosition.x);
float isLeft = 1.0 - smoothstep(-${da}, -${pa}, projPosition.x);
float vt_out_0 = pow(vt_noise_0.x, 1.5) * 25.0 * (isRight + isLeft);
vec3 normNormal = normalize(normalMatrix * normal);
vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 )
    + vec4(vt_out_0 * normNormal, 0.0);
gl_Position = projectionMatrix * (modelViewMatrix * vec4( position, 1.0 )
+ vec4(vt_out_0 * normNormal, 1.0));

#include <fog_vertex>
}
`
  , nR = `
#include <fog_pars_fragment>
#define COL_RAMP_NUM_PICKER_0 6

// Uniforms
uniform float uShift;
uniform float scale;

// Attributes 

// Varyings

// Ins 
in vec3 projPosition;

// Outs 

// Functions
vec3 hash( vec3 p ){
  return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), 
                         dot(p,vec3(57.0,113.0,1.0)),
                         dot(p,vec3(113.0,1.0,57.0))))*43758.5453);

}
vec3 voronoi( const in vec3 x, float randomness) {
      //vec3 voronoi( const in vec3 x, float randomness, float smoothness ) {
    vec3 p = floor( x );
    vec3 f = fract( x );
    //float w = smoothness;

    float id = 0.0;
    vec2 res = vec2( 100.0 );
    for( int k=-1; k<=1; k++ ) {
        for( int j=-1; j<=1; j++ ) {
            for( int i=-1; i<=1; i++ ) {
                vec3 b = vec3( float(i), float(j), float(k) );
                vec3 r = vec3( b ) - f + randomness * hash( p + b );
                float d = dot( r, r );
                //float h = smoothstep( -1.0, 1.0, (res.x-d)/w );
                //float newD = mix( res.x, d, h ) - h*(1.0-h)*w/(1.0+3.0*w);

                //if( newD < res.x ) {
                if( d < res.x ) {
                    id = dot( p+b, vec3(1.0,57.0,113.0 ) );
                    //res = vec2( newD, res.x );         
                    res = vec2( d, res.x );         
                }
                //else if( newD < res.y ) {
                else if( d < res.y ) {
                    res.y = d;
                }
            }
        }
    }

    return vec3( sqrt( res ), abs(id) );
}

// Cellular noise ("Worley noise") in 3D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 mod289(vec3 x) {
return x - floor(x * (1.0 / 289.0)) * 289.0;
}
vec3 mod7(vec3 x) {
return x - floor(x * (1.0 / 7.0)) * 7.0;
}
vec3 permute(vec3 x, float randomness) {
//return mod289((34.0 * x + 10.0) * x);
  return mod289(randomness * (34.0 * x + 10.0) * x + (1.0 - randomness) * x);
}
// Cellular noise, returning F1 and F2 in a vec2.
// 3x3x3 search region for good F2 everywhere, but a lot
// slower than the 2x2x2 version.
// The code below is a bit scary even to its author,
// but it has at least half decent performance on a
// modern GPU. In any case, it beats any software
// implementation of Worley noise hands down.
//
// Adapted for randomness

vec2 cellular(vec3 P, float randomness) {
#define K 0.142857142857 // 1/7
#define Ko 0.428571428571 // 1/2-K/2
#define K2 0.020408163265306 // 1/(7*7)
#define Kz 0.166666666667 // 1/6
#define Kzo 0.416666666667 // 1/2-1/6*2
#define jitter 1.0 // smaller jitter gives more regular pattern

vec3 Pi = mod289(floor(P));
vec3 Pf = fract(P) - 0.5;

vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);

vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0), randomness);
vec3 p1 = permute(p + Pi.y - 1.0, randomness);
vec3 p2 = permute(p + Pi.y, randomness);
vec3 p3 = permute(p + Pi.y + 1.0, randomness);

vec3 p11 = permute(p1 + Pi.z - 1.0, randomness);
vec3 p12 = permute(p1 + Pi.z, randomness);
vec3 p13 = permute(p1 + Pi.z + 1.0, randomness);

vec3 p21 = permute(p2 + Pi.z - 1.0, randomness);
vec3 p22 = permute(p2 + Pi.z, randomness);
vec3 p23 = permute(p2 + Pi.z + 1.0, randomness);

vec3 p31 = permute(p3 + Pi.z - 1.0, randomness);
vec3 p32 = permute(p3 + Pi.z, randomness);
vec3 p33 = permute(p3 + Pi.z + 1.0, randomness);

vec3 ox11 = fract(p11*K) - Ko;
vec3 oy11 = mod7(floor(p11*K))*K - Ko;
vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed

vec3 ox12 = fract(p12*K) - Ko;
vec3 oy12 = mod7(floor(p12*K))*K - Ko;
vec3 oz12 = floor(p12*K2)*Kz - Kzo;

vec3 ox13 = fract(p13*K) - Ko;
vec3 oy13 = mod7(floor(p13*K))*K - Ko;
vec3 oz13 = floor(p13*K2)*Kz - Kzo;

vec3 ox21 = fract(p21*K) - Ko;
vec3 oy21 = mod7(floor(p21*K))*K - Ko;
vec3 oz21 = floor(p21*K2)*Kz - Kzo;

vec3 ox22 = fract(p22*K) - Ko;
vec3 oy22 = mod7(floor(p22*K))*K - Ko;
vec3 oz22 = floor(p22*K2)*Kz - Kzo;

vec3 ox23 = fract(p23*K) - Ko;
vec3 oy23 = mod7(floor(p23*K))*K - Ko;
vec3 oz23 = floor(p23*K2)*Kz - Kzo;

vec3 ox31 = fract(p31*K) - Ko;
vec3 oy31 = mod7(floor(p31*K))*K - Ko;
vec3 oz31 = floor(p31*K2)*Kz - Kzo;

vec3 ox32 = fract(p32*K) - Ko;
vec3 oy32 = mod7(floor(p32*K))*K - Ko;
vec3 oz32 = floor(p32*K2)*Kz - Kzo;

vec3 ox33 = fract(p33*K) - Ko;
vec3 oy33 = mod7(floor(p33*K))*K - Ko;
vec3 oz33 = floor(p33*K2)*Kz - Kzo;

vec3 dx11 = Pfx + jitter*ox11;
vec3 dy11 = Pfy.x + jitter*oy11;
vec3 dz11 = Pfz.x + jitter*oz11;

vec3 dx12 = Pfx + jitter*ox12;
vec3 dy12 = Pfy.x + jitter*oy12;
vec3 dz12 = Pfz.y + jitter*oz12;

vec3 dx13 = Pfx + jitter*ox13;
vec3 dy13 = Pfy.x + jitter*oy13;
vec3 dz13 = Pfz.z + jitter*oz13;

vec3 dx21 = Pfx + jitter*ox21;
vec3 dy21 = Pfy.y + jitter*oy21;
vec3 dz21 = Pfz.x + jitter*oz21;

vec3 dx22 = Pfx + jitter*ox22;
vec3 dy22 = Pfy.y + jitter*oy22;
vec3 dz22 = Pfz.y + jitter*oz22;

vec3 dx23 = Pfx + jitter*ox23;
vec3 dy23 = Pfy.y + jitter*oy23;
vec3 dz23 = Pfz.z + jitter*oz23;

vec3 dx31 = Pfx + jitter*ox31;
vec3 dy31 = Pfy.z + jitter*oy31;
vec3 dz31 = Pfz.x + jitter*oz31;

vec3 dx32 = Pfx + jitter*ox32;
vec3 dy32 = Pfy.z + jitter*oy32;
vec3 dz32 = Pfz.y + jitter*oz32;

vec3 dx33 = Pfx + jitter*ox33;
vec3 dy33 = Pfy.z + jitter*oy33;
vec3 dz33 = Pfz.z + jitter*oz33;

vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;
vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;
vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;
vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;
vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;
vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;
vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;
vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;
vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;

// Sort out the two smallest distances (F1, F2)
#if 0
// Cheat and sort out only F1
vec3 d1 = min(min(d11,d12), d13);
vec3 d2 = min(min(d21,d22), d23);
vec3 d3 = min(min(d31,d32), d33);
vec3 d = min(min(d1,d2), d3);
d.x = min(min(d.x,d.y),d.z);
return vec2(sqrt(d.x)); // F1 duplicated, no F2 computed
#else
// Do it right and sort out both F1 and F2
vec3 d1a = min(d11, d12);
d12 = max(d11, d12);
d11 = min(d1a, d13); // Smallest now not in d12 or d13
d13 = max(d1a, d13);
d12 = min(d12, d13); // 2nd smallest now not in d13
vec3 d2a = min(d21, d22);
d22 = max(d21, d22);
d21 = min(d2a, d23); // Smallest now not in d22 or d23
d23 = max(d2a, d23);
d22 = min(d22, d23); // 2nd smallest now not in d23
vec3 d3a = min(d31, d32);
d32 = max(d31, d32);
d31 = min(d3a, d33); // Smallest now not in d32 or d33
d33 = max(d3a, d33);
d32 = min(d32, d33); // 2nd smallest now not in d33
vec3 da = min(d11, d21);
d21 = max(d11, d21);
d11 = min(da, d31); // Smallest now in d11
d31 = max(da, d31); // 2nd smallest now not in d31
d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
d12 = min(d12, d21); // 2nd smallest now not in d21
d12 = min(d12, d22); // nor in d22
d12 = min(d12, d31); // nor in d31
d12 = min(d12, d32); // nor in d32
d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
d11.y = min(d11.y,d12.z); // Only two more to go
d11.y = min(d11.y,d11.z); // Done! (Phew!)
return sqrt(d11.xy); // F1, F2
#endif
}
vec4 getGradientColorLinear(vec4[COL_RAMP_NUM_PICKER_0] colors, float[COL_RAMP_NUM_PICKER_0] positions, float fac) {
      vec4 color = vec4(0);
      for(int i = 0; i < COL_RAMP_NUM_PICKER_0 - 1; i++) {
        float dist = positions[i + 1] - positions[i];
        color += step(positions[i], fac) * (1. - step(positions[i + 1], fac)) *
          mix(colors[i], colors[i + 1], (fac - positions[i]) / dist);
      }
      color.w = 1.0;
      return color;
    }


// Main
void main() {
  const float nt_rand_0 = 0.8;
float nt_scale_0 = scale;
vec3 vt_noise_0 = voronoi(projPosition * nt_scale_0, nt_rand_0);
float isRight = smoothstep(${pa}, ${da}, projPosition.x);
float isLeft = 1.0 - smoothstep(-${da}, -${pa}, projPosition.x);
float vt_out_0 = clamp(pow(vt_noise_0.x, 1.5) * (isRight + isLeft), 0.0, 0.999999);
vec4[COL_RAMP_NUM_PICKER_0] col_ramp_picker_color_0;
col_ramp_picker_color_0[0] = vec4(0.0, 0.0, 0.1, 1.0);
col_ramp_picker_color_0[1] = vec4(0.06132033583333325, 0.04408150000000001, 0.21791850000000001, 1.0);
col_ramp_picker_color_0[2] = vec4(0.08248812, 0.2796435694, 0.5103118799999999, 1.0);
col_ramp_picker_color_0[3] = vec4(0.56864872, 0.67944371896, 0.8085512800000001, 1.0);
col_ramp_picker_color_0[4] = vec4(0.9, 0.9, 0.9, 1.0);
col_ramp_picker_color_0[5] = vec4(1.0, 1.0, 1.0, 1.0);

float[COL_RAMP_NUM_PICKER_0] col_ramp_picker_pos_0;
col_ramp_picker_pos_0[0] = 0.0;
col_ramp_picker_pos_0[1] = 0.0812266370985243055;
col_ramp_picker_pos_0[2] = 0.24998711480034722;
col_ramp_picker_pos_0[3] = 0.7349310980902778;
col_ramp_picker_pos_0[4] = 0.8040085856119791;
col_ramp_picker_pos_0[5] = 1.0;

vec4 col_ramp_color_0 = getGradientColorLinear(col_ramp_picker_color_0, col_ramp_picker_pos_0, vt_out_0);
vec4 col_ramp_out_0 = col_ramp_color_0;
gl_FragColor = col_ramp_out_0;
////float hasNegW = 1.0 - step(0.0, gl_FragColor.w);
////gl_FragColor = hasNegW * vec4(1.0) + (1.0 - hasNegW) * gl_FragColor;
//gl_FragColor = vec4(step(1.0, vt_out_0), 0.0, 0.0, 1.0);
#include <fog_fragment>

}
`
  , iR = `
#include <fog_pars_vertex>
uniform float uSize;
uniform float uTime;
uniform float uLowBound;
uniform float uHighBound;
uniform float uLeftBound;
uniform float uRightBound;
uniform float uShiftX;

attribute float aScale;

void main() {
  float range = abs(uLowBound - uHighBound);
  float leftRightRange = abs(uRightBound - uLeftBound);
  vec3 startPosition = position;

  startPosition.y -= 1.5 * uTime;

  float distToTop = uHighBound - startPosition.y;
  float isBelow = step(range, distToTop);

  startPosition.y = isBelow * (-mod(distToTop, range) + uHighBound) + 
                    (1.0 - isBelow) * startPosition.y;

  startPosition.x += uShiftX;
  //startPosition.x += smoothstep(0.0, 0.4, (uHighBound - startPosition.y)/ range) * uShiftX;
  //startPosition.x += mod(uShiftX, leftRightRange) * (uHighBound - startPosition.y) / range * 0.5;

  float distToRight = abs(uRightBound - startPosition.x);
  float distToLeft = abs(uLeftBound - startPosition.x);
  float isTooFarLeft = 1.0 - step(uLeftBound, startPosition.x);
  float isTooFarRight = step(uRightBound, startPosition.x);

  startPosition.x = isTooFarLeft * (-mod(distToRight, leftRightRange) + uRightBound) + 
                    isTooFarRight * (mod(distToLeft, leftRightRange) + uLeftBound) +
                    (1.0 - (isTooFarRight + isTooFarLeft)) * startPosition.x;

  vec4 modelPosition = modelMatrix * vec4(startPosition, 1.0);
  vec4 viewPosition = viewMatrix * modelPosition;
  vec4 mvPosition = viewPosition;
  vec4 projPosition = projectionMatrix * viewPosition;
  #include <fog_vertex>
  gl_Position = projPosition;
  gl_PointSize = uSize * aScale;
  gl_PointSize *= (1.0 / - viewPosition.z);
}
`
  , rR = `
#include <fog_pars_fragment>
void main() {
  float strength = 1.0 - distance(gl_PointCoord, vec2(0.5));
  strength = pow(strength, 5.0);
  float alpha = smoothstep(0.5, 0.7, strength);
  gl_FragColor = vec4(vec3(strength), alpha);
  gl_FragColor = vec4(mix(vec3(0.0), vec3(0.7, 0.7, 1.0), strength), alpha);
  #include <fog_fragment>
}
`;
let fr = "";

const iL = `
#include <fog_pars_vertex>
uniform float uSize;
uniform float uTime;
uniform float uLowBound;
uniform float uHighBound;
uniform float uLeftBound;
uniform float uRightBound;
uniform float uShiftX;

attribute float aScale;
attribute float aSpeed;
attribute float aRotSpeed;
attribute float aRotOffset;
attribute float aPhase;

varying float vAngle;
varying vec3 vColor;

void main() {
  float range = abs(uLowBound - uHighBound);
  float leftRightRange = abs(uRightBound - uLeftBound);
  vec3 startPosition = position;

  startPosition.y -= aSpeed * uTime;

  float distToTop = uHighBound - startPosition.y;
  float isBelow = step(range, distToTop);

  startPosition.y = isBelow * (-mod(distToTop, range) + uHighBound) +
                    (1.0 - isBelow) * startPosition.y;

  startPosition.x += uShiftX + sin(uTime * 0.6 + aPhase) * 0.35;
  startPosition.z += cos(uTime * 0.45 + aPhase) * 0.22;

  float distToRight = abs(uRightBound - startPosition.x);
  float distToLeft = abs(uLeftBound - startPosition.x);
  float isTooFarLeft = 1.0 - step(uLeftBound, startPosition.x);
  float isTooFarRight = step(uRightBound, startPosition.x);

  startPosition.x = isTooFarLeft * (-mod(distToRight, leftRightRange) + uRightBound) +
                    isTooFarRight * (mod(distToLeft, leftRightRange) + uLeftBound) +
                    (1.0 - (isTooFarRight + isTooFarLeft)) * startPosition.x;

  vec4 modelPosition = modelMatrix * vec4(startPosition, 1.0);
  vec4 viewPosition = viewMatrix * modelPosition;
  vec4 mvPosition = viewPosition;
  vec4 projPosition = projectionMatrix * viewPosition;

  #include <fog_vertex>

  gl_Position = projPosition;
  gl_PointSize = uSize * aScale;
  gl_PointSize *= (1.0 / -viewPosition.z);

  vAngle = aRotOffset + aRotSpeed * uTime;
  vColor = color;
}
`;
const rL = `
#include <fog_pars_fragment>
varying float vAngle;
varying vec3 vColor;

void main() {
  vec2 uv = gl_PointCoord - vec2(0.5);

  float s = sin(vAngle);
  float c = cos(vAngle);
  vec2 p = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);

  float body = length(p / vec2(0.28, 0.42)) - 1.0;
  float tip  = length((p - vec2(0.0, 0.16)) / vec2(0.18, 0.30)) - 1.0;
  float d = min(body, tip);

  float notch = length((p + vec2(0.0, 0.42)) / vec2(0.18, 0.12)) - 1.0;
  d = max(d, -notch);

  float alpha = smoothstep(0.03, -0.03, d);

  float vein = smoothstep(0.03, 0.0, abs(p.x) * 3.0) * smoothstep(-0.40, -0.05, p.y);
  vec3 col = vColor + vein * 0.06;

  gl_FragColor = vec4(col, alpha);
  #include <fog_fragment>
}
`;

new H(0,0,1);
const Ld = 90
  , sR = 80
  , As = 85
  , Dd = As + 15
  , Uc = -20
  , oR = -20
  , pg = 10
  , aR = 15
  , Id = 20
  , Vo = 6
  , Wo = As - 20;
let ui = Wo + pg
  , _r = ui - Vo * 4 - 5;
const Gl = _r - 20
  , Vl = -100
  , lR = Uc - 8
  , cR = 3
  , uR = 3
  , hR = 8
  , fR = 17
  , as = .08
  , ls = 3.5
  , Bo = 5.1
  , dr = 8;
class ThreeScene {
    constructor(e, t) {
        Ye(this, "canvas");
        Ye(this, "scrollElement");
        Ye(this, "isDemo");
        Ye(this, "gui");
        Ye(this, "stats");
        Ye(this, "sizes");
        Ye(this, "scene");
        Ye(this, "camera");
        Ye(this, "cameraGroup");
        Ye(this, "controls");
        Ye(this, "renderer");
        Ye(this, "clock", new CA);
        Ye(this, "plane");
        Ye(this, "mousePos", {
            x: 0,
            y: 0
        });
        Ye(this, "textDownPosition", 3);
        Ye(this, "textUpPosition", 8);
        Ye(this, "textZPosition", As - 5);
        Ye(this, "textZMobilePosition", Dd - 12);
        Ye(this, "currentPage", 0);
        Ye(this, "maxPages", 0);
        Ye(this, "cameraStartPos", As);
        Ye(this, "cameraEndPos", Uc);
        this.isDemo = t,
        fr = Aa().app.baseURL,
        this.isDemo && (this.gui = new eR,
        this.gui.close(),
        this.stats = new kA,
        this.stats.showPanel(0),
        document.body.appendChild(this.stats.dom)),
        this.canvas = e,
        this.scrollElement = document.querySelector("#__nuxt") || document.querySelector("#scripts") || document.documentElement || document.body,
        this.sizes = {
            width: innerWidth,
            height: innerHeight
        };
        const i = new Xe(657700);
        this.scene = new O1,
        this.scene.background = i,
        this.scene.fog = new Mu(i,25,260),
        this.cameraGroup = new Gt,
        this.camera = new sn(Ld,this.sizes.width / this.sizes.height,.1,300),
        this.camera.rotation.x = -.15,
        this.cameraGroup.add(this.camera),
        //camera height
        this.cameraGroup.position.y = 13,
        this.cameraGroup.position.z = this.cameraStartPos,
        this.isDemo && (this.gui.add(this.camera, "fov", 10, 150, 1).onChange( () => {
            this.camera.updateProjectionMatrix()
        }
        ),
        this.gui.add(this.cameraGroup.position, "z", 70, 100, 1)),
        this.scene.add(this.cameraGroup),
        this.renderer = new tg({
            antialias: !0
        }),
        this.renderer.setSize(this.sizes.width, this.sizes.height),
        this.renderer.setPixelRatio(window.devicePixelRatio),
        e.appendChild(this.renderer.domElement),
        0,
        this.addObjects(),
        window.addEventListener("resize", () => this.updateSizes()),
        window.addEventListener("mousemove", s => this.updateMousePosition(s)),
        window.addEventListener("deviceorientation", () => this.updateSizes(), !0),
        this.scrollElement && this.scrollElement.addEventListener("scroll", () => this.updateScroll()),
        this.updateSizes(),
        this.updateScroll(),
        this.animate()
    }
    animate() {
        requestAnimationFrame(() => this.animate());

        const e = this.clock.getElapsedTime();
        this.clock.getDelta();

        if (this.leafFall) {
            this.leafFall.material.uniforms.uTime.value = e;
            this.leafFall.material.uniforms.uShiftX.value -= this.mousePos.x * 0.04;
        }


        if (this.sizes.width >= 900) {
            this.cameraGroup.position.x +=
            (this.mousePos.x * 3 - this.cameraGroup.position.x) * 0.1;

            this.cameraGroup.position.y +=
            (this.mousePos.y * 3 + 13 - this.cameraGroup.position.y) * 0.1;
        } else {
            this.cameraGroup.position.x = 0;
            this.cameraGroup.position.y = 13;
        }

        let t = 0;
        if (this.currentPage < ls) {
            t =
            this.cameraStartPos +
            (ui - this.cameraStartPos) *
                Math.pow(Math.max(this.currentPage, 0) / ls, 2);
        } else if (this.currentPage < Bo) {
            t = ui + (_r - ui) * (Math.max(this.currentPage - ls, 0) / (Bo - ls));
        } else if (this.currentPage < dr) {
            t = _r + (Gl - _r) * (Math.max(this.currentPage - Bo, 0) / (dr - Bo));
        } else {
            t =
            Gl +
            (this.cameraEndPos - Gl) *
                (Math.max(this.currentPage - dr, 0) / (this.maxPages - dr));
        }

        this.cameraGroup.position.z += (t - this.cameraGroup.position.z) * as;
        this.renderer.render(this.scene, this.camera);
        if (this.isDemo) this.stats.update();
    }
    updateScroll() {
	        this.currentPage = (this.scrollElement ? this.scrollElement.scrollTop : (window.scrollY || 0)) / this.sizes.height;
	        this.maxPages = ((this.scrollElement ? this.scrollElement.scrollHeight : document.body.scrollHeight) - innerHeight) / this.sizes.height;
	    }
    updateSizes() {
        this.sizes.width = innerWidth,
        this.sizes.height = innerHeight,
        this.camera.aspect = this.sizes.width / this.sizes.height,
        this.sizes.width > 600 ? (this.camera.fov = Ld,
        this.cameraStartPos = As,
        this.cameraEndPos = Uc,
        this.textDownPosition = cR,
        this.textUpPosition = hR,
        ui = Wo + pg,
        _r = ui - Vo * 4 - 5) : (this.camera.fov = sR,
        this.cameraStartPos = Dd,
        this.cameraEndPos = oR,
        this.textDownPosition = uR,
        this.textUpPosition = fR,
        ui = Wo + aR,
        _r = ui - Vo * 4 - 5),
        this.camera.updateProjectionMatrix(),
        this.renderer.setSize(this.sizes.width, this.sizes.height),
        this.hill && (this.hill.position.z = _r,
        this.hill.position.y = 8)
    }
    updateMousePosition(e) {
        this.mousePos.x = (e.clientX / this.sizes.width - .5) * 2,
        this.mousePos.y = (-e.clientY / this.sizes.height + .5) * 2
    }
    addObjects() {
        const e = new AA(16777215,20);
        e.position.set(1, 4, 5),
        this.scene.add(e),
        this.scene.add(e.target),
        e.target.position.set(0, 0, 0);
        const t = new RA(148);
        this.scene.add(t);
        // Low-poly ground + pine forest
        const l = new Td({
            color: 2841910
        })
          , c = new Fa(1200,1200,1,1)
          , u = new Vt(c,l);
        u.rotation.x = -Math.PI / 2,
        u.position.set(0, -10, 0),
        this.scene.add(u),
        this.ground = u,
        this.addDirtPath(),
        this.addForest(),
        this.addGrassPatches();  
        this.leafFall = this.addLeafFall()
    }

    addHill() {
        const e = new Bl().load(fr + "images/textures/18.png")
          , t = new xA({
            fog: !0,
            matcap: e,
            side: Wt
        })
          , i = new Tu(18,32,32)
          , r = new Vt(i,t);
        r.position.set(0, 8, _r),
        this.scene.add(r),
        this.hill = r
    }
    

addDirtPath() {
        // Random each page reload.
        const rand = Math.random;

    // Path spans the camera travel range.
    const zStart = this.cameraStartPos + 10;   // slightly in front of camera start
    const zEnd = this.cameraEndPos - 20;       // slightly past camera end
    const segments = 90;

    // Base path params (low poly, wide enough to read from above).
    const baseWidth = 1.5;
    const bermWidth = 2.4;     // extra width on each side
    const bermHeight = 0.65;   // berm raise amount

    let x = 0;
    const maxX = 6;

    // Keep above the ground plane to avoid z-fighting.
    const yBase = -9.88;

    // Store centerline so we can scatter rocks deterministically along the same path.
    const centers = [];
    const widths = [];

    const positions = [];
    const uvs = [];
    const indices = [];

    for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const z = zStart + (zEnd - zStart) * t;

        // Smoothed random walk (non-periodic and gentle). Static per reload (seeded).
        x += (rand() - 0.5) * 1.6;
        x *= 0.88;
        x = Math.max(-maxX, Math.min(maxX, x));

        const w = baseWidth + (rand() - 0.5) * 1.5;

        centers.push(x);
        widths.push(w);

        const leftInner = x - w * 0.5;
        const rightInner = x + w * 0.5;
        const leftOuter = leftInner - bermWidth;
        const rightOuter = rightInner + bermWidth;

        // Add tiny height variation so it's not perfectly flat.
        const yCenter = yBase + (rand() - 0.5) * 0.04;
        const yBerm = yBase + bermHeight + (rand() - 0.5) * 0.15;

        // 4 verts per segment: left berm, left edge, right edge, right berm
        positions.push(
            leftOuter, yBerm, z,
            leftInner, yCenter, z,
            rightInner, yCenter, z,
            rightOuter, yBerm, z
        );

        // Simple UVs (not really used, but harmless)
        uvs.push(0, t, 0.25, t, 0.75, t, 1, t);

        if (i < segments) {
            const a = 4 * i;
            const b = a + 4;

            // left slope quad (a0-a1-b1-b0)
            indices.push(a, a + 1, b + 1, a, b + 1, b);

            // center quad (a1-a2-b2-b1)
            indices.push(a + 1, a + 2, b + 2, a + 1, b + 2, b + 1);

            // right slope quad (a2-a3-b3-b2)
            indices.push(a + 2, a + 3, b + 3, a + 2, b + 3, b + 2);
        }
    }
    //avoid area for grass + things
    this.pathProfile = { zStart, zEnd, segments, centers, widths };

    const geo = new Zt;
    geo.setIndex(indices);
    geo.setAttribute("position", new Tt(positions,3));
    geo.setAttribute("uv", new Tt(uvs,2));
    geo.computeVertexNormals();

    const mat = new Td({
        color: 6968368
    });

    const mesh = new Vt(geo, mat);
    mesh.name = "dirtPath";
    mesh.renderOrder = 0;

    this.scene.add(mesh);
    this.dirtPath = mesh;

    // --- Rocks: deterministic scatter along and near the berms (low poly) ---
        const randRock = Math.random;
    const rocks = new Gt;
    rocks.name = "rocks";

    const rockGeo = new Tu(0.22, 5, 4); // low-poly "boulder"
    const rockMat = new Td({ color: 5987163 }); // muted gray-brown

    const rockCount = 750;

    for (let k = 0; k < rockCount; k++) {
        const t = randRock();
        const z = zStart + (zEnd - zStart) * t;

        // interpolate center + width
        let p = t * segments;
        let idx = Math.floor(p);
        if (idx >= segments) idx = segments - 1;
        const a = p - idx;

        const cx = centers[idx] * (1 - a) + centers[idx + 1] * a;
        const w = widths[idx] * (1 - a) + widths[idx + 1] * a;

        // Bias rocks toward the berm edges.
        const edgeBias = randRock() < 0.75;

        // no-rock zone = inside the path (plus a little safety margin)
        const clear = (w * 0.5) + 0.45;   // tweak 0.35 to taste (bigger = wider clear lane)

        let rx;
        const side = randRock() < 0.5 ? -1 : 1;

        if (edgeBias) {
        // Mostly on berms/outside
        rx = cx + side * (clear + 0.9 + randRock() * 3.5) + (randRock() - 0.5) * 0.6;
        } else {
        // Still outside the path (just less berm-biased)
        rx = cx + side * (clear + randRock() * 4.5);
        }

        // Height: mostly on/near ground; slightly higher near berms
        const ry = edgeBias ? (-9.82 + randRock() * 0.18) : (-9.92 + randRock() * 0.12);

        const rMesh = new Vt(rockGeo, rockMat);
        rMesh.position.set(rx, ry, z + (randRock() - 0.5) * 1.2);
        rMesh.rotation.set(
            randRock() * Math.PI,
            randRock() * Math.PI,
            randRock() * Math.PI
        );

        // Non-uniform scale for irregular low-poly rocks
        const s = 0.18 + randRock() * 0.94;
        rMesh.scale.set(
            s * (0.7 + randRock() * 0.7),
            s * (0.6 + randRock() * 0.9),
            s * (0.7 + randRock() * 0.7)
        );

        rocks.add(rMesh);
    }

    this.scene.add(rocks);
    this.rocksGroup = rocks;
}
    addForest() {
        const e = new Gt;
        e.name = "forest";

        // ---- Tree color tuning (percentages; will be normalized automatically) ----
        // Tweak these to control how many trees of each type appear.
        const PCT_GREEN  = 0.65;
        const PCT_ORANGE = 0.20;
        const PCT_RED    = 0.05;
        const PCT_BROWN  = 0.10;

        // Leaf colors (low-poly, slightly muted).
        const COLOR_GREEN  = 0x1b5e20; // dark evergreen
        const COLOR_ORANGE = 0x8a4917;
        const COLOR_RED    = 0x6e1b17;
        const COLOR_BROWN  = 0x4a2b13;
        this.treeColorTuning = { PCT_GREEN, PCT_ORANGE, PCT_RED, PCT_BROWN, COLOR_GREEN, COLOR_ORANGE, COLOR_RED, COLOR_BROWN };
        // Random each page reload.
        const rand = Math.random;

        const t = new Td({ color: 7031339 }); // trunk (brown)
        const leafMatGreen  = new Td({ color: COLOR_GREEN  });
        const leafMatOrange = new Td({ color: COLOR_ORANGE });
        const leafMatRed    = new Td({ color: COLOR_RED    });
        const leafMatBrown  = new Td({ color: COLOR_BROWN  });

        const totalPct = PCT_GREEN + PCT_ORANGE + PCT_RED + PCT_BROWN;
        const pickLeafMat = () => {
            const r0 = rand() * totalPct;
            if (r0 < PCT_GREEN) return leafMatGreen;
            if (r0 < PCT_GREEN + PCT_ORANGE) return leafMatOrange;
            if (r0 < PCT_GREEN + PCT_ORANGE + PCT_RED) return leafMatRed;
            return leafMatBrown;
        };

        // Tree shape (scaled up).
        const trunkH = 7
          , leavesH = 16
          , trunkGeo = new bu([new xe(.65,0), new xe(.45,trunkH)],6)
          , leavesGeo = new bu([new xe(3.8,0), new xe(0,leavesH)],7);

        // ---- Forest extents ----
        // Widen the forest left/right while keeping the SAME density as before.
        const u = 300;                // half-length (Z)
        const c = 420;                // half-width  (X)  (was 120)
        const BASE_DENSITY = 900 / (240 * 600); // original: 900 trees over (2*120) x (2*300)
        const l = Math.floor(BASE_DENSITY * (2 * c) * (2 * u));

        for (let h = 0; h < l; h++) {
            const f = new Gt
              , p = new Vt(trunkGeo, t)
              , g = new Vt(leavesGeo, pickLeafMat());

            g.position.y = trunkH;
            f.add(p, g);

            let x = (rand() - .5) * 2 * c
              , m = (rand() - .5) * 2 * u;

            // Keep a clear corridor for the path.
            Math.abs(x) < 12 && (x += x < 0 ? -12 : 12);

            f.position.set(x, -10, m);
            f.rotation.y = rand() * Math.PI * 2;

            const d = 1 + rand() * .9;
            f.scale.set(d, d, d);

            e.add(f);
        }

        this.scene.add(e);
        this.forest = e;
    }

    addGrassPatches() {
        // If re-creating the scene, remove old grass
        if (this.grassPatches) {
            this.scene.remove(this.grassPatches);
            this.grassPatches.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose?.();
                if (obj.material) obj.material.dispose?.();
            });
            this.grassPatches = null;
        }

        const group = new Gt();
        group.name = "grassPatches";

        // --- Tunables ---
        const PATCH_COUNT = 1000;
        const X_HALF = 420;
        const Z_HALF = 300;
        const yGround = -10;
        const pathMargin = 1.2;

        // --- Slimmer, less-wide blades (narrower radius + slimmer x/z scaling) ---
        const tuftH = 1.45;
        const tuftR = 0.24; //  was wider; smaller = thinner blades

        const tuftGeo = new bu(
            [
                new xe(0.00, 0.00),
                new xe(tuftR * 0.90, 0.02),
                new xe(tuftR * 1.00, tuftH * 0.22),
                new xe(tuftR * 0.45, tuftH * 0.62),
                new xe(tuftR * 0.16, tuftH * 0.90),
                new xe(0.00, tuftH)
            ],
            10 // keep it reasonably more poly
        );

        const grassMat = new Td({
            color: 0x2f7d32,
            flatShading: !0
        });

        const rand = Math.random;

        // Helper: test whether a point is inside the dirt path corridor at this z
        const isOnPath = (x, z) => {
            const prof = this.pathProfile;
            if (!prof) return false;

            const t = (z - prof.zStart) / (prof.zEnd - prof.zStart);
            if (t < 0 || t > 1) return false;

            const p = t * prof.segments;
            const idx = Math.min(prof.segments - 1, Math.max(0, Math.floor(p)));
            const a = p - idx;

            const cx = prof.centers[idx] * (1 - a) + prof.centers[idx + 1] * a;
            const w  = prof.widths[idx]  * (1 - a) + prof.widths[idx + 1]  * a;

            return Math.abs(x - cx) < (w * 0.5 + pathMargin);
        };

        for (let i = 0; i < PATCH_COUNT; i++) {
            let x = 0, z = 0, ok = false;

            for (let tries = 0; tries < 10; tries++) {
                x = (rand() - 0.5) * 2 * X_HALF;
                z = (rand() - 0.5) * 2 * Z_HALF;
                if (!isOnPath(x, z)) { ok = true; break; }
            }
            if (!ok) continue;

            const patch = new Gt();

            const tuftCount = 4 + Math.floor(rand() * 5); // 4..8
            for (let k = 0; k < tuftCount; k++) {
                const m = new Vt(tuftGeo, grassMat);

                const r = 0.22 + rand() * 0.80;
                const ang = rand() * Math.PI * 2;
                m.position.set(Math.cos(ang) * r, 0, Math.sin(ang) * r);

                m.rotation.y = rand() * Math.PI * 2;

                // Make blades noticeably less wide: shrink X/Z relative to Y
                const s = 0.55 + rand() * 0.95;
                const xz = 0.42 + rand() * 0.35;     //  slimmer width band
                const yy = 0.95 + rand() * 0.85;     // keep height healthy
                m.scale.set(s * xz, s * yy, s * xz);

                patch.add(m);
            }

            patch.position.set(x, yGround, z);
            patch.rotation.y = rand() * Math.PI * 2;

            group.add(patch);
        }

        this.scene.add(group);
        this.grassPatches = group;
    }

    addLeafFall() {
        const tune = this.treeColorTuning || {
            PCT_GREEN: 0.65,
            PCT_ORANGE: 0.20,
            PCT_RED: 0.05,
            PCT_BROWN: 0.10,
            COLOR_GREEN: 0x1b5e20,
            COLOR_ORANGE: 0x8a4917,
            COLOR_RED: 0x6e1b17,
            COLOR_BROWN: 0x4a2b13
        };

        const PCT_GREEN  = tune.PCT_GREEN;
        const PCT_ORANGE = tune.PCT_ORANGE;
        const PCT_RED    = tune.PCT_RED;
        const PCT_BROWN  = tune.PCT_BROWN;

        const COLOR_GREEN  = tune.COLOR_GREEN;
        const COLOR_ORANGE = tune.COLOR_ORANGE;
        const COLOR_RED    = tune.COLOR_RED;
        const COLOR_BROWN  = tune.COLOR_BROWN;

        const totalPct = PCT_GREEN + PCT_ORANGE + PCT_RED + PCT_BROWN;
        const pickLeafHex = () => {
            const r0 = Math.random() * totalPct;
            if (r0 < PCT_GREEN) return COLOR_GREEN;
            if (r0 < PCT_GREEN + PCT_ORANGE) return COLOR_ORANGE;
            if (r0 < PCT_GREEN + PCT_ORANGE + PCT_RED) return COLOR_RED;
            return COLOR_BROWN;
        };

        const geo = new Zt;
        const count = 2000;
        const pos = new Float32Array(count * 3);
        const aScale = new Float32Array(count);
        const aSpeed = new Float32Array(count);
        const aRotSpeed = new Float32Array(count);
        const aRotOffset = new Float32Array(count);
        const aPhase = new Float32Array(count);
        const colors = new Float32Array(count * 3);

        const bounds = { x: 80, y: 55, z: 160 };

        for (let i = 0; i < count; i++) {
            const c = i * 3;
            pos[c]     = (Math.random() - .5) * 2 * bounds.x;
            pos[c + 1] = -10 + Math.random() * bounds.y;
            pos[c + 2] = (Math.random() - .5) * 2 * bounds.z;

            aScale[i] = 0.7 + Math.random() * 1.1;
            aSpeed[i] = 0.9 + Math.random() * 2.2;

            aRotSpeed[i] = (Math.random() - 0.5) * 4.5;
            aRotOffset[i] = Math.random() * Math.PI * 2;
            aPhase[i] = Math.random() * Math.PI * 2;

            const hex = pickLeafHex();
            colors[c]     = ((hex >> 16) & 255) / 255;
            colors[c + 1] = ((hex >> 8) & 255) / 255;
            colors[c + 2] = (hex & 255) / 255;
        }

        geo.setAttribute("position", new Tt(pos,3));
        geo.setAttribute("aScale", new Tt(aScale,1));
        geo.setAttribute("aSpeed", new Tt(aSpeed,1));
        geo.setAttribute("aRotSpeed", new Tt(aRotSpeed,1));
        geo.setAttribute("aRotOffset", new Tt(aRotOffset,1));
        geo.setAttribute("aPhase", new Tt(aPhase,1));
        geo.setAttribute("color", new Tt(colors,3));

        const mat = new Zn({
            depthWrite: !1,
            transparent: !0,
            vertexColors: !0,
            vertexShader: iL,
            fragmentShader: rL,
            fog: !0,
            uniforms: wc.merge([Me.fog, {
                uSize: { value: 180 * this.renderer.getPixelRatio() },
                uTime: { value: 0 },
                uLowBound: { value: -10 },
                uHighBound: { value: -10 + bounds.y },
                uLeftBound: { value: -bounds.x },
                uRightBound: { value: bounds.x },
                uShiftX: { value: 0 }
            }])
        });

        const pts = new H1(geo, mat);
        pts.name = "leafFall";
        pts.renderOrder = 2;
        this.scene.add(pts);
        return pts;
    }
}
const pR = {
    id: "threejs-container"
}
  , mR = $i({
    __name: "ThreeJS",
    setup(n) {
        const e = Rn();
        return js( () => {
            if (!e.value)
                return new Error("Canvas not found");
            const t = !1;
            new ThreeScene(e.value,t)
        }
        ),
        (t, i) => (Wn(),
        iu("div", pR, [ru("div", {
            id: "threejs",
            ref_key: "canvasParent",
            ref: e
        }, null, 512)]))
    }
});
const mg = (n, e) => {
    const t = n.__vccOpts || n;
    for (const [i,r] of e)
        t[i] = r;
    return t
}
  , gR = mR , _R = $i({
    name: "ClientOnly",
    inheritAttrs: !1,
    props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
    setup(n, {slots: e, attrs: t}) {
        const i = Rn(!1);
        return js( () => {
            i.value = !0
        }
        ),
        r => {
            var l;
            if (i.value)
                return (l = e.default) == null ? void 0 : l.call(e);
            const s = e.fallback || e.placeholder;
            if (s)
                return s();
            const o = r.fallback || r.placeholder || ""
              , a = r.fallbackTag || r.placeholderTag || "span";
            return iu(a, t, o)
        }
    }
})
  , vR = (n, e) => e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, t => {
    var i;
    return ((i = n.params[t.slice(1)]) == null ? void 0 : i.toString()) || ""
}
)
  , Nc = (n, e) => {
    const t = n.route.matched.find(r => {
        var s;
        return ((s = r.components) == null ? void 0 : s.default) === n.Component.type
    }
    )
      , i = e ?? (t == null ? void 0 : t.meta.key) ?? (t && vR(n.route, t));
    return typeof i == "function" ? i(n.route) : i
}
  , xR = (n, e) => ({
    default: () => n ? Kn(G_, n === !0 ? {} : n, e) : e
})
  , yR = $i({
    name: "RouteProvider",
    props: {
        vnode: {
            type: Object,
            required: !0
        },
        route: {
            type: Object,
            required: !0
        },
        vnodeRef: Object,
        renderKey: String,
        trackRootNodes: Boolean
    },
    setup(n) {
        const e = n.renderKey
          , t = n.route
          , i = {};
        for (const r in n.route)
            Object.defineProperty(i, r, {
                get: () => e === n.renderKey ? n.route[r] : t[r]
            });
        return Rr(Ra, Xs(i)),
        () => Kn(n.vnode, {
            ref: n.vnodeRef
        })
    }
})
  , MR = (n, e, t) => (e = e === !0 ? {} : e,
{
    default: () => {
        var i;
        return e ? Kn(n, e, t) : (i = t.default) == null ? void 0 : i.call(t)
    }
})
  , SR = $i({
    name: "NuxtPage",
    inheritAttrs: !1,
    props: {
        name: {
            type: String
        },
        transition: {
            type: [Boolean, Object],
            default: void 0
        },
        keepalive: {
            type: [Boolean, Object],
            default: void 0
        },
        route: {
            type: Object
        },
        pageKey: {
            type: [Function, String],
            default: null
        }
    },
    setup(n, {attrs: e, expose: t}) {
        const i = ft()
          , r = Rn()
          , s = Jt(Ra, null);
        t({
            pageRef: r
        });
        const o = Jt(sy, null);
        let a;
        const l = i.deferHydration();
        return () => Kn(Tm, {
            name: n.name,
            route: n.route,
            ...e
        }, {
            default: c => {
                const u = TR(s, c.route, c.Component)
                  , h = s && s.matched.length === c.route.matched.length;
                if (!c.Component)
                    return a && !h ? a : void 0;
                if (a && o && !o.isCurrent(c.route))
                    return a;
                if (u && s && (!o || o != null && o.isCurrent(s)))
                    return h ? a : null;
                const f = Nc(c, n.pageKey)
                  , p = !!(n.transition ?? c.route.meta.pageTransition ?? gc)
                  , g = p && bR([n.transition, c.route.meta.pageTransition, gc, {
                    onAfterLeave: () => {
                        i.callHook("page:transition:finish", c.Component)
                    }
                }].filter(Boolean));
                return a = MR(cu, p && g, xR(n.keepalive ?? c.route.meta.keepalive ?? hy, Kn(fp, {
                    suspensible: !0,
                    onPending: () => i.callHook("page:start", c.Component),
                    onResolve: () => {
                        jr( () => i.callHook("page:finish", c.Component).finally(l))
                    }
                }, {
                    default: () => Kn(yR, {
                        key: f,
                        vnode: c.Component,
                        route: c.route,
                        renderKey: f,
                        trackRootNodes: p,
                        vnodeRef: r
                    })
                }))).default(),
                a
            }
        })
    }
});
function ER(n) {
    return Array.isArray(n) ? n : n ? [n] : []
}
function bR(n) {
    const e = n.map(t => ({
        ...t,
        onAfterLeave: ER(t.onAfterLeave)
    }));
    return Qx(...e)
}
function TR(n, e, t) {
    if (!n)
        return !1;
    const i = e.matched.findIndex(r => {
        var s;
        return ((s = r.components) == null ? void 0 : s.default) === (t == null ? void 0 : t.type)
    }
    );
    return !i || i === -1 ? !1 : e.matched.slice(0, i).some( (r, s) => {
        var o, a, l;
        return ((o = r.components) == null ? void 0 : o.default) !== ((l = (a = n.matched[s]) == null ? void 0 : a.components) == null ? void 0 : l.default)
    }
    ) || t && Nc({
        route: e,
        Component: t
    }) !== Nc({
        route: n,
        Component: t
    })
}
const wR = {}
  , AR = {
    id: "main-app"
};
function RR(n, e) {
    const t = gR
      , i = _R
      , r = SR;
    return Wn(),
    iu("div", AR, [at(i, null, {
        default: qc( () => [at(t)]),
        _: 1
    }), at(r)])
}
const CR = mg(wR, [["render", RR]])
  , PR = {
    __name: "nuxt-error-page",
    props: {
        error: Object
    },
    setup(n) {
        const t = n.error;
        (t.stack || "").split(`
`).splice(1).map(h => ({
            text: h.replace("webpack:/", "").replace(".vue", ".js").trim(),
            internal: h.includes("node_modules") && !h.includes(".cache") || h.includes("internal") || h.includes("new Promise")
        })).map(h => `<span class="stack${h.internal ? " internal" : ""}">${h.text}</span>`).join(`
`);
        const i = Number(t.statusCode || 500)
          , r = i === 404
          , s = t.statusMessage ?? (r ? "Page Not Found" : "Internal Server Error")
          , o = t.message || t.toString()
          , a = void 0
          , u = r ? $u( () => lc( () => import("./error_404.js"), ["./error_404.js", "./vue.js", "./error_404.css"], import.meta.url).then(h => h.default || h)) : $u( () => lc( () => import("./error_500.js"), ["./error_500.js", "./vue.js", "./error_500.css"], import.meta.url).then(h => h.default || h));
        return (h, f) => (Wn(),
        pr(st(u), Ng(Op({
            statusCode: st(i),
            statusMessage: st(s),
            description: st(o),
            stack: st(a)
        })), null, 16))
    }
}
  , LR = PR
  , DR = {
    __name: "nuxt-root",
    setup(n) {
        const e = () => null
          , t = ft()
          , i = t.deferHydration()
          , r = !1;
        Rr(Ra, um()),
        t.hooks.callHookWith(a => a.map(l => l()), "vue:setup");
        const s = Ca();
        Mp( (a, l, c) => {
            if (t.hooks.callHook("vue:error", a, l, c).catch(u => console.error("[nuxt] Error in `vue:error` hook", u)),
            ly(a) && (a.fatal || a.unhandled))
                return t.runWithContext( () => xr(a)),
                !1
        }
        );
        const o = !1;
        return (a, l) => (Wn(),
        pr(fp, {
            onResolve: st(i)
        }, {
            default: qc( () => [st(s) ? (Wn(),
            pr(st(LR), {
                key: 0,
                error: st(s)
            }, null, 8, ["error"])) : st(o) ? (Wn(),
            pr(st(e), {
                key: 1,
                context: st(o)
            }, null, 8, ["context"])) : st(r) ? (Wn(),
            pr(J_(st(r)), {
                key: 2
            })) : (Wn(),
            pr(st(CR), {
                key: 3
            }))]),
            _: 1
        }, 8, ["onResolve"]))
    }
}
  , Ud = DR;
globalThis.$fetch || (globalThis.$fetch = X0.create({
    baseURL: j0()
}));
let Nd;
{
    let n;
    Nd = async function() {
        var s, o;
        if (n)
            return n;
        const i = !!((s = window.__NUXT__) != null && s.serverRendered || ((o = document.getElementById("__NUXT_DATA__")) == null ? void 0 : o.dataset.ssr) === "true") ? Qv(Ud) : Zv(Ud)
          , r = ox({
            vueApp: i
        });
        try {
            await lx(r, IM)
        } catch (a) {
            await r.callHook("app:error", a),
            r.payload.error = r.payload.error || a
        }
        try {
            await r.hooks.callHook("app:created", i),
            await r.hooks.callHook("app:beforeMount", i),
            i.mount(document.querySelector("#__nuxt") ? "#__nuxt" : (document.querySelector("#scripts") ? "#scripts" : "body")),
            await r.hooks.callHook("app:mounted", i),
            await jr()
        } catch (a) {
            await r.callHook("app:error", a),
            r.payload.error = r.payload.error || a
        }
        return i
    }
    ,
    n = Nd().catch(e => {
        console.error("Error while mounting app:", e)
    }
    )
}
export {FR as A, BR as B, st as C, _h as D, qs as E, nn as F, Qx as G, d0 as H, kR as I, Aa as J, va as K, HR as L, GR as M, OR as N, ms as O, W_ as P, V_ as Q, cc as R, ou as S, mg as _, cy as a, Lh as b, _n as c, $i as d, Qc as e, WR as f, Kn as g, Ks as h, zR as i, g0 as j, Kp as k, ft as l, Wn as m, VR as n, js as o, wa as p, iu as q, Rn as r, ru as s, UR as t, Ki as u, at as v, sc as w, qc as x, zp as y, NR as z};